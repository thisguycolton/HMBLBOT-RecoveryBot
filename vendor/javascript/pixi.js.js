// pixi.js@8.8.1 downloaded from https://ga.jspm.io/npm:pixi.js@8.8.1/lib/index.mjs

import{E as X,e as Y}from"../_/CiJNseos.js";export{n as normalizeExtensionPriority}from"../_/CiJNseos.js";import{c as $,d as Z,V as J,a as ee,b as te}from"../_/b97imLX8.js";export{A as AlphaMask,C as ColorMask,f as Spritesheet,S as StencilMask,e as autoDetectSource,g as getMatrixRelativeToParent,r as resourceToTexture,s as spritesheetAsset,t as textureFrom}from"../_/b97imLX8.js";export{A as AccessibilitySystem,a as accessibilityTarget,i as isMobile}from"../_/A6T_GEhI.js";import{F as re}from"../_/C5fbq_ax.js";export{B as BlendModeFilter,C as ColorBlend,a as ColorBurnBlend,b as ColorDodgeBlend,D as DarkenBlend,c as DifferenceBlend,d as DivideBlend,E as ExclusionBlend,H as HardLightBlend,e as HardMixBlend,L as LightenBlend,f as LinearBurnBlend,g as LinearDodgeBlend,h as LinearLightBlend,i as LuminosityBlend,N as NegationBlend,O as OverlayBlend,P as PinLightBlend,S as SaturationBlend,j as SoftLightBlend,k as SubtractBlend,V as VividLightBlend,l as blendTemplateFrag,m as blendTemplateVert,n as blendTemplateWgsl,o as hslgl,p as hslgpu}from"../_/C5fbq_ax.js";import{i as se,a as ne,c as ie,b as oe}from"../_/DnqLVFh0.js";export{C as CompressedSource,e as getSupportedCompressedTextureFormats,d as getSupportedGPUCompressedTextureFormats,g as getSupportedGlCompressedTextureFormats,f as getSupportedTextureFormats,n as nonCompressedFormats}from"../_/DnqLVFh0.js";import{A as ae,C as ue,S as ce}from"../_/DuCuI9aN.js";export{a as autoDetectEnvironment,l as loadEnvironmentExtensions,u as unsafeEvalSupported}from"../_/DuCuI9aN.js";import{C as le,g as de,F as he,U as pe,a as fe,b as me,m as ge,c as _e,d as xe,e as be}from"../_/BBV-ZAnR.js";export{M as MaskEffectManager,h as MaskEffectManagerClass,R as RenderGroup,y as UPDATE_TRANSFORM,_ as _getGlobalBounds,j as boundsPool,l as cacheAsTextureMixin,z as checkChildrenDidChange,n as childrenHelperMixin,o as collectRenderablesMixin,f as cullingMixin,p as effectsMixin,q as findMixin,r as getFastGlobalBoundsMixin,s as getGlobalMixin,i as getParent,k as matrixPool,t as measureMixin,v as onRenderMixin,A as removeItems,w as sortMixin,x as toLocalGlobalMixin,u as updateTransformBackwards}from"../_/BBV-ZAnR.js";export{default as EventEmitter}from"eventemitter3";import{d as ye,v as Te}from"../_/CPjYF1RQ.js";export{a as v8_3_4}from"../_/CPjYF1RQ.js";export{R as ResizePlugin,T as TickerPlugin}from"../_/DvZ4U84i.js";import{L as Se}from"../_/BKda9ZRN.js";import{D as ve}from"../_/HkcL8NV-.js";export{B as BrowserAdapter}from"../_/HkcL8NV-.js";import{p as Ge}from"../_/4-5TwXdf.js";import{R as Ee}from"../_/DDcfjY8w.js";import{T as Ae,a as Pe,b as Ce,g as Re,d as Be}from"../_/DN9TJOna.js";export{B as BufferImageSource,N as NOOP,c as TextureStyle,i as isPow2,l as log2,n as nextPow2}from"../_/DN9TJOna.js";import{A as we,B as Me}from"../_/ZIAmBQy2.js";export{D as DynamicBitmapFont,G as Graphics,g as getBitmapTextLayout,r as resolveCharacters}from"../_/ZIAmBQy2.js";import{w as Fe}from"../_/qbTIbSEt.js";import{c as Ue,C as Ie}from"../_/DW2zM9-A.js";import{i as Oe,R as ke}from"../_/JDZVCazy.js";export{c as createStringVariations,g as getUrlExtension}from"../_/JDZVCazy.js";import{I as Le,G as De,s as Ne,C as He,a as Ve,T as We}from"../_/DBd3_jFZ.js";export{c as CanvasPoolClass,b as Circle,E as Ellipse,F as FillGradient,i as FillPattern,P as Polygon,R as RoundedRectangle,q as SVGParser,S as ShapePath,d as buildAdaptiveBezier,e as buildAdaptiveQuadratic,f as buildArc,g as buildArcTo,h as buildArcToSvg,t as extractSvgUrlId,w as generateTextStyleKey,m as parseAttribute,p as parseSVGDefinitions,k as parseSVGFloatAttribute,l as parseSVGPath,n as parseSVGStyle,r as roundedShapeArc,j as roundedShapeQuadraticCurve,o as styleAttributes,u as toFillStyle,v as toStrokeStyle}from"../_/DBd3_jFZ.js";import{C as je}from"../_/DR01RAnB.js";export{b as basisTranscoderUrls,d as detectBasis,l as loadBasis,a as loadBasisOnWorker,s as setBasisTranscoderPath}from"../_/Bt26cKJA.js";export{D as D3D10_RESOURCE_DIMENSION,a as D3DFMT,b as DDS,c as DXGI_FORMAT,d as DXGI_TO_TEXTURE_FORMAT,F as FOURCC_TO_TEXTURE_FORMAT,T as TEXTURE_FORMAT_BLOCK_SIZE,l as loadDDS,p as parseDDS}from"../_/qowhR8Gb.js";export{G as GL_INTERNAL_FORMAT,K as KTX,l as loadKTX,p as parseKTX}from"../_/uxwc9i8j.js";export{k as ktxTranscoderUrls,l as loadKTX2,a as loadKTX2onWorker,s as setKTXTranscoderPath}from"../_/ryOcviRR.js";export{d as detectCompressed,r as resolveCompressedTextureUrl,v as validFormats}from"../_/BCXSZoOU.js";import{B as ze}from"../_/CsGVij7-.js";import{DOMParser as Xe}from"@xmldom/xmldom";export{E as EventBoundary,a as EventSystem,b as EventsTicker,F as FederatedContainer,c as FederatedMouseEvent,d as FederatedPointerEvent,e as FederatedWheelEvent}from"../_/w_e3mqNd.js";export{F as FederatedEvent}from"../_/B7IZNnRw.js";import{G as Ye,a as Ke,S as $e}from"../_/B1rjliXi.js";export{k as ShaderStage,b as addProgramDefines,e as ensurePrecision,d as extractAttributesFromGpuProgram,f as extractStructAndGroups,h as generateGpuLayoutGroups,j as generateLayoutHash,g as getMaxFragmentPrecision,i as insertVersion,r as removeStructAndGroupDuplicates,s as setProgramName,c as stripVersion}from"../_/B1rjliXi.js";import{U as qe,c as Qe}from"../_/N1sZULdm.js";export{a as UNIFORM_TYPES_MAP,b as UNIFORM_TYPES_VALUES,g as getDefaultUniformValue}from"../_/N1sZULdm.js";import{T as Ze}from"../_/Bt1AfHFn.js";export{a as TexturePoolClass}from"../_/Bt1AfHFn.js";import{R as Je}from"../_/dln5bN8k.js";import{M as et,u as tt}from"../_/QtJKG6EO.js";export{D as DEG_TO_RAD,P as PI_2,R as RAD_TO_DEG,r as resetUids}from"../_/QtJKG6EO.js";import{P as rt}from"../_/wEroH2_d.js";import{S as st}from"../_/CL51fjbJ.js";export{F as FilterPipe,a as FilterSystem,g as getGlobalRenderableBounds}from"../_/CFqaBCht.js";import{O as nt}from"../_/1bJPxWU2.js";import{M as it}from"../_/BUiFVagV.js";export{d as AbstractText,A as AnimatedSprite,B as BitmapText,H as HTMLText,P as PrepareBase,a as PrepareQueue,b as PrepareSystem,c as PrepareUpload,f as Text,T as TilingSprite,g as Transform,e as ensureTextOptions,p as pointInTriangle}from"../_/BUiFVagV.js";import{S as ot}from"../_/UhTenTEy.js";import{g as at}from"../_/jGuOKWmV.js";export{c as checkMaxIfStatementsInShader}from"../_/jGuOKWmV.js";import{g as ut,D as ct,c as lt,a as dt,b as ht,f as pt,d as ft,e as mt,h as gt,i as _t,j as xt,k as bt,t as yt,l as Tt,m as St}from"../_/BrPk-uEK.js";export{B as Batch,o as BatchGeometry,p as BatchTextureArray,r as BatchableGraphics,n as Batcher,q as DefaultShader,G as GpuGraphicsContext,z as GraphicsContextRenderData,A as GraphicsContextSystem,C as buildContextBatches,s as buildEllipse,v as buildLine,w as buildPixelLine,u as buildRoundedRectangle,x as closePointEps,y as curveEps,F as generateTextureMatrix,H as getOrientationOfPoints,E as shapeBuilders,I as triangulateWithHoles}from"../_/BrPk-uEK.js";import{c as vt,r as Gt,a as Et,b as At}from"../_/D26BwMap.js";export{f as addBits,d as compileHighShader,e as compileHighShaderGl,g as compileHooks,i as compileInputs,j as compileOutputs,h as findHooksRx,l as fragmentGPUTemplate,m as fragmentGlTemplate,o as globalUniformsBit,p as globalUniformsBitGl,q as globalUniformsUBOBitGl,k as injectBits,v as vertexGPUTemplate,n as vertexGlTemplate}from"../_/D26BwMap.js";import{l as Pt,a as Ct,b as Rt}from"../_/CjPof6iF.js";export{Q as QuadGeometry,d as TilingSpritePipe,T as TilingSpriteShader,e as applyMatrix,s as setPositions,f as setUvs,t as tilingBit,c as tilingBitGl}from"../_/CjPof6iF.js";import{B as Bt}from"../_/hsnQZ5mO.js";export{P as Pool,a as PoolGroupClass}from"../_/hsnQZ5mO.js";import{S as wt}from"../_/BmZ-QKv3.js";export{B as BLEND_TO_NPM,g as getAdjustedBlendModeBlend}from"../_/BmZ-QKv3.js";import{B as Mt,G as Ft,a as Ut}from"../_/DzkTbokL.js";export{e as ensureIsBuffer,g as getGeometryBounds}from"../_/DzkTbokL.js";import{g as It}from"../_/RB1t9lbT.js";export{a as getTestContext}from"../_/RB1t9lbT.js";import{G as Ot,a as kt,b as Lt,B as Dt,c as Nt}from"../_/x2XrsuZw.js";export{d as GlProgramData,I as IGLUniformData,U as UNIFORM_TO_ARRAY_SETTERS,s as UNIFORM_TO_SINGLE_SETTERS,x as UboSystem,t as WGSL_ALIGN_SIZE_DATA,W as WGSL_TO_STD40_SIZE,e as compileShader,o as createUboElementsSTD40,u as createUboElementsWGSL,y as createUboSyncFunction,p as createUboSyncFunctionSTD40,v as createUboSyncFunctionWGSL,f as defaultValue,h as extractAttributesFromGlProgram,q as generateArraySyncSTD40,w as generateArraySyncWGSL,i as generateProgram,g as generateShaderSyncCode,r as generateUniformsSync,j as getUboData,k as getUniformData,l as logProgramError,m as mapGlToVertexFormat,n as mapType,z as uboSyncFunctionsSTD40,A as uboSyncFunctionsWGSL,C as uniformParsers}from"../_/x2XrsuZw.js";import{C as Ht}from"../_/YVRvxIGW.js";import{B as Vt}from"../_/5DsnQy3t.js";export{g as getPo2TextureFromSource,u as updateTextBounds}from"../_/5DsnQy3t.js";import{c as Wt}from"../_/B4-0cGBG.js";export{a as colorToUniform}from"../_/B4-0cGBG.js";import{B as jt}from"../_/CIFQ1GZP.js";import{T as zt}from"../_/CS2AEeyh.js";export{a as TickerListener,U as UPDATE_PRIORITY}from"../_/CS2AEeyh.js";export{I as InstructionSet,m as multiplyHexColors}from"../_/DFYKVwmy.js";import{V as Xt}from"../_/BxjtIPS9.js";export{G as GraphicsPipe}from"../_/Dlt4gw4y.js";import{M as Yt}from"../_/CNOFbz8x.js";import{P as Kt,N as $t}from"../_/C7uk_vW2.js";export{a as NineSliceSpritePipe}from"../_/C7uk_vW2.js";export{B as BatchableMesh}from"../_/BfM6YPQq.js";export{M as MeshPipe}from"../_/iHODp7NU.js";export{G as GlParticleContainerAdaptor,b as GlParticleContainerPipe,a as GpuParticleContainerAdaptor,c as GpuParticleContainerPipe,P as ParticleContainerPipe,d as ParticleShader,f as particlesFrag,v as particlesVert,w as particlesWgsl}from"../_/CPujgGRB.js";export{P as ParticleBuffer,c as createIndicesForQuads,g as generateParticleUpdateFunction}from"../_/CpEZudLt.js";export{B as BitmapTextPipe,S as SdfShader,l as localUniformMSDFBit,a as localUniformMSDFBitGl,m as mSDFBit,b as mSDFBitGl}from"../_/C6gMCh65.js";export{F as FontStylePromiseCache,H as HTMLTextPipe,a as HTMLTextSystem,e as extractFontFamilies,g as getFontCss,b as getSVGUrl,c as getTemporaryCanvasFromImage,i as isSafari,l as loadFontAsBase64,d as loadFontCSS,f as loadSVGImage}from"../_/CJ5K_S46.js";import{H as qt}from"../_/CcHSFJgH.js";export{a as HTMLTextRenderData,m as measureHtmlText,n as nssvg,b as nsxhtml,t as textStyleToCSS}from"../_/CcHSFJgH.js";export{C as CanvasTextMetrics,f as fontStringFromTextStyle,g as getCanvasFillStyle}from"../_/Ha33ZdNF.js";export{C as CanvasTextPipe,a as CanvasTextSystem,g as getCanvasBoundingBox}from"../_/Crg0hAsf.js";export{u as updateQuadBounds}from"../_/C_-5p3ds.js";export{V as ViewableBuffer}from"../_/CoNQyFVH.js";export{default as earcut}from"earcut";import"ismobilejs";import"parse-svg-path";import"@pixi/colord";import"@pixi/colord/plugins/names";"use strict";const Qt={extension:{type:X.Environment,name:"browser",priority:-1},test:()=>true,load:async()=>{await import("./environment-browser/browserAll.mjs")}};"use strict";const Zt={extension:{type:X.Environment,name:"webworker",priority:0},test:()=>typeof self!=="undefined"&&self.WorkerGlobalScope!==void 0,load:async()=>{await import("./environment-webworker/webworkerAll.mjs")}};"use strict";"use strict";"use strict";const Jt=["webgl","webgpu","canvas"];async function autoDetectRenderer(e){let t=[];if(e.preference){t.push(e.preference);Jt.forEach((r=>{r!==e.preference&&t.push(r)}))}else t=Jt.slice();let r;let s={};for(let n=0;n<t.length;n++){const i=t[n];if(i==="webgpu"&&await se()){const{WebGPURenderer:t}=await Promise.resolve().then((function(){return di}));r=t;s={...e,...e.webgpu};break}if(i==="webgl"&&ne(e.failIfMajorPerformanceCaveat??ae.defaultOptions.failIfMajorPerformanceCaveat)){const{WebGLRenderer:t}=await Promise.resolve().then((function(){return $n}));r=t;s={...e,...e.webgl};break}if(i==="canvas"){s={...e};throw new Error("CanvasRenderer is not yet implemented")}}delete s.webgpu;delete s.webgl;if(!r)throw new Error("No available renderer for the current environment");const n=new r;await n.init(s);return n}"use strict";const er=/^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;const tr="8.8.1";"use strict";class ApplicationInitHook{static init(){globalThis.__PIXI_APP_INIT__?.(this,tr)}static destroy(){}}ApplicationInitHook.extension=X.Application;class RendererInitHook{constructor(e){this._renderer=e}init(){globalThis.__PIXI_RENDERER_INIT__?.(this._renderer,tr)}destroy(){this._renderer=null}}RendererInitHook.extension={type:[X.WebGLSystem,X.WebGPUSystem],name:"initHook",priority:-10};"use strict";const rr=class _Application{constructor(...e){this.stage=new le;e[0]!==void 0&&ye(Te,"Application constructor options are deprecated, please use Application.init() instead.")}
/**
   * @param options - The optional application and renderer parameters.
   */async init(e){e={...e};this.renderer=await autoDetectRenderer(e);_Application._plugins.forEach((t=>{t.init.call(this,e)}))}render(){this.renderer.render({container:this.stage})}get canvas(){return this.renderer.canvas}
/**
   * Reference to the renderer's canvas element.
   * @member {HTMLCanvasElement}
   * @deprecated since 8.0.0
   */get view(){ye(Te,"Application.view is deprecated, please use Application.canvas instead.");return this.renderer.canvas}get screen(){return this.renderer.screen}
/**
   * Destroys the application and all of its resources.
   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.
   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.
   * @param {object|boolean} [options=false] - The options for destroying the stage.
   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method
   * called as well. `options` will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.
   * If options.children is set to true,
   * it should destroy the texture of the child sprite.
   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
   *  If options.children is set to true,
   * it should destroy the texture source of the child sprite.
   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
   * If options.children is set to true,
   * it should destroy the context of the child graphics.
   */destroy(e=false,t=false){const r=_Application._plugins.slice(0);r.reverse();r.forEach((e=>{e.destroy.call(this)}));this.stage.destroy(t);this.stage=null;this.renderer.destroy(e);this.renderer=null}};rr._plugins=[];let sr=rr;Y.handleByList(X.Application,sr._plugins);Y.add(ApplicationInitHook);"use strict";"use strict";"use strict";class BitmapFont extends we{constructor(e,t){super();const{textures:r,data:s}=e;Object.keys(s.pages).forEach((e=>{const t=s.pages[parseInt(e,10)];const n=r[t.id];this.pages.push({texture:n})}));Object.keys(s.chars).forEach((e=>{const t=s.chars[e];const{frame:n,source:i}=r[t.page];const o=new Ee(t.x+n.x,t.y+n.y,t.width,t.height);const a=new Ae({source:i,frame:o});this.chars[e]={id:e.codePointAt(0),xOffset:t.xOffset,yOffset:t.yOffset,xAdvance:t.xAdvance,kerning:t.kerning??{},texture:a}}));this.baseRenderedFontSize=s.fontSize;this.baseMeasurementFontSize=s.fontSize;this.fontMetrics={ascent:0,descent:0,fontSize:s.fontSize};this.baseLineOffset=s.baseLineOffset;this.lineHeight=s.lineHeight;this.fontFamily=s.fontFamily;this.distanceField=s.distanceField??{type:"none",range:0};this.url=t}destroy(){super.destroy();for(let e=0;e<this.pages.length;e++){const{texture:t}=this.pages[e];t.destroy(true)}this.pages=null}
/**
   * Generates a bitmap-font for the given style and character set
   * @param options - Setup options for font generation.
   * @returns Font generated by style options.
   * @example
   * import { BitmapFont, BitmapText } from 'pixi.js';
   *
   * BitmapFont.install('TitleFont', {
   *     fontFamily: 'Arial',
   *     fontSize: 12,
   *     strokeThickness: 2,
   *     fill: 'purple',
   * });
   *
   * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });
   */static install(e){Me.install(e)}
/**
   * Uninstalls a bitmap font from the cache.
   * @param {string} name - The name of the bitmap font to uninstall.
   */static uninstall(e){Me.uninstall(e)}}"use strict";const nr={test(e){return typeof e==="string"&&e.startsWith("info face=")},parse(e){const t=e.match(/^[a-z]+\s+.+$/gm);const r={info:[],common:[],page:[],char:[],chars:[],kerning:[],kernings:[],distanceField:[]};for(const e in t){const s=t[e].match(/^[a-z]+/gm)[0];const n=t[e].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);const i={};for(const e in n){const t=n[e].split("=");const r=t[0];const s=t[1].replace(/"/gm,"");const o=parseFloat(s);const a=isNaN(o)?s:o;i[r]=a}r[s].push(i)}const s={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0};const[n]=r.info;const[i]=r.common;const[o]=r.distanceField??[];o&&(s.distanceField={range:parseInt(o.distanceRange,10),type:o.fieldType});s.fontSize=parseInt(n.size,10);s.fontFamily=n.face;s.lineHeight=parseInt(i.lineHeight,10);const a=r.page;for(let e=0;e<a.length;e++)s.pages.push({id:parseInt(a[e].id,10)||0,file:a[e].file});const u={};s.baseLineOffset=s.lineHeight-parseInt(i.base,10);const c=r.char;for(let e=0;e<c.length;e++){const t=c[e];const r=parseInt(t.id,10);let n=t.letter??t.char??String.fromCharCode(r);n==="space"&&(n=" ");u[r]=n;s.chars[n]={id:r,page:parseInt(t.page,10)||0,x:parseInt(t.x,10),y:parseInt(t.y,10),width:parseInt(t.width,10),height:parseInt(t.height,10),xOffset:parseInt(t.xoffset,10),yOffset:parseInt(t.yoffset,10),xAdvance:parseInt(t.xadvance,10),kerning:{}}}const l=r.kerning||[];for(let e=0;e<l.length;e++){const t=parseInt(l[e].first,10);const r=parseInt(l[e].second,10);const n=parseInt(l[e].amount,10);s.chars[u[r]].kerning[u[t]]=n}return s}};"use strict";const ir={test(e){const t=e;return typeof t!=="string"&&"getElementsByTagName"in t&&t.getElementsByTagName("page").length&&t.getElementsByTagName("info")[0].getAttribute("face")!==null},parse(e){const t={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0};const r=e.getElementsByTagName("info")[0];const s=e.getElementsByTagName("common")[0];const n=e.getElementsByTagName("distanceField")[0];n&&(t.distanceField={type:n.getAttribute("fieldType"),range:parseInt(n.getAttribute("distanceRange"),10)});const i=e.getElementsByTagName("page");const o=e.getElementsByTagName("char");const a=e.getElementsByTagName("kerning");t.fontSize=parseInt(r.getAttribute("size"),10);t.fontFamily=r.getAttribute("face");t.lineHeight=parseInt(s.getAttribute("lineHeight"),10);for(let e=0;e<i.length;e++)t.pages.push({id:parseInt(i[e].getAttribute("id"),10)||0,file:i[e].getAttribute("file")});const u={};t.baseLineOffset=t.lineHeight-parseInt(s.getAttribute("base"),10);for(let e=0;e<o.length;e++){const r=o[e];const s=parseInt(r.getAttribute("id"),10);let n=r.getAttribute("letter")??r.getAttribute("char")??String.fromCharCode(s);n==="space"&&(n=" ");u[s]=n;t.chars[n]={id:s,page:parseInt(r.getAttribute("page"),10)||0,x:parseInt(r.getAttribute("x"),10),y:parseInt(r.getAttribute("y"),10),width:parseInt(r.getAttribute("width"),10),height:parseInt(r.getAttribute("height"),10),xOffset:parseInt(r.getAttribute("xoffset"),10),yOffset:parseInt(r.getAttribute("yoffset"),10),xAdvance:parseInt(r.getAttribute("xadvance"),10),kerning:{}}}for(let e=0;e<a.length;e++){const r=parseInt(a[e].getAttribute("first"),10);const s=parseInt(a[e].getAttribute("second"),10);const n=parseInt(a[e].getAttribute("amount"),10);t.chars[u[s]].kerning[u[r]]=n}return t}};"use strict";const or={test(e){return!(typeof e!=="string"||!e.includes("<font>"))&&ir.test(ve.get().parseXML(e))},parse(e){return ir.parse(ve.get().parseXML(e))}};"use strict";const ar=[".xml",".fnt"];const ur={extension:{type:X.CacheParser,name:"cacheBitmapFont"},test:e=>e instanceof BitmapFont,getCacheableAssets(e,t){const r={};e.forEach((e=>{r[e]=t;r[`${e}-bitmap`]=t}));r[`${t.fontFamily}-bitmap`]=t;return r}};const cr={extension:{type:X.LoadParser,priority:Se.Normal},name:"loadBitmapFont",test(e){return ar.includes(Ge.extname(e).toLowerCase())},async testParse(e){return nr.test(e)||or.test(e)},async parse(e,t,r){const s=nr.test(e)?nr.parse(e):or.parse(e);const{src:n}=t;const{pages:i}=s;const o=[];const a=s.distanceField?{scaleMode:"linear",alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:false,resolution:1}:{};for(let e=0;e<i.length;++e){const t=i[e].file;let r=Ge.join(Ge.dirname(n),t);r=$(r,n);o.push({src:r,data:a})}const u=await r.load(o);const c=o.map((e=>u[e.src]));const l=new BitmapFont({data:s,textures:c},n);return l},async load(e,t){const r=await ve.get().fetch(e);return await r.text()},async unload(e,t,r){await Promise.all(e.pages.map((e=>r.unload(e.texture.source._sourceOrigin))));e.destroy()}};"use strict";class BackgroundLoader{
/**
   * @param loader
   * @param verbose - should the loader log to the console
   */
constructor(e,t=false){this._loader=e;this._assetList=[];this._isLoading=false;this._maxConcurrent=1;this.verbose=t}
/**
   * Adds an array of assets to load.
   * @param assetUrls - assets to load
   */add(e){e.forEach((e=>{this._assetList.push(e)}));this.verbose&&console.log("[BackgroundLoader] assets: ",this._assetList);this._isActive&&!this._isLoading&&void this._next()}async _next(){if(this._assetList.length&&this._isActive){this._isLoading=true;const e=[];const t=Math.min(this._assetList.length,this._maxConcurrent);for(let r=0;r<t;r++)e.push(this._assetList.pop());await this._loader.load(e);this._isLoading=false;void this._next()}}
/**
   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.
   * @returns whether the class is active
   */get active(){return this._isActive}set active(e){if(this._isActive!==e){this._isActive=e;e&&!this._isLoading&&void this._next()}}}"use strict";const lr={extension:{type:X.CacheParser,name:"cacheTextureArray"},test:e=>Array.isArray(e)&&e.every((e=>e instanceof Ae)),getCacheableAssets:(e,t)=>{const r={};e.forEach((e=>{t.forEach(((t,s)=>{r[e+(s===0?"":s+1)]=t}))}));return r}};"use strict";async function testImageFormat(e){if("Image"in globalThis)return new Promise((t=>{const r=new Image;r.onload=()=>{t(true)};r.onerror=()=>{t(false)};r.src=e}));if("createImageBitmap"in globalThis&&"fetch"in globalThis){try{const t=await(await fetch(e)).blob();await createImageBitmap(t)}catch(e){return false}return true}return false}"use strict";const dr={extension:{type:X.DetectionParser,priority:1},test:async()=>testImageFormat("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),add:async e=>[...e,"avif"],remove:async e=>e.filter((e=>e!=="avif"))};"use strict";const hr=["png","jpg","jpeg"];const pr={extension:{type:X.DetectionParser,priority:-1},test:()=>Promise.resolve(true),add:async e=>[...e,...hr],remove:async e=>e.filter((e=>!hr.includes(e)))};"use strict";const fr="WorkerGlobalScope"in globalThis&&globalThis instanceof globalThis.WorkerGlobalScope;function testVideoFormat(e){if(fr)return false;const t=document.createElement("video");return t.canPlayType(e)!==""}"use strict";const mr={extension:{type:X.DetectionParser,priority:0},test:async()=>testVideoFormat("video/mp4"),add:async e=>[...e,"mp4","m4v"],remove:async e=>e.filter((e=>e!=="mp4"&&e!=="m4v"))};"use strict";const gr={extension:{type:X.DetectionParser,priority:0},test:async()=>testVideoFormat("video/ogg"),add:async e=>[...e,"ogv"],remove:async e=>e.filter((e=>e!=="ogv"))};"use strict";const _r={extension:{type:X.DetectionParser,priority:0},test:async()=>testVideoFormat("video/webm"),add:async e=>[...e,"webm"],remove:async e=>e.filter((e=>e!=="webm"))};"use strict";const xr={extension:{type:X.DetectionParser,priority:0},test:async()=>testImageFormat("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),add:async e=>[...e,"webp"],remove:async e=>e.filter((e=>e!=="webp"))};"use strict";class Loader{constructor(){this._parsers=[];this._parsersValidated=false;
/**
     * All loader parsers registered
     * @type {assets.LoaderParser[]}
     */this.parsers=new Proxy(this._parsers,{set:(e,t,r)=>{this._parsersValidated=false;e[t]=r;return true}});this.promiseCache={}}reset(){this._parsersValidated=false;this.promiseCache={}}
/**
   * Used internally to generate a promise for the asset to be loaded.
   * @param url - The URL to be loaded
   * @param data - any custom additional information relevant to the asset being loaded
   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
   */_getLoadPromiseAndParser(e,t){const r={promise:null,parser:null};r.promise=(async()=>{let s=null;let n=null;if(t.loadParser){n=this._parserHash[t.loadParser];n||Fe(`[Assets] specified load parser "${t.loadParser}" not found while loading ${e}`)}if(!n){for(let r=0;r<this.parsers.length;r++){const s=this.parsers[r];if(s.load&&s.test?.(e,t,this)){n=s;break}}if(!n){Fe(`[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);return null}}s=await n.load(e,t,this);r.parser=n;for(let e=0;e<this.parsers.length;e++){const n=this.parsers[e];if(n.parse&&n.parse&&await(n.testParse?.(s,t,this))){s=await n.parse(s,t,this)||s;r.parser=n}}return s})();return r}async load(e,t){this._parsersValidated||this._validateParsers();let r=0;const s={};const n=Oe(e);const i=Ue(e,(e=>({alias:[e],src:e,data:{}})));const o=i.length;const a=i.map((async e=>{const n=Ge.toAbsolute(e.src);if(!s[e.src])try{this.promiseCache[n]||(this.promiseCache[n]=this._getLoadPromiseAndParser(n,e));s[e.src]=await this.promiseCache[n].promise;t&&t(++r/o)}catch(t){delete this.promiseCache[n];delete s[e.src];throw new Error(`[Loader.load] Failed to load ${n}.\n${t}`)}}));await Promise.all(a);return n?s[i[0].src]:s}
/**
   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.
   * The parser that created the asset, will be the one that unloads it.
   * @example
   * // Single asset:
   * const asset = await Loader.load('cool.png');
   *
   * await Loader.unload('cool.png');
   *
   * console.log(asset.destroyed); // true
   * @param assetsToUnloadIn - urls that you want to unload, or a single one!
   */async unload(e){const t=Ue(e,(e=>({alias:[e],src:e})));const r=t.map((async e=>{const t=Ge.toAbsolute(e.src);const r=this.promiseCache[t];if(r){const s=await r.promise;delete this.promiseCache[t];await(r.parser?.unload?.(s,e,this))}}));await Promise.all(r)}_validateParsers(){this._parsersValidated=true;this._parserHash=this._parsers.filter((e=>e.name)).reduce(((e,t)=>{t.name?e[t.name]&&Fe(`[Assets] loadParser name conflict "${t.name}"`):Fe("[Assets] loadParser should have a name");return{...e,[t.name]:t}}),{})}}"use strict";function checkDataUrl(e,t){if(Array.isArray(t)){for(const r of t)if(e.startsWith(`data:${r}`))return true;return false}return e.startsWith(`data:${t}`)}"use strict";const br=".json";const yr="application/json";const Tr={extension:{type:X.LoadParser,priority:Se.Low},name:"loadJson",test(e){return checkDataUrl(e,yr)||ie(e,br)},async load(e){const t=await ve.get().fetch(e);const r=await t.json();return r}};"use strict";const Sr=".txt";const vr="text/plain";const Gr={name:"loadTxt",extension:{type:X.LoadParser,priority:Se.Low,name:"loadTxt"},test(e){return checkDataUrl(e,vr)||ie(e,Sr)},async load(e){const t=await ve.get().fetch(e);const r=await t.text();return r}};"use strict";const Er=["normal","bold","100","200","300","400","500","600","700","800","900"];const Ar=[".ttf",".otf",".woff",".woff2"];const Pr=["font/ttf","font/otf","font/woff","font/woff2"];const Cr=/^(--|-?[A-Z_])[0-9A-Z_-]*$/i;function getFontFamilyName(e){const t=Ge.extname(e);const r=Ge.basename(e,t);const s=r.replace(/(-|_)/g," ");const n=s.toLowerCase().split(" ").map((e=>e.charAt(0).toUpperCase()+e.slice(1)));let i=n.length>0;for(const e of n)if(!e.match(Cr)){i=false;break}let o=n.join(" ");i||(o=`"${o.replace(/[\\"]/g,"\\$&")}"`);return o}const Rr=/^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;function encodeURIWhenNeeded(e){return Rr.test(e)?e:encodeURI(e)}const Br={extension:{type:X.LoadParser,priority:Se.Low},name:"loadWebFont",test(e){return checkDataUrl(e,Pr)||ie(e,Ar)},async load(e,t){const r=ve.get().getFontFaceSet();if(r){const s=[];const n=t.data?.family??getFontFamilyName(e);const i=t.data?.weights?.filter((e=>Er.includes(e)))??["normal"];const o=t.data??{};for(let t=0;t<i.length;t++){const a=i[t];const u=new FontFace(n,`url(${encodeURIWhenNeeded(e)})`,{...o,weight:a});await u.load();r.add(u);s.push(u)}Ie.set(`${n}-and-url`,{url:e,fontFaces:s});return s.length===1?s[0]:s}Fe("[loadWebFont] FontFace API is not supported. Skipping loading font");return null},unload(e){(Array.isArray(e)?e:[e]).forEach((e=>{Ie.remove(`${e.family}-and-url`);ve.get().getFontFaceSet().delete(e)}))}};"use strict";function getResolutionOfUrl(e,t=1){const r=ke.RETINA_PREFIX?.exec(e);return r?parseFloat(r[1]):t}"use strict";const wr=".svg";const Mr="image/svg+xml";const Fr={extension:{type:X.LoadParser,priority:Se.Low,name:"loadSVG"},name:"loadSVG",config:{crossOrigin:"anonymous",parseAsGraphicsContext:false},test(e){return checkDataUrl(e,Mr)||ie(e,wr)},async load(e,t,r){return t.data?.parseAsGraphicsContext??this.config.parseAsGraphicsContext?loadAsGraphics(e):loadAsTexture(e,t,r,this.config.crossOrigin)},unload(e){e.destroy(true)}};async function loadAsTexture(e,t,r,s){const n=await ve.get().fetch(e);const i=await n.blob();const o=URL.createObjectURL(i);const a=new Image;a.src=o;a.crossOrigin=s;await a.decode();URL.revokeObjectURL(o);const u=document.createElement("canvas");const c=u.getContext("2d");const l=t.data?.resolution||getResolutionOfUrl(e);const d=t.data?.width??a.width;const h=t.data?.height??a.height;u.width=d*l;u.height=h*l;c.drawImage(a,0,0,d*l,h*l);const{parseAsGraphicsContext:p,...f}=t.data??{};const m=new Le({resource:u,alphaMode:"premultiply-alpha-on-upload",resolution:l,...f});return oe(m,r,e)}async function loadAsGraphics(e){const t=await ve.get().fetch(e);const r=await t.text();const s=new De;s.svg(r);return s}const Ur='(function () {\n    \'use strict\';\n\n    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";\n    async function checkImageBitmap() {\n      try {\n        if (typeof createImageBitmap !== "function")\n          return false;\n        const response = await fetch(WHITE_PNG);\n        const imageBlob = await response.blob();\n        const imageBitmap = await createImageBitmap(imageBlob);\n        return imageBitmap.width === 1 && imageBitmap.height === 1;\n      } catch (_e) {\n        return false;\n      }\n    }\n    void checkImageBitmap().then((result) => {\n      self.postMessage(result);\n    });\n\n})();\n';let Ir=null;let Or=class WorkerInstance{constructor(){Ir||(Ir=URL.createObjectURL(new Blob([Ur],{type:"application/javascript"})));this.worker=new Worker(Ir)}};Or.revokeObjectURL=function revokeObjectURL(){if(Ir){URL.revokeObjectURL(Ir);Ir=null}};const kr='(function () {\n    \'use strict\';\n\n    async function loadImageBitmap(url, alphaMode) {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n      }\n      const imageBlob = await response.blob();\n      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);\n    }\n    self.onmessage = async (event) => {\n      try {\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\n        self.postMessage({\n          data: imageBitmap,\n          uuid: event.data.uuid,\n          id: event.data.id\n        }, [imageBitmap]);\n      } catch (e) {\n        self.postMessage({\n          error: e,\n          uuid: event.data.uuid,\n          id: event.data.id\n        });\n      }\n    };\n\n})();\n';let Lr=null;class WorkerInstance{constructor(){Lr||(Lr=URL.createObjectURL(new Blob([kr],{type:"application/javascript"})));this.worker=new Worker(Lr)}}WorkerInstance.revokeObjectURL=function revokeObjectURL(){if(Lr){URL.revokeObjectURL(Lr);Lr=null}};"use strict";let Dr=0;let Nr;class WorkerManagerClass{constructor(){this._initialized=false;this._createdWorkers=0;this._workerPool=[];this._queue=[];this._resolveHash={}}isImageBitmapSupported(){if(this._isImageBitmapSupported!==void 0)return this._isImageBitmapSupported;this._isImageBitmapSupported=new Promise((e=>{const{worker:t}=new Or;t.addEventListener("message",(r=>{t.terminate();Or.revokeObjectURL();e(r.data)}))}));return this._isImageBitmapSupported}loadImageBitmap(e,t){return this._run("loadImageBitmap",[e,t?.data?.alphaMode])}async _initWorkers(){this._initialized||(this._initialized=true)}_getWorker(){Nr===void 0&&(Nr=navigator.hardwareConcurrency||4);let e=this._workerPool.pop();if(!e&&this._createdWorkers<Nr){this._createdWorkers++;e=(new WorkerInstance).worker;e.addEventListener("message",(e=>{this._complete(e.data);this._returnWorker(e.target);this._next()}))}return e}_returnWorker(e){this._workerPool.push(e)}_complete(e){e.error!==void 0?this._resolveHash[e.uuid].reject(e.error):this._resolveHash[e.uuid].resolve(e.data);this._resolveHash[e.uuid]=null}async _run(e,t){await this._initWorkers();const r=new Promise(((r,s)=>{this._queue.push({id:e,arguments:t,resolve:r,reject:s})}));this._next();return r}_next(){if(!this._queue.length)return;const e=this._getWorker();if(!e)return;const t=this._queue.pop();const r=t.id;this._resolveHash[Dr]={resolve:t.resolve,reject:t.reject};e.postMessage({data:t.arguments,uuid:Dr++,id:r})}}const Hr=new WorkerManagerClass;"use strict";const Vr=[".jpeg",".jpg",".png",".webp",".avif"];const Wr=["image/jpeg","image/png","image/webp","image/avif"];async function loadImageBitmap(e,t){const r=await ve.get().fetch(e);if(!r.ok)throw new Error(`[loadImageBitmap] Failed to fetch ${e}: ${r.status} ${r.statusText}`);const s=await r.blob();return t?.data?.alphaMode==="premultiplied-alpha"?createImageBitmap(s,{premultiplyAlpha:"none"}):createImageBitmap(s)}const jr={name:"loadTextures",extension:{type:X.LoadParser,priority:Se.High,name:"loadTextures"},config:{preferWorkers:true,preferCreateImageBitmap:true,crossOrigin:"anonymous"},test(e){return checkDataUrl(e,Wr)||ie(e,Vr)},async load(e,t,r){let s=null;s=globalThis.createImageBitmap&&this.config.preferCreateImageBitmap?this.config.preferWorkers&&await Hr.isImageBitmapSupported()?await Hr.loadImageBitmap(e,t):await loadImageBitmap(e,t):await new Promise(((t,r)=>{s=new Image;s.crossOrigin=this.config.crossOrigin;s.src=e;if(s.complete)t(s);else{s.onload=()=>{t(s)};s.onerror=r}}));const n=new Le({resource:s,alphaMode:"premultiply-alpha-on-upload",resolution:t.data?.resolution||getResolutionOfUrl(e),...t.data});return oe(n,r,e)},unload(e){e.destroy(true)}};"use strict";const zr=[".mp4",".m4v",".webm",".ogg",".ogv",".h264",".avi",".mov"];const Xr=zr.map((e=>`video/${e.substring(1)}`));function crossOrigin(e,t,r){r!==void 0||t.startsWith("data:")?r!==false&&(e.crossOrigin=typeof r==="string"?r:"anonymous"):e.crossOrigin=determineCrossOrigin(t)}function preloadVideo(e){return new Promise(((t,r)=>{e.addEventListener("canplaythrough",loaded);e.addEventListener("error",error);e.load();function loaded(){cleanup();t()}function error(e){cleanup();r(e)}function cleanup(){e.removeEventListener("canplaythrough",loaded);e.removeEventListener("error",error)}}))}function determineCrossOrigin(e,t=globalThis.location){if(e.startsWith("data:"))return"";t||(t=globalThis.location);const r=new URL(e,document.baseURI);return r.hostname!==t.hostname||r.port!==t.port||r.protocol!==t.protocol?"anonymous":""}const Yr={name:"loadVideo",extension:{type:X.LoadParser,name:"loadVideo"},test(e){const t=checkDataUrl(e,Xr);const r=ie(e,zr);return t||r},async load(e,t,r){const s={...J.defaultOptions,resolution:t.data?.resolution||getResolutionOfUrl(e),alphaMode:t.data?.alphaMode||await Z(),...t.data};const n=document.createElement("video");const i={preload:s.autoLoad!==false?"auto":void 0,"webkit-playsinline":s.playsinline!==false?"":void 0,playsinline:s.playsinline!==false?"":void 0,muted:s.muted===true?"":void 0,loop:s.loop===true?"":void 0,autoplay:s.autoPlay!==false?"":void 0};Object.keys(i).forEach((e=>{const t=i[e];t!==void 0&&n.setAttribute(e,t)}));s.muted===true&&(n.muted=true);crossOrigin(n,e,s.crossorigin);const o=document.createElement("source");let a;if(e.startsWith("data:"))a=e.slice(5,e.indexOf(";"));else if(!e.startsWith("blob:")){const t=e.split("?")[0].slice(e.lastIndexOf(".")+1).toLowerCase();a=J.MIME_TYPES[t]||`video/${t}`}o.src=e;a&&(o.type=a);return new Promise((i=>{const onCanPlay=async()=>{const o=new J({...s,resource:n});n.removeEventListener("canplay",onCanPlay);t.data.preload&&await preloadVideo(n);i(oe(o,r,e))};n.addEventListener("canplay",onCanPlay);n.appendChild(o)}))},unload(e){e.destroy(true)}};"use strict";const Kr={extension:{type:X.ResolveParser,name:"resolveTexture"},test:jr.test,parse:e=>({resolution:parseFloat(ke.RETINA_PREFIX.exec(e)?.[1]??"1"),format:e.split(".").pop(),src:e})};"use strict";const $r={extension:{type:X.ResolveParser,priority:-2,name:"resolveJson"},test:e=>ke.RETINA_PREFIX.test(e)&&e.endsWith(".json"),parse:Kr.parse};"use strict";class AssetsClass{constructor(){this._detections=[];this._initialized=false;this.resolver=new ke;this.loader=new Loader;this.cache=Ie;this._backgroundLoader=new BackgroundLoader(this.loader);this._backgroundLoader.active=true;this.reset()}
/**
   * Best practice is to call this function before any loading commences
   * Initiating is the best time to add any customization to the way things are loaded.
   *
   * you do not need to call this for the Assets class to work, only if you want to set any initial properties
   * @param options - options to initialize the Assets manager with
   */async init(e={}){if(this._initialized){Fe("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");return}this._initialized=true;e.defaultSearchParams&&this.resolver.setDefaultSearchParams(e.defaultSearchParams);e.basePath&&(this.resolver.basePath=e.basePath);e.bundleIdentifier&&this.resolver.setBundleIdentifier(e.bundleIdentifier);if(e.manifest){let t=e.manifest;typeof t==="string"&&(t=await this.load(t));this.resolver.addManifest(t)}const t=e.texturePreference?.resolution??1;const r=typeof t==="number"?[t]:t;const s=await this._detectFormats({preferredFormats:e.texturePreference?.format,skipDetections:e.skipDetections,detections:this._detections});this.resolver.prefer({params:{format:s,resolution:r}});e.preferences&&this.setPreferences(e.preferences)}
/**
   * Allows you to specify how to resolve any assets load requests.
   * There are a few ways to add things here as shown below:
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Simple
   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});
   * const bunny = await Assets.load('bunnyBooBoo');
   *
   * // Multiple keys:
   * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});
   *
   * const bunny = await Assets.load('burger');
   * const bunny2 = await Assets.load('chicken');
   *
   * // passing options to to the object
   * Assets.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny.{png,webp}',
   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * // Multiple assets
   *
   * // The following all do the same thing:
   *
   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.{png,webp}'});
   *
   * Assets.add({
   *     alias: 'bunnyBooBoo',
   *     src: [
   *         'bunny.png',
   *         'bunny.webp',
   *    ],
   * });
   *
   * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available
   * @param assets - the unresolved assets to add to the resolver
   */add(e){this.resolver.add(e)}async load(e,t){this._initialized||await this.init();const r=Oe(e);const s=Ue(e).map((e=>{if(typeof e!=="string"){const t=this.resolver.getAlias(e);t.some((e=>!this.resolver.hasKey(e)))&&this.add(e);return Array.isArray(t)?t[0]:t}this.resolver.hasKey(e)||this.add({alias:e,src:e});return e}));const n=this.resolver.resolve(s);const i=await this._mapLoadToResolve(n,t);return r?i[s[0]]:i}
/**
   * This adds a bundle of assets in one go so that you can load them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle('animals', [
   *  { alias: 'bunny', src: 'bunny.png' },
   *  { alias: 'chicken', src: 'chicken.png' },
   *  { alias: 'thumper', src: 'thumper.png' },
   * ]);
   * // or
   * Assets.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const assets = await Assets.loadBundle('animals');
   * @param bundleId - the id of the bundle to add
   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key
   */addBundle(e,t){this.resolver.addBundle(e,t)}
/**
   * Bundles are a way to load multiple assets at once.
   * If a manifest has been provided to the init function then you can load a bundle, or bundles.
   * you can also add bundles via `addBundle`
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * await Assets.init({ manifest });
   *
   * // Load a bundle...
   * loadScreenAssets = await Assets.loadBundle('load-screen');
   * // Load another bundle...
   * gameScreenAssets = await Assets.loadBundle('game-screen');
   * @param bundleIds - the bundle id or ids to load
   * @param onProgress - Optional function that is called when progress on asset loading is made.
   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)
   * of the assets loaded. Do not use this function to detect when assets are complete and available,
   * instead use the Promise returned by this function.
   * @returns all the bundles assets or a hash of assets for each bundle specified
   */async loadBundle(e,t){this._initialized||await this.init();let r=false;if(typeof e==="string"){r=true;e=[e]}const s=this.resolver.resolveBundle(e);const n={};const i=Object.keys(s);let o=0;let a=0;const _onProgress=()=>{t?.(++o/a)};const u=i.map((e=>{const t=s[e];a+=Object.keys(t).length;return this._mapLoadToResolve(t,_onProgress).then((t=>{n[e]=t}))}));await Promise.all(u);return r?n[e[0]]:n}
/**
   * Initiate a background load of some assets. It will passively begin to load these assets in the background.
   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately
   *
   * An example of this might be that you would background load game assets after your initial load.
   * then when you got to actually load your game screen assets when a player goes to the game - the loading
   * would already have stared or may even be complete, saving you having to show an interim load bar.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.backgroundLoad('bunny.png');
   *
   * // later on in your app...
   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!
   * @param urls - the url / urls you want to background load
   */async backgroundLoad(e){this._initialized||await this.init();typeof e==="string"&&(e=[e]);const t=this.resolver.resolve(e);this._backgroundLoader.add(Object.values(t))}
/**
   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.
   * this can only be used if the loader has been initiated with a manifest
   * @example
   * import { Assets } from 'pixi.js';
   *
   * await Assets.init({
   *     manifest: {
   *         bundles: [
   *             {
   *                 name: 'load-screen',
   *                 assets: [...],
   *             },
   *             ...
   *         ],
   *     },
   * });
   *
   * Assets.backgroundLoadBundle('load-screen');
   *
   * // Later on in your app...
   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!
   * @param bundleIds - the bundleId / bundleIds you want to background load
   */async backgroundLoadBundle(e){this._initialized||await this.init();typeof e==="string"&&(e=[e]);const t=this.resolver.resolveBundle(e);Object.values(t).forEach((e=>{this._backgroundLoader.add(Object.values(e))}))}reset(){this.resolver.reset();this.loader.reset();this.cache.reset();this._initialized=false}get(e){if(typeof e==="string")return Ie.get(e);const t={};for(let r=0;r<e.length;r++)t[r]=Ie.get(e[r]);return t}
/**
   * helper function to map resolved assets back to loaded assets
   * @param resolveResults - the resolve results from the resolver
   * @param onProgress - the progress callback
   */async _mapLoadToResolve(e,t){const r=[...new Set(Object.values(e))];this._backgroundLoader.active=false;const s=await this.loader.load(r,t);this._backgroundLoader.active=true;const n={};r.forEach((e=>{const t=s[e.src];const r=[e.src];e.alias&&r.push(...e.alias);r.forEach((e=>{n[e]=t}));Ie.set(r,t)}));return n}
/**
   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function
   * this will make sure to destroy any assets and release them from memory.
   * Once unloaded, you will need to load the asset again.
   *
   * Use this to help manage assets if you find that you have a large app and you want to free up memory.
   *
   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,
   * Pixi won't break but you will end up with missing assets. Not a good look for the user!
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Load a URL:
   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture
   *
   * await Assets.unload('http://some.url.com/image.png')
   *
   * // myImageTexture will be destroyed now.
   *
   * // Unload multiple assets:
   * const textures = await Assets.unload(['thumper', 'chicko']);
   * @param urls - the urls to unload
   */async unload(e){this._initialized||await this.init();const t=Ue(e).map((e=>typeof e!=="string"?e.src:e));const r=this.resolver.resolve(t);await this._unloadFromResolved(r)}
/**
   * Bundles are a way to manage multiple assets at once.
   * this will unload all files in a bundle.
   *
   * once a bundle has been unloaded, you need to load it again to have access to the assets.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle({
   *     'thumper': 'http://some.url.com/thumper.png',
   * })
   *
   * const assets = await Assets.loadBundle('thumper');
   *
   * // Now to unload...
   *
   * await Assets.unloadBundle('thumper');
   *
   * // All assets in the assets object will now have been destroyed and purged from the cache
   * @param bundleIds - the bundle id or ids to unload
   */async unloadBundle(e){this._initialized||await this.init();e=Ue(e);const t=this.resolver.resolveBundle(e);const r=Object.keys(t).map((e=>this._unloadFromResolved(t[e])));await Promise.all(r)}async _unloadFromResolved(e){const t=Object.values(e);t.forEach((e=>{Ie.remove(e.src)}));await this.loader.unload(t)}
/**
   * Detects the supported formats for the browser, and returns an array of supported formats, respecting
   * the users preferred formats order.
   * @param options - the options to use when detecting formats
   * @param options.preferredFormats - the preferred formats to use
   * @param options.skipDetections - if we should skip the detections altogether
   * @param options.detections - the detections to use
   * @returns - the detected formats
   */async _detectFormats(e){let t=[];e.preferredFormats&&(t=Array.isArray(e.preferredFormats)?e.preferredFormats:[e.preferredFormats]);for(const r of e.detections)e.skipDetections||await r.test()?t=await r.add(t):e.skipDetections||(t=await r.remove(t));t=t.filter(((e,r)=>t.indexOf(e)===r));return t}get detections(){return this._detections}
/**
   * General setter for preferences. This is a helper function to set preferences on all parsers.
   * @param preferences - the preferences to set
   */setPreferences(e){this.loader.parsers.forEach((t=>{t.config&&Object.keys(t.config).filter((t=>t in e)).forEach((r=>{t.config[r]=e[r]}))}))}}const qr=new AssetsClass;Y.handleByList(X.LoadParser,qr.loader.parsers).handleByList(X.ResolveParser,qr.resolver.parsers).handleByList(X.CacheParser,qr.cache.parsers).handleByList(X.DetectionParser,qr.detections);Y.add(lr,pr,dr,xr,mr,gr,_r,Tr,Gr,Br,Fr,jr,Yr,cr,ur,Kr,$r);const Qr={loader:X.LoadParser,resolver:X.ResolveParser,cache:X.CacheParser,detection:X.DetectionParser};Y.handle(X.Asset,(e=>{const t=e.ref;Object.entries(Qr).filter((([e])=>!!t[e])).forEach((([e,r])=>Y.add(Object.assign(t[e],{extension:t[e].extension??r}))))}),(e=>{const t=e.ref;Object.keys(Qr).filter((e=>!!t[e])).forEach((e=>Y.remove(t[e])))}));"use strict";"use strict";"use strict";"use strict";"use strict";"use strict";"use strict";"use strict";"use strict";function createLevelBuffers(e,t){const r=e.getNumImages();const s=e.getNumLevels(0);const n=e.startTranscoding();if(!n)throw new Error("startTranscoding failed");const i=[];for(let n=0;n<s;++n)for(let s=0;s<r;++s){const r=e.getImageTranscodedSizeInBytes(s,n,t);const o=new Uint8Array(r);const a=e.transcodeImage(o,s,n,t,1,0);if(!a)throw new Error("transcodeImage failed");i.push(o)}return i}"use strict";const Zr={"bc3-rgba-unorm":3,"bc7-rgba-unorm":6,"etc2-rgba8unorm":1,"astc-4x4-unorm":10,rgba8unorm:13,rgba4unorm:16};function gpuFormatToBasisTranscoderFormat(e){const t=Zr[e];if(t)return t;throw new Error(`Unsupported transcoderFormat: ${e}`)}"use strict";"use strict";const Jr={rgb8unorm:{convertedFormat:"rgba8unorm",convertFunction:convertRGBtoRGBA},"rgb8unorm-srgb":{convertedFormat:"rgba8unorm-srgb",convertFunction:convertRGBtoRGBA}};function convertFormatIfRequired(e){const t=e.format;if(Jr[t]){const r=Jr[t].convertFunction;const s=e.resource;for(let e=0;e<s.length;e++)s[e]=r(s[e]);e.format=Jr[t].convertedFormat}}function convertRGBtoRGBA(e){const t=e.byteLength/3;const r=new Uint32Array(t);for(let s=0;s<t;++s)r[s]=e[s*3]+(e[s*3+1]<<8)+(e[s*3+2]<<16)+4278190080;return new Uint8Array(r.buffer)}"use strict";function createLevelBuffersFromKTX(e){const t=[];for(let r=0;r<e.numLevels;r++){const s=e.getImageData(r,0,0);const n=new Uint8Array(s.byteLength);n.set(s);t.push(n)}return t}"use strict";const es={6408:"rgba8unorm",32856:"bgra8unorm",32857:"rgb10a2unorm",33189:"depth16unorm",33190:"depth24plus",33321:"r8unorm",33323:"rg8unorm",33325:"r16float",33326:"r32float",33327:"rg16float",33328:"rg32float",33329:"r8sint",33330:"r8uint",33331:"r16sint",33332:"r16uint",33333:"r32sint",33334:"r32uint",33335:"rg8sint",33336:"rg8uint",33337:"rg16sint",33338:"rg16uint",33339:"rg32sint",33340:"rg32uint",33778:"bc2-rgba-unorm",33779:"bc3-rgba-unorm",34836:"rgba32float",34842:"rgba16float",35056:"depth24plus-stencil8",35898:"rg11b10ufloat",35901:"rgb9e5ufloat",35907:"rgba8unorm-srgb",36012:"depth32float",36013:"depth32float-stencil8",36168:"stencil8",36208:"rgba32uint",36214:"rgba16uint",36220:"rgba8uint",36226:"rgba32sint",36232:"rgba16sint",36238:"rgba8sint",36492:"bc7-rgba-unorm",36756:"r8snorm",36757:"rg8snorm",36759:"rgba8snorm",37496:"etc2-rgba8unorm",37808:"astc-4x4-unorm"};function glFormatToGPUFormat(e){const t=es[e];if(t)return t;throw new Error(`Unsupported glInternalFormat: ${e}`)}"use strict";const ts={23:"rgb8unorm",37:"rgba8unorm",43:"rgba8unorm-srgb"};function vkFormatToGPUFormat(e){const t=ts[e];if(t)return t;throw new Error(`Unsupported VkFormat: ${e}`)}"use strict";function getTextureFormatFromKTXTexture(e){return e.classId===2?vkFormatToGPUFormat(e.vkFormat):glFormatToGPUFormat(e.glInternalformat)}"use strict";const rs={"bc3-rgba-unorm":"BC3_RGBA","bc7-rgba-unorm":"BC7_M5_RGBA","etc2-rgba8unorm":"ETC2_RGBA","astc-4x4-unorm":"ASTC_4x4_RGBA",rgba8unorm:"RGBA32",rg11b10ufloat:"R11F_G11F_B10F"};function gpuFormatToKTXBasisTranscoderFormat(e){const t=rs[e];if(t)return t;throw new Error(`Unsupported transcoderFormat: ${e}`)}"use strict";"use strict";const ss=new ze;const ns=class _Culler{
/**
   * Culls the children of a specific container based on the given view. This will also cull items that are not
   * being explicitly managed by the culler.
   * @param container - The container to cull.
   * @param view - The view rectangle.
   * @param skipUpdateTransform - Whether to skip updating the transform.
   */
cull(e,t,r=true){this._cullRecursive(e,t,r)}_cullRecursive(e,t,r=true){if(e.cullable&&e.measurable&&e.includeInBuild){const s=e.cullArea??de(e,r,ss);e.culled=s.x>=t.x+t.width||s.y>=t.y+t.height||s.x+s.width<=t.x||s.y+s.height<=t.y}else e.culled=false;if(e.cullableChildren&&!e.culled&&e.renderable&&e.measurable&&e.includeInBuild)for(let s=0;s<e.children.length;s++)this._cullRecursive(e.children[s],t,r)}};ns.shared=new ns;let is=ns;"use strict";class CullerPlugin{static init(){this._renderRef=this.render.bind(this);this.render=()=>{is.shared.cull(this.stage,this.renderer.screen);this.renderer.render({container:this.stage})}}static destroy(){this.render=this._renderRef}}CullerPlugin.extension={priority:10,type:X.Application,name:"culler"};"use strict";"use strict";"use strict";"use strict";"use strict";"use strict";const os={createCanvas:(e,t)=>new OffscreenCanvas(e??0,t??0),getCanvasRenderingContext2D:()=>OffscreenCanvasRenderingContext2D,getWebGLRenderingContext:()=>WebGLRenderingContext,getNavigator:()=>navigator,getBaseUrl:()=>globalThis.location.href,getFontFaceSet:()=>globalThis.fonts,fetch:(e,t)=>fetch(e,t),parseXML:e=>{const t=new Xe;return t.parseFromString(e,"text/xml")}};"use strict";"use strict";"use strict";"use strict";"use strict";"use strict";var as="in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";var us="\nin vec2 vTextureCoord;\n\nout vec4 finalColor;\n\nuniform float uAlpha;\nuniform sampler2D uTexture;\n\nvoid main()\n{\n    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;\n}\n";var cs="struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct AlphaUniforms {\n  uAlpha:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n \n    var sample = textureSample(uTexture, uSampler, uv);\n    \n    return sample * alphaUniforms.uAlpha;\n}";"use strict";const ls=class _AlphaFilter extends re{constructor(e){e={..._AlphaFilter.defaultOptions,...e};const t=Ye.from({vertex:{source:cs,entryPoint:"mainVertex"},fragment:{source:cs,entryPoint:"mainFragment"}});const r=Ke.from({vertex:as,fragment:us,name:"alpha-filter"});const{alpha:s,...n}=e;const i=new qe({uAlpha:{value:s,type:"f32"}});super({...n,gpuProgram:t,glProgram:r,resources:{alphaUniforms:i}})}get alpha(){return this.resources.alphaUniforms.uniforms.uAlpha}set alpha(e){this.resources.alphaUniforms.uniforms.uAlpha=e}};ls.defaultOptions={alpha:1};let ds=ls;"use strict";const hs={5:[.153388,.221461,.250301],7:[.071303,.131514,.189879,.214607],9:[.028532,.067234,.124009,.179044,.20236],11:[.0093,.028002,.065984,.121703,.175713,.198596],13:[.002406,.009255,.027867,.065666,.121117,.174868,.197641],15:[489e-6,.002403,.009246,.02784,.065602,.120999,.174697,.197448]};"use strict";const ps=["in vec2 vBlurTexCoords[%size%];","uniform sampler2D uTexture;","out vec4 finalColor;","void main(void)","{","    finalColor = vec4(0.0);","    %blur%","}"].join("\n");function generateBlurFragSource(e){const t=hs[e];const r=t.length;let s=ps;let n="";const i="finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;";let o;for(let s=0;s<e;s++){let a=i.replace("%index%",s.toString());o=s;s>=r&&(o=e-s-1);a=a.replace("%value%",t[o].toString());n+=a;n+="\n"}s=s.replace("%blur%",n);s=s.replace("%size%",e.toString());return s}"use strict";const fs="\n    in vec2 aPosition;\n\n    uniform float uStrength;\n\n    out vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 uInputSize;\n    uniform vec4 uOutputFrame;\n    uniform vec4 uOutputTexture;\n\n    vec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\n    vec2 filterTextureCoord( void )\n    {\n        return aPosition * (uOutputFrame.zw * uInputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        float pixelStrength = uInputSize.%dimension% * uStrength;\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";function generateBlurVertSource(e,t){const r=Math.ceil(e/2);let s=fs;let n="";let i;i=t?"vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);":"vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";for(let t=0;t<e;t++){let e=i.replace("%index%",t.toString());e=e.replace("%sampleIndex%",t-(r-1)+".0");n+=e;n+="\n"}s=s.replace("%blur%",n);s=s.replace("%size%",e.toString());s=s.replace("%dimension%",t?"z":"w");return s}"use strict";function generateBlurGlProgram(e,t){const r=generateBlurVertSource(t,e);const s=generateBlurFragSource(t);return Ke.from({vertex:r,fragment:s,name:`blur-${e?"horizontal":"vertical"}-pass-filter`})}var ms="\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct BlurUniforms {\n  uStrength:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    %blur-struct%\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n\n  let filteredCord = filterTextureCoord(aPosition);\n\n  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;\n\n  return VSOutput(\n   filterVertexPosition(aPosition),\n    %blur-vertex-out%\n  );\n}\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  %blur-fragment-in%\n) -> @location(0) vec4<f32> {\n\n    var   finalColor = vec4(0.0);\n\n    %blur-sampling%\n\n    return finalColor;\n}";"use strict";function generateBlurProgram(e,t){const r=hs[t];const s=r.length;const n=[];const i=[];const o=[];for(let a=0;a<t;a++){n[a]=`@location(${a}) offset${a}: vec2<f32>,`;i[a]=e?`filteredCord + vec2(${a-s+1} * pixelStrength, 0.0),`:`filteredCord + vec2(0.0, ${a-s+1} * pixelStrength),`;const u=a<s?a:t-a-1;const c=r[u].toString();o[a]=`finalColor += textureSample(uTexture, uSampler, offset${a}) * ${c};`}const a=n.join("\n");const u=i.join("\n");const c=o.join("\n");const l=ms.replace("%blur-struct%",a).replace("%blur-vertex-out%",u).replace("%blur-fragment-in%",a).replace("%blur-sampling%",c).replace("%dimension%",e?"z":"w");return Ye.from({vertex:{source:l,entryPoint:"mainVertex"},fragment:{source:l,entryPoint:"mainFragment"}})}"use strict";const gs=class _BlurFilterPass extends re{
/**
   * @param options
   * @param options.horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).
   * @param options.strength - The strength of the blur filter.
   * @param options.quality - The quality of the blur filter.
   * @param options.kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
   */
constructor(e){e={..._BlurFilterPass.defaultOptions,...e};const t=generateBlurGlProgram(e.horizontal,e.kernelSize);const r=generateBlurProgram(e.horizontal,e.kernelSize);super({glProgram:t,gpuProgram:r,resources:{blurUniforms:{uStrength:{value:0,type:"f32"}}},...e});this.horizontal=e.horizontal;this._quality=0;this.quality=e.quality;this.blur=e.strength;this._uniforms=this.resources.blurUniforms.uniforms}
/**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - How to clear
   */apply(e,t,r,s){this._uniforms.uStrength=this.strength/this.passes;if(this.passes===1)e.applyFilter(this,t,r,s);else{const n=Ze.getSameSizeTexture(t);let i=t;let o=n;this._state.blend=false;const a=e.renderer.type===Je.WEBGPU;for(let t=0;t<this.passes-1;t++){e.applyFilter(this,i,o,t===0||a);const r=o;o=i;i=r}this._state.blend=true;e.applyFilter(this,i,r,s);Ze.returnTexture(n)}}get blur(){return this.strength}set blur(e){this.padding=1+Math.abs(e)*2;this.strength=e}get quality(){return this._quality}set quality(e){this._quality=e;this.passes=e}};gs.defaultOptions={strength:8,quality:4,kernelSize:5};let _s=gs;"use strict";class BlurFilter extends re{constructor(...e){let t=e[0]??{};if(typeof t==="number"){ye(Te,"BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }");t={strength:t};e[1]!==void 0&&(t.quality=e[1]);e[2]!==void 0&&(t.resolution=e[2]||"inherit");e[3]!==void 0&&(t.kernelSize=e[3])}t={..._s.defaultOptions,...t};const{strength:r,strengthX:s,strengthY:n,quality:i,...o}=t;super({...o,compatibleRenderers:Je.BOTH,resources:{}});this._repeatEdgePixels=false;this.blurXFilter=new _s({horizontal:true,...t});this.blurYFilter=new _s({horizontal:false,...t});this.quality=i;this.strengthX=s??r;this.strengthY=n??r;this.repeatEdgePixels=false}
/**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - How to clear
   */apply(e,t,r,s){const n=Math.abs(this.blurXFilter.strength);const i=Math.abs(this.blurYFilter.strength);if(n&&i){const n=Ze.getSameSizeTexture(t);this.blurXFilter.blendMode="normal";this.blurXFilter.apply(e,t,n,true);this.blurYFilter.blendMode=this.blendMode;this.blurYFilter.apply(e,n,r,s);Ze.returnTexture(n)}else if(i){this.blurYFilter.blendMode=this.blendMode;this.blurYFilter.apply(e,t,r,s)}else{this.blurXFilter.blendMode=this.blendMode;this.blurXFilter.apply(e,t,r,s)}}updatePadding(){this._repeatEdgePixels?this.padding=0:this.padding=Math.max(Math.abs(this.blurXFilter.blur),Math.abs(this.blurYFilter.blur))*2}get strength(){if(this.strengthX!==this.strengthY)throw new Error("BlurFilter's strengthX and strengthY are different");return this.strengthX}set strength(e){this.blurXFilter.blur=this.blurYFilter.blur=e;this.updatePadding()}get quality(){return this.blurXFilter.quality}set quality(e){this.blurXFilter.quality=this.blurYFilter.quality=e}get strengthX(){return this.blurXFilter.blur}set strengthX(e){this.blurXFilter.blur=e;this.updatePadding()}get strengthY(){return this.blurYFilter.blur}set strengthY(e){this.blurYFilter.blur=e;this.updatePadding()}
/**
   * Sets the strength of both the blurX and blurY properties simultaneously
   * @default 2
   * @deprecated since 8.3.0
   * @see BlurFilter.strength
   */get blur(){ye("8.3.0","BlurFilter.blur is deprecated, please use BlurFilter.strength instead.");return this.strength}set blur(e){ye("8.3.0","BlurFilter.blur is deprecated, please use BlurFilter.strength instead.");this.strength=e}
/**
   * Sets the strength of the blurX property
   * @default 2
   * @deprecated since 8.3.0
   * @see BlurFilter.strengthX
   */get blurX(){ye("8.3.0","BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.");return this.strengthX}set blurX(e){ye("8.3.0","BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.");this.strengthX=e}
/**
   * Sets the strength of the blurY property
   * @default 2
   * @deprecated since 8.3.0
   * @see BlurFilter.strengthY
   */get blurY(){ye("8.3.0","BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.");return this.strengthY}set blurY(e){ye("8.3.0","BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.");this.strengthY=e}get repeatEdgePixels(){return this._repeatEdgePixels}set repeatEdgePixels(e){this._repeatEdgePixels=e;this.updatePadding()}}BlurFilter.defaultOptions={strength:8,quality:4,kernelSize:5};var xs="\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uColorMatrix[20];\nuniform float uAlpha;\n\nuniform sampler2D uTexture;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * 0.2);\n    float diff = (randomValue - 0.5) *  0.5;\n\n    if (uAlpha == 0.0) {\n        finalColor = color;\n        return;\n    }\n\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    vec4 result;\n\n    result.r = (uColorMatrix[0] * color.r);\n        result.r += (uColorMatrix[1] * color.g);\n        result.r += (uColorMatrix[2] * color.b);\n        result.r += (uColorMatrix[3] * color.a);\n        result.r += uColorMatrix[4];\n\n    result.g = (uColorMatrix[5] * color.r);\n        result.g += (uColorMatrix[6] * color.g);\n        result.g += (uColorMatrix[7] * color.b);\n        result.g += (uColorMatrix[8] * color.a);\n        result.g += uColorMatrix[9];\n\n    result.b = (uColorMatrix[10] * color.r);\n       result.b += (uColorMatrix[11] * color.g);\n       result.b += (uColorMatrix[12] * color.b);\n       result.b += (uColorMatrix[13] * color.a);\n       result.b += uColorMatrix[14];\n\n    result.a = (uColorMatrix[15] * color.r);\n       result.a += (uColorMatrix[16] * color.g);\n       result.a += (uColorMatrix[17] * color.b);\n       result.a += (uColorMatrix[18] * color.a);\n       result.a += uColorMatrix[19];\n\n    vec3 rgb = mix(color.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    finalColor = vec4(rgb, result.a);\n}\n";var bs="struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct ColorMatrixUniforms {\n  uColorMatrix:array<vec4<f32>, 5>,\n  uAlpha:f32,\n};\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n@group(1) @binding(0) var<uniform> colorMatrixUniforms : ColorMatrixUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n  };\n  \nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n  );\n}\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n\n\n  var c = textureSample(uTexture, uSampler, uv);\n  \n  if (colorMatrixUniforms.uAlpha == 0.0) {\n    return c;\n  }\n\n \n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.r /= c.a;\n      c.g /= c.a;\n      c.b /= c.a;\n    }\n\n    var cm = colorMatrixUniforms.uColorMatrix;\n\n\n    var result = vec4<f32>(0.);\n\n    result.r = (cm[0][0] * c.r);\n    result.r += (cm[0][1] * c.g);\n    result.r += (cm[0][2] * c.b);\n    result.r += (cm[0][3] * c.a);\n    result.r += cm[1][0];\n\n    result.g = (cm[1][1] * c.r);\n    result.g += (cm[1][2] * c.g);\n    result.g += (cm[1][3] * c.b);\n    result.g += (cm[2][0] * c.a);\n    result.g += cm[2][1];\n\n    result.b = (cm[2][2] * c.r);\n    result.b += (cm[2][3] * c.g);\n    result.b += (cm[3][0] * c.b);\n    result.b += (cm[3][1] * c.a);\n    result.b += cm[3][2];\n\n    result.a = (cm[3][3] * c.r);\n    result.a += (cm[4][0] * c.g);\n    result.a += (cm[4][1] * c.b);\n    result.a += (cm[4][2] * c.a);\n    result.a += cm[4][3];\n\n    var rgb = mix(c.rgb, result.rgb, colorMatrixUniforms.uAlpha);\n\n    rgb.r *= result.a;\n    rgb.g *= result.a;\n    rgb.b *= result.a;\n\n    return vec4(rgb, result.a);\n}";"use strict";class ColorMatrixFilter extends re{constructor(e={}){const t=new qe({uColorMatrix:{value:[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],type:"f32",size:20},uAlpha:{value:1,type:"f32"}});const r=Ye.from({vertex:{source:bs,entryPoint:"mainVertex"},fragment:{source:bs,entryPoint:"mainFragment"}});const s=Ke.from({vertex:as,fragment:xs,name:"color-matrix-filter"});super({...e,gpuProgram:r,glProgram:s,resources:{colorMatrixUniforms:t}});this.alpha=1}
/**
   * Transforms current matrix and set the new one
   * @param {number[]} matrix - 5x4 matrix
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */_loadMatrix(e,t=false){let r=e;if(t){this._multiply(r,this.matrix,e);r=this._colorMatrix(r)}this.resources.colorMatrixUniforms.uniforms.uColorMatrix=r;this.resources.colorMatrixUniforms.update()}
/**
   * Multiplies two mat5's
   * @private
   * @param out - 5x4 matrix the receiving matrix
   * @param a - 5x4 matrix the first operand
   * @param b - 5x4 matrix the second operand
   * @returns {number[]} 5x4 matrix
   */_multiply(e,t,r){e[0]=t[0]*r[0]+t[1]*r[5]+t[2]*r[10]+t[3]*r[15];e[1]=t[0]*r[1]+t[1]*r[6]+t[2]*r[11]+t[3]*r[16];e[2]=t[0]*r[2]+t[1]*r[7]+t[2]*r[12]+t[3]*r[17];e[3]=t[0]*r[3]+t[1]*r[8]+t[2]*r[13]+t[3]*r[18];e[4]=t[0]*r[4]+t[1]*r[9]+t[2]*r[14]+t[3]*r[19]+t[4];e[5]=t[5]*r[0]+t[6]*r[5]+t[7]*r[10]+t[8]*r[15];e[6]=t[5]*r[1]+t[6]*r[6]+t[7]*r[11]+t[8]*r[16];e[7]=t[5]*r[2]+t[6]*r[7]+t[7]*r[12]+t[8]*r[17];e[8]=t[5]*r[3]+t[6]*r[8]+t[7]*r[13]+t[8]*r[18];e[9]=t[5]*r[4]+t[6]*r[9]+t[7]*r[14]+t[8]*r[19]+t[9];e[10]=t[10]*r[0]+t[11]*r[5]+t[12]*r[10]+t[13]*r[15];e[11]=t[10]*r[1]+t[11]*r[6]+t[12]*r[11]+t[13]*r[16];e[12]=t[10]*r[2]+t[11]*r[7]+t[12]*r[12]+t[13]*r[17];e[13]=t[10]*r[3]+t[11]*r[8]+t[12]*r[13]+t[13]*r[18];e[14]=t[10]*r[4]+t[11]*r[9]+t[12]*r[14]+t[13]*r[19]+t[14];e[15]=t[15]*r[0]+t[16]*r[5]+t[17]*r[10]+t[18]*r[15];e[16]=t[15]*r[1]+t[16]*r[6]+t[17]*r[11]+t[18]*r[16];e[17]=t[15]*r[2]+t[16]*r[7]+t[17]*r[12]+t[18]*r[17];e[18]=t[15]*r[3]+t[16]*r[8]+t[17]*r[13]+t[18]*r[18];e[19]=t[15]*r[4]+t[16]*r[9]+t[17]*r[14]+t[18]*r[19]+t[19];return e}
/**
   * Create a Float32 Array and normalize the offset component to 0-1
   * @param {number[]} matrix - 5x4 matrix
   * @returns {number[]} 5x4 matrix with all values between 0-1
   */_colorMatrix(e){const t=new Float32Array(e);t[4]/=255;t[9]/=255;t[14]/=255;t[19]/=255;return t}
/**
   * Adjusts brightness
   * @param b - value of the brightness (0-1, where 0 is black)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */brightness(e,t){const r=[e,0,0,0,0,0,e,0,0,0,0,0,e,0,0,0,0,0,1,0];this._loadMatrix(r,t)}
/**
   * Sets each channel on the diagonal of the color matrix.
   * This can be used to achieve a tinting effect on Containers similar to the tint field of some
   * display objects like Sprite, Text, Graphics, and Mesh.
   * @param color - Color of the tint. This is a hex value.
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */tint(e,t){const[r,s,n]=je.shared.setValue(e).toArray();const i=[r,0,0,0,0,0,s,0,0,0,0,0,n,0,0,0,0,0,1,0];this._loadMatrix(i,t)}
/**
   * Set the matrices in grey scales
   * @param scale - value of the grey (0-1, where 0 is black)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */greyscale(e,t){const r=[e,e,e,0,0,e,e,e,0,0,e,e,e,0,0,0,0,0,1,0];this._loadMatrix(r,t)}
/**
   * for our american friends!
   * @param scale
   * @param multiply
   */grayscale(e,t){this.greyscale(e,t)}
/**
   * Set the black and white matrice.
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */blackAndWhite(e){const t=[.3,.6,.1,0,0,.3,.6,.1,0,0,.3,.6,.1,0,0,0,0,0,1,0];this._loadMatrix(t,e)}
/**
   * Set the hue property of the color
   * @param rotation - in degrees
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */hue(e,t){e=(e||0)/180*Math.PI;const r=Math.cos(e);const s=Math.sin(e);const n=Math.sqrt;const i=1/3;const o=n(i);const a=r+(1-r)*i;const u=i*(1-r)-o*s;const c=i*(1-r)+o*s;const l=i*(1-r)+o*s;const d=r+i*(1-r);const h=i*(1-r)-o*s;const p=i*(1-r)-o*s;const f=i*(1-r)+o*s;const m=r+i*(1-r);const g=[a,u,c,0,0,l,d,h,0,0,p,f,m,0,0,0,0,0,1,0];this._loadMatrix(g,t)}
/**
   * Set the contrast matrix, increase the separation between dark and bright
   * Increase contrast : shadows darker and highlights brighter
   * Decrease contrast : bring the shadows up and the highlights down
   * @param amount - value of the contrast (0-1)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */contrast(e,t){const r=(e||0)+1;const s=-.5*(r-1);const n=[r,0,0,0,s,0,r,0,0,s,0,0,r,0,s,0,0,0,1,0];this._loadMatrix(n,t)}
/**
   * Set the saturation matrix, increase the separation between colors
   * Increase saturation : increase contrast, brightness, and sharpness
   * @param amount - The saturation amount (0-1)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */saturate(e=0,t){const r=e*2/3+1;const s=(r-1)*-.5;const n=[r,s,s,0,0,s,r,s,0,0,s,s,r,0,0,0,0,0,1,0];this._loadMatrix(n,t)}desaturate(){this.saturate(-1)}
/**
   * Negative image (inverse of classic rgb matrix)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */negative(e){const t=[-1,0,0,1,0,0,-1,0,1,0,0,0,-1,1,0,0,0,0,1,0];this._loadMatrix(t,e)}
/**
   * Sepia image
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */sepia(e){const t=[.393,.7689999,.18899999,0,0,.349,.6859999,.16799999,0,0,.272,.5339999,.13099999,0,0,0,0,0,1,0];this._loadMatrix(t,e)}
/**
   * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */technicolor(e){const t=[1.9125277891456083,-.8545344976951645,-.09155508482755585,0,11.793603434377337,-.3087833385928097,1.7658908555458428,-.10601743074722245,0,-70.35205161461398,-.231103377548616,-.7501899197440212,1.847597816108189,0,30.950940869491138,0,0,0,1,0];this._loadMatrix(t,e)}
/**
   * Polaroid filter
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */polaroid(e){const t=[1.438,-.062,-.062,0,0,-.122,1.378,-.122,0,0,-.016,-.016,1.483,0,0,0,0,0,1,0];this._loadMatrix(t,e)}
/**
   * Filter who transforms : Red -> Blue and Blue -> Red
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */toBGR(e){const t=[0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0];this._loadMatrix(t,e)}
/**
   * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */kodachrome(e){const t=[1.1285582396593525,-.3967382283601348,-.03992559172921793,0,63.72958762196502,-.16404339962244616,1.0835251566291304,-.05498805115633132,0,24.732407896706203,-.16786010706155763,-.5603416277695248,1.6014850761964943,0,35.62982807460946,0,0,0,1,0];this._loadMatrix(t,e)}
/**
   * Brown delicious browni filter (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */browni(e){const t=[.5997023498159715,.34553243048391263,-.2708298674538042,0,47.43192855600873,-.037703249837783157,.8609577587992641,.15059552388459913,0,-36.96841498319127,.24113635128153335,-.07441037908422492,.44972182064877153,0,-7.562075277591283,0,0,0,1,0];this._loadMatrix(t,e)}
/**
   * Vintage filter (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */vintage(e){const t=[.6279345635605994,.3202183420819367,-.03965408211312453,0,9.651285835294123,.02578397704808868,.6441188644374771,.03259127616149294,0,7.462829176470591,.0466055556782719,-.0851232987247891,.5241648018700465,0,5.159190588235296,0,0,0,1,0];this._loadMatrix(t,e)}
/**
   * We don't know exactly what it does, kind of gradient map, but funny to play with!
   * @param desaturation - Tone values.
   * @param toned - Tone values.
   * @param lightColor - Tone values, example: `0xFFE580`
   * @param darkColor - Tone values, example: `0xFFE580`
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */colorTone(e,t,r,s,n){e||(e=.2);t||(t=.15);r||(r=16770432);s||(s=3375104);const i=je.shared;const[o,a,u]=i.setValue(r).toArray();const[c,l,d]=i.setValue(s).toArray();const h=[.3,.59,.11,0,0,o,a,u,e,0,c,l,d,t,0,o-c,a-l,u-d,0,0];this._loadMatrix(h,n)}
/**
   * Night effect
   * @param intensity - The intensity of the night effect.
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */night(e,t){e||(e=.1);const r=[e*-2,-e,0,0,0,-e,0,e,0,0,0,e,e*2,0,0,0,0,0,1,0];this._loadMatrix(r,t)}
/**
   * Predator effect
   *
   * Erase the current matrix by setting a new independent one
   * @param amount - how much the predator feels his future victim
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */predator(e,t){const r=[11.224130630493164*e,-4.794486999511719*e,-2.8746118545532227*e,0*e,.40342438220977783*e,-3.6330697536468506*e,9.193157196044922*e,-2.951810836791992*e,0*e,-1.316135048866272*e,-3.2184197902679443*e,-4.2375030517578125*e,7.476448059082031*e,0*e,.8044459223747253*e,0,0,0,1,0];this._loadMatrix(r,t)}
/**
   * LSD effect
   *
   * Multiply the current matrix
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */lsd(e){const t=[2,-.4,.5,0,0,-.5,2,-.4,0,0,-.4,-.5,3,0,0,0,0,0,1,0];this._loadMatrix(t,e)}reset(){const e=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0];this._loadMatrix(e,false)}get matrix(){return this.resources.colorMatrixUniforms.uniforms.uColorMatrix}set matrix(e){this.resources.colorMatrixUniforms.uniforms.uColorMatrix=e}get alpha(){return this.resources.colorMatrixUniforms.uniforms.uAlpha}set alpha(e){this.resources.colorMatrixUniforms.uniforms.uAlpha=e}}var ys="\nin vec2 vTextureCoord;\nin vec2 vFilterUv;\n\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMapTexture;\n\nuniform vec4 uInputClamp;\nuniform highp vec4 uInputSize;\nuniform mat2 uRotation;\nuniform vec2 uScale;\n\nvoid main()\n{\n    vec4 map = texture(uMapTexture, vFilterUv);\n    \n    vec2 offset = uInputSize.zw * (uRotation * (map.xy - 0.5)) * uScale; \n\n    finalColor = texture(uTexture, clamp(vTextureCoord + offset, uInputClamp.xy, uInputClamp.zw));\n}\n";var Ts="in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 vFilterUv;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( void )\n{\n  return ( uFilterMatrix * vec3( filterTextureCoord(), 1.0)  ).xy;\n}\n\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n    vFilterUv = getFilterCoord();\n}\n";var Ss="\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct DisplacementUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uScale:vec2<f32>,\n  uRotation:mat2x2<f32>\n};\n\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : DisplacementUniforms;\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\n@group(1) @binding(2) var uMapSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n\n  \n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var map = textureSample(uMapTexture, uMapSampler, filterUv);\n\n    var offset =  gfu.uInputSize.zw * (filterUniforms.uRotation * (map.xy - 0.5)) * filterUniforms.uScale; \n   \n    return textureSample(uTexture, uSampler, clamp(uv + offset, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n}";"use strict";class DisplacementFilter extends re{constructor(...e){let t=e[0];if(t instanceof st){e[1]&&ye(Te,"DisplacementFilter now uses options object instead of params. {sprite, scale}");t={sprite:t,scale:e[1]}}const{sprite:r,scale:s,...n}=t;let i=s??20;typeof i==="number"&&(i=new rt(i,i));const o=new qe({uFilterMatrix:{value:new et,type:"mat3x3<f32>"},uScale:{value:i,type:"vec2<f32>"},uRotation:{value:new Float32Array([0,0,0,0]),type:"mat2x2<f32>"}});const a=Ke.from({vertex:Ts,fragment:ys,name:"displacement-filter"});const u=Ye.from({vertex:{source:Ss,entryPoint:"mainVertex"},fragment:{source:Ss,entryPoint:"mainFragment"}});const c=r.texture.source;super({...n,gpuProgram:u,glProgram:a,resources:{filterUniforms:o,uMapTexture:c,uMapSampler:c.style}});this._sprite=t.sprite;this._sprite.renderable=false}
/**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - clearMode.
   */apply(e,t,r,s){const n=this.resources.filterUniforms.uniforms;e.calculateSpriteMatrix(n.uFilterMatrix,this._sprite);const i=this._sprite.worldTransform;const o=Math.sqrt(i.a*i.a+i.b*i.b);const a=Math.sqrt(i.c*i.c+i.d*i.d);if(o!==0&&a!==0){n.uRotation[0]=i.a/o;n.uRotation[1]=i.b/o;n.uRotation[2]=i.c/a;n.uRotation[3]=i.d/a}this.resources.uMapTexture=this._sprite.texture.source;e.applyFilter(this,t,r,s)}get scale(){return this.resources.filterUniforms.uniforms.uScale}}var vs="\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uTexture;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) *  uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    finalColor = color;\n}\n";var Gs="\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct NoiseUniforms {\n  uNoise:f32,\n  uSeed:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> noiseUniforms : NoiseUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\nfn rand(co:vec2<f32>) -> f32\n{\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var pixelPosition =  globalTextureCoord(position.xy);// / (getSize());//-  gfu.uOutputFrame.xy);\n  \n    \n    var sample = textureSample(uTexture, uSampler, uv);\n    var randomValue =  rand(pixelPosition.xy * noiseUniforms.uSeed);\n    var diff = (randomValue - 0.5) * noiseUniforms.uNoise;\n  \n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (sample.a > 0.0) {\n      sample.r /= sample.a;\n      sample.g /= sample.a;\n      sample.b /= sample.a;\n    }\n\n    sample.r += diff;\n    sample.g += diff;\n    sample.b += diff;\n\n    // Premultiply alpha again.\n    sample.r *= sample.a;\n    sample.g *= sample.a;\n    sample.b *= sample.a;\n    \n    return sample;\n}";"use strict";const Es=class _NoiseFilter extends re{
/**
   * @param options - The options of the noise filter.
   */
constructor(e={}){e={..._NoiseFilter.defaultOptions,...e};const t=Ye.from({vertex:{source:Gs,entryPoint:"mainVertex"},fragment:{source:Gs,entryPoint:"mainFragment"}});const r=Ke.from({vertex:as,fragment:vs,name:"noise-filter"});const{noise:s,seed:n,...i}=e;super({...i,gpuProgram:t,glProgram:r,resources:{noiseUniforms:new qe({uNoise:{value:1,type:"f32"},uSeed:{value:1,type:"f32"}})}});this.noise=s;this.seed=n??Math.random()}get noise(){return this.resources.noiseUniforms.uniforms.uNoise}set noise(e){this.resources.noiseUniforms.uniforms.uNoise=e}get seed(){return this.resources.noiseUniforms.uniforms.uSeed}set seed(e){this.resources.noiseUniforms.uniforms.uSeed=e}};Es.defaultOptions={noise:.5};let As=Es;var Ps="in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\nuniform float uInverse;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha;\n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    float a = alphaMul * masky.r * npmAlpha * clip;\n\n    if (uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    finalColor = original * a;\n}\n";var Cs="in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";var Rs="struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n  uInverse:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n    var uAlpha = filterUniforms.uAlpha;\n\n    var clip = step(3.5,\n      step(maskClamp.x, filterUv.x) +\n      step(maskClamp.y, filterUv.y) +\n      step(filterUv.x, maskClamp.z) +\n      step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\n\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\n\n    if (filterUniforms.uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    return source * a;\n}\n";"use strict";class MaskFilter extends re{constructor(e){const{sprite:t,...r}=e;const s=new Pe(t.texture);const n=new qe({uFilterMatrix:{value:new et,type:"mat3x3<f32>"},uMaskClamp:{value:s.uClampFrame,type:"vec4<f32>"},uAlpha:{value:1,type:"f32"},uInverse:{value:e.inverse?1:0,type:"f32"}});const i=Ye.from({vertex:{source:Rs,entryPoint:"mainVertex"},fragment:{source:Rs,entryPoint:"mainFragment"}});const o=Ke.from({vertex:Cs,fragment:Ps,name:"mask-filter"});super({...r,gpuProgram:i,glProgram:o,resources:{filterUniforms:n,uMaskTexture:t.texture.source}});this.sprite=t;this._textureMatrix=s}set inverse(e){this.resources.filterUniforms.uniforms.uInverse=e?1:0}get inverse(){return this.resources.filterUniforms.uniforms.uInverse===1}apply(e,t,r,s){this._textureMatrix.texture=this.sprite.texture;e.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix,this.sprite).prepend(this._textureMatrix.mapCoord);this.resources.uMaskTexture=this.sprite.texture.source;e.applyFilter(this,t,r,s)}}var Bs="fn getLuminosity(c: vec3<f32>) -> f32 {\n  return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;\n}\n\nfn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32> {\n  let d: f32 = lum - getLuminosity(c);\n  let newColor: vec3<f32> = c.rgb + vec3<f32>(d, d, d);\n\n  // clip back into legal range\n  let newLum: f32 = getLuminosity(newColor);\n  let cMin: f32 = min(newColor.r, min(newColor.g, newColor.b));\n  let cMax: f32 = max(newColor.r, max(newColor.g, newColor.b));\n\n  let t1: f32 = newLum / (newLum - cMin);\n  let t2: f32 = (1.0 - newLum) / (cMax - newLum);\n\n  let finalColor = mix(vec3<f32>(newLum, newLum, newLum), newColor, select(select(1.0, t2, cMax > 1.0), t1, cMin < 0.0));\n\n  return finalColor;\n}\n\nfn getSaturation(c: vec3<f32>) -> f32 {\n  return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\n}\n\n// Set saturation if color components are sorted in ascending order.\nfn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32> {\n  var result: vec3<f32>;\n  if (cSorted.z > cSorted.x) {\n    let newY = (((cSorted.y - cSorted.x) * s) / (cSorted.z - cSorted.x));\n    result = vec3<f32>(0.0, newY, s);\n  } else {\n    result = vec3<f32>(0.0, 0.0, 0.0);\n  }\n  return vec3<f32>(result.x, result.y, result.z);\n}\n\nfn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32> {\n    var result: vec3<f32> = c;\n\n    if (c.r <= c.g && c.r <= c.b) {\n        if (c.g <= c.b) {\n            result = setSaturationMinMidMax(result, s);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.r, result.b, result.g);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.r, temp.b, temp.g);\n        }\n    } else if (c.g <= c.r && c.g <= c.b) {\n        if (c.r <= c.b) {\n            var temp: vec3<f32> = vec3<f32>(result.g, result.r, result.b);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.g, temp.r, temp.b);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.g, result.b, result.r);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.g, temp.b, temp.r);\n        }\n    } else {\n        if (c.r <= c.g) {\n            var temp: vec3<f32> = vec3<f32>(result.b, result.r, result.g);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.b, temp.r, temp.g);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.b, result.g, result.r);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.b, temp.g, temp.r);\n        }\n    }\n\n    return result;\n}";"use strict";"use strict";"use strict";"use strict";"use strict";"use strict";class Triangle{
/**
   * @param x - The X coord of the first point.
   * @param y - The Y coord of the first point.
   * @param x2 - The X coord of the second point.
   * @param y2 - The Y coord of the second point.
   * @param x3 - The X coord of the third point.
   * @param y3 - The Y coord of the third point.
   */
constructor(e=0,t=0,r=0,s=0,n=0,i=0){this.type="triangle";this.x=e;this.y=t;this.x2=r;this.y2=s;this.x3=n;this.y3=i}
/**
   * Checks whether the x and y coordinates given are contained within this triangle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Triangle
   */contains(e,t){const r=(this.x-this.x3)*(t-this.y3)-(this.y-this.y3)*(e-this.x3);const s=(this.x2-this.x)*(t-this.y)-(this.y2-this.y)*(e-this.x);if(r<0!==s<0&&r!==0&&s!==0)return false;const n=(this.x3-this.x2)*(t-this.y2)-(this.y3-this.y2)*(e-this.x2);return n===0||n<0===r+s<=0}
/**
   * Checks whether the x and y coordinates given are contained within this triangle including the stroke.
   * @param pointX - The X coordinate of the point to test
   * @param pointY - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param _alignment - The alignment of the stroke
   * @returns Whether the x/y coordinates are within this triangle
   */strokeContains(e,t,r,s=.5){const n=r/2;const i=n*n;const{x:o,x2:a,x3:u,y:c,y2:l,y3:d}=this;return Ne(e,t,o,c,a,d)<=i||Ne(e,t,a,l,u,d)<=i||Ne(e,t,u,d,o,c)<=i}
/**
   * Creates a clone of this Triangle
   * @returns a copy of the triangle
   */clone(){const e=new Triangle(this.x,this.y,this.x2,this.y2,this.x3,this.y3);return e}
/**
   * Copies another triangle to this one.
   * @param triangle - The triangle to copy from.
   * @returns Returns itself.
   */copyFrom(e){this.x=e.x;this.y=e.y;this.x2=e.x2;this.y2=e.y2;this.x3=e.x3;this.y3=e.y3;return this}
/**
   * Copies this triangle to another one.
   * @param triangle - The triangle to copy to.
   * @returns Returns given parameter.
   */copyTo(e){e.copyFrom(this);return e}
/**
   * Returns the framing rectangle of the triangle as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */getBounds(e){e||(e=new Ee);const t=Math.min(this.x,this.x2,this.x3);const r=Math.max(this.x,this.x2,this.x3);const s=Math.min(this.y,this.y2,this.y3);const n=Math.max(this.y,this.y2,this.y3);e.x=t;e.y=s;e.width=r-t;e.height=n-s;return e}}"use strict";"use strict";"use strict";class GlBatchAdaptor{constructor(){this._tempState=ot.for2d();this._didUploadHash={}}init(e){e.renderer.runners.contextChange.add(this)}contextChange(){this._didUploadHash={}}start(e,t,r){const s=e.renderer;const n=this._didUploadHash[r.uid];s.shader.bind(r,n);n||(this._didUploadHash[r.uid]=true);s.shader.updateUniformGroup(s.globalUniforms.uniformGroup);s.geometry.bind(t,r.glProgram)}execute(e,t){const r=e.renderer;this._tempState.blendMode=t.blendMode;r.state.set(this._tempState);const s=t.textures.textures;for(let e=0;e<t.textures.count;e++)r.texture.bind(s[e],e);r.geometry.draw(t.topology,t.size,t.start)}}GlBatchAdaptor.extension={type:[X.WebGLPipesAdaptor],name:"batch"};"use strict";function generateGPULayout(e){const t=[];let r=0;for(let s=0;s<e;s++){t[r]={texture:{sampleType:"float",viewDimension:"2d",multisampled:false},binding:r,visibility:GPUShaderStage.FRAGMENT};r++;t[r]={sampler:{type:"filtering"},binding:r,visibility:GPUShaderStage.FRAGMENT};r++}return t}"use strict";function generateLayout(e){const t={};let r=0;for(let s=0;s<e;s++){t[`textureSource${s+1}`]=r++;t[`textureSampler${s+1}`]=r++}return t}"use strict";const ws=ot.for2d();class GpuBatchAdaptor{start(e,t,r){const s=e.renderer;const n=s.encoder;const i=r.gpuProgram;this._shader=r;this._geometry=t;n.setGeometry(t,i);ws.blendMode="normal";s.pipeline.getPipeline(t,i,ws);const o=s.globalUniforms.bindGroup;n.resetBindGroup(1);n.setBindGroup(0,o,i)}execute(e,t){const r=this._shader.gpuProgram;const s=e.renderer;const n=s.encoder;if(!t.bindGroup){const e=t.textures;t.bindGroup=ut(e.textures,e.count)}ws.blendMode=t.blendMode;const i=s.bindGroup.getBindGroup(t.bindGroup,r,1);const o=s.pipeline.getPipeline(this._geometry,r,ws,t.topology);t.bindGroup._touch(s.textureGC.count);n.setPipeline(o);n.renderPassEncoder.setBindGroup(1,i);n.renderPassEncoder.drawIndexed(t.size,1,t.start)}}GpuBatchAdaptor.extension={type:[X.WebGPUPipesAdaptor],name:"batch"};"use strict";const Ms=class _BatcherPipe{constructor(e,t){this.state=ot.for2d();this._batchersByInstructionSet=Object.create(null);this._activeBatches=Object.create(null);this.renderer=e;this._adaptor=t;this._adaptor.init?.(this)}static getBatcher(e){return new this._availableBatchers[e]}buildStart(e){let t=this._batchersByInstructionSet[e.uid];if(!t){t=this._batchersByInstructionSet[e.uid]=Object.create(null);t.default||(t.default=new ct)}this._activeBatches=t;this._activeBatch=this._activeBatches.default;for(const e in this._activeBatches)this._activeBatches[e].begin()}addToBatch(e,t){if(this._activeBatch.name!==e.batcherName){this._activeBatch.break(t);let r=this._activeBatches[e.batcherName];if(!r){r=this._activeBatches[e.batcherName]=_BatcherPipe.getBatcher(e.batcherName);r.begin()}this._activeBatch=r}this._activeBatch.add(e)}break(e){this._activeBatch.break(e)}buildEnd(e){this._activeBatch.break(e);const t=this._activeBatches;for(const e in t){const r=t[e];const s=r.geometry;s.indexBuffer.setDataWithSize(r.indexBuffer,r.indexSize,true);s.buffers[0].setDataWithSize(r.attributeBuffer.float32View,r.attributeSize,false)}}upload(e){const t=this._batchersByInstructionSet[e.uid];for(const e in t){const r=t[e];const s=r.geometry;if(r.dirty){r.dirty=false;s.buffers[0].update(r.attributeSize*4)}}}execute(e){if(e.action==="startBatch"){const t=e.batcher;const r=t.geometry;const s=t.shader;this._adaptor.start(this,r,s)}this._adaptor.execute(this,e)}destroy(){this.state=null;this.renderer=null;this._adaptor=null;for(const e in this._activeBatches)this._activeBatches[e].destroy();this._activeBatches=null}};Ms.extension={type:[X.WebGLPipes,X.WebGPUPipes,X.CanvasPipes],name:"batch"};Ms._availableBatchers=Object.create(null);let Fs=Ms;Y.handleByMap(X.Batcher,Fs._availableBatchers);Y.add(ct);"use strict";"use strict";function formatShader(e){const t=e.split(/([\n{}])/g).map((e=>e.trim())).filter((e=>e.length));let r="";const s=t.map((e=>{let t=r+e;if(e==="{")r+="    ";else if(e==="}"){r=r.substr(0,r.length-4);t=r+e}return t})).join("\n");return s}"use strict";const Us={name:"texture-bit",vertex:{header:"\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        ",main:"\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        "},fragment:{header:"\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n         \n        ",main:"\n            outColor = textureSample(uTexture, uSampler, vUV);\n        "}};const Is={name:"texture-bit",vertex:{header:"\n            uniform mat3 uTextureMatrix;\n        ",main:"\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        "},fragment:{header:"\n        uniform sampler2D uTexture;\n\n         \n        ",main:"\n            outColor = texture(uTexture, vUV);\n        "}};"use strict";const Os=new ze;class AlphaMaskEffect extends he{constructor(){super();this.filters=[new MaskFilter({sprite:new st(Ae.EMPTY),inverse:false,resolution:"inherit",antialias:"inherit"})]}get sprite(){return this.filters[0].sprite}set sprite(e){this.filters[0].sprite=e}get inverse(){return this.filters[0].inverse}set inverse(e){this.filters[0].inverse=e}}class AlphaMaskPipe{constructor(e){this._activeMaskStage=[];this._renderer=e}push(e,t,r){const s=this._renderer;s.renderPipes.batch.break(r);r.add({renderPipeId:"alphaMask",action:"pushMaskBegin",mask:e,inverse:t._maskOptions.inverse,canBundle:false,maskedContainer:t});e.inverse=t._maskOptions.inverse;if(e.renderMaskToTexture){const t=e.mask;t.includeInBuild=true;t.collectRenderables(r,s,null);t.includeInBuild=false}s.renderPipes.batch.break(r);r.add({renderPipeId:"alphaMask",action:"pushMaskEnd",mask:e,maskedContainer:t,inverse:t._maskOptions.inverse,canBundle:false})}pop(e,t,r){const s=this._renderer;s.renderPipes.batch.break(r);r.add({renderPipeId:"alphaMask",action:"popMaskEnd",mask:e,inverse:t._maskOptions.inverse,canBundle:false})}execute(e){const t=this._renderer;const r=e.mask.renderMaskToTexture;if(e.action==="pushMaskBegin"){const s=Bt.get(AlphaMaskEffect);s.inverse=e.inverse;if(r){e.mask.mask.measurable=true;const r=de(e.mask.mask,true,Os);e.mask.mask.measurable=false;r.ceil();const n=t.renderTarget.renderTarget.colorTexture.source;const i=Ze.getOptimalTexture(r.width,r.height,n._resolution,n.antialias);t.renderTarget.push(i,true);t.globalUniforms.push({offset:r,worldColor:4294967295});const o=s.sprite;o.texture=i;o.worldTransform.tx=r.minX;o.worldTransform.ty=r.minY;this._activeMaskStage.push({filterEffect:s,maskedContainer:e.maskedContainer,filterTexture:i})}else{s.sprite=e.mask.mask;this._activeMaskStage.push({filterEffect:s,maskedContainer:e.maskedContainer})}}else if(e.action==="pushMaskEnd"){const e=this._activeMaskStage[this._activeMaskStage.length-1];if(r){t.type===Je.WEBGL&&t.renderTarget.finishRenderPass();t.renderTarget.pop();t.globalUniforms.pop()}t.filter.push({renderPipeId:"filter",action:"pushFilter",container:e.maskedContainer,filterEffect:e.filterEffect,canBundle:false})}else if(e.action==="popMaskEnd"){t.filter.pop();const e=this._activeMaskStage.pop();r&&Ze.returnTexture(e.filterTexture);Bt.return(e.filterEffect)}}destroy(){this._renderer=null;this._activeMaskStage=null}}AlphaMaskPipe.extension={type:[X.WebGLPipes,X.WebGPUPipes,X.CanvasPipes],name:"alphaMask"};"use strict";class ColorMaskPipe{constructor(e){this._colorStack=[];this._colorStackIndex=0;this._currentColor=0;this._renderer=e}buildStart(){this._colorStack[0]=15;this._colorStackIndex=1;this._currentColor=15}push(e,t,r){const s=this._renderer;s.renderPipes.batch.break(r);const n=this._colorStack;n[this._colorStackIndex]=n[this._colorStackIndex-1]&e.mask;const i=this._colorStack[this._colorStackIndex];if(i!==this._currentColor){this._currentColor=i;r.add({renderPipeId:"colorMask",colorMask:i,canBundle:false})}this._colorStackIndex++}pop(e,t,r){const s=this._renderer;s.renderPipes.batch.break(r);const n=this._colorStack;this._colorStackIndex--;const i=n[this._colorStackIndex-1];if(i!==this._currentColor){this._currentColor=i;r.add({renderPipeId:"colorMask",colorMask:i,canBundle:false})}}execute(e){const t=this._renderer;t.colorMask.setMask(e.colorMask)}destroy(){this._colorStack=null}}ColorMaskPipe.extension={type:[X.WebGLPipes,X.WebGPUPipes,X.CanvasPipes],name:"colorMask"};"use strict";class ScissorMask{constructor(e){this.priority=0;this.pipe="scissorMask";this.mask=e;this.mask.renderable=false;this.mask.measurable=false}addBounds(e,t){ee(this.mask,e,t)}addLocalBounds(e,t){te(this.mask,e,t)}containsPoint(e,t){const r=this.mask;return t(r,e)}reset(){this.mask.measurable=true;this.mask=null}destroy(){this.reset()}}"use strict";class StencilMaskPipe{constructor(e){this._maskStackHash={};this._maskHash=new WeakMap;this._renderer=e}push(e,t,r){var s;const n=e;const i=this._renderer;i.renderPipes.batch.break(r);i.renderPipes.blendMode.setBlendMode(n.mask,"none",r);r.add({renderPipeId:"stencilMask",action:"pushMaskBegin",mask:e,inverse:t._maskOptions.inverse,canBundle:false});const o=n.mask;o.includeInBuild=true;this._maskHash.has(n)||this._maskHash.set(n,{instructionsStart:0,instructionsLength:0});const a=this._maskHash.get(n);a.instructionsStart=r.instructionSize;o.collectRenderables(r,i,null);o.includeInBuild=false;i.renderPipes.batch.break(r);r.add({renderPipeId:"stencilMask",action:"pushMaskEnd",mask:e,inverse:t._maskOptions.inverse,canBundle:false});const u=r.instructionSize-a.instructionsStart-1;a.instructionsLength=u;const c=i.renderTarget.renderTarget.uid;(s=this._maskStackHash)[c]??(s[c]=0)}pop(e,t,r){const s=e;const n=this._renderer;n.renderPipes.batch.break(r);n.renderPipes.blendMode.setBlendMode(s.mask,"none",r);r.add({renderPipeId:"stencilMask",action:"popMaskBegin",inverse:t._maskOptions.inverse,canBundle:false});const i=this._maskHash.get(e);for(let e=0;e<i.instructionsLength;e++)r.instructions[r.instructionSize++]=r.instructions[i.instructionsStart++];r.add({renderPipeId:"stencilMask",action:"popMaskEnd",canBundle:false})}execute(e){var t;const r=this._renderer;const s=r.renderTarget.renderTarget.uid;let n=(t=this._maskStackHash)[s]??(t[s]=0);if(e.action==="pushMaskBegin"){r.renderTarget.ensureDepthStencil();r.stencil.setStencilMode(wt.RENDERING_MASK_ADD,n);n++;r.colorMask.setMask(0)}else if(e.action==="pushMaskEnd"){e.inverse?r.stencil.setStencilMode(wt.INVERSE_MASK_ACTIVE,n):r.stencil.setStencilMode(wt.MASK_ACTIVE,n);r.colorMask.setMask(15)}else if(e.action==="popMaskBegin"){r.colorMask.setMask(0);if(n!==0)r.stencil.setStencilMode(wt.RENDERING_MASK_REMOVE,n);else{r.renderTarget.clear(null,ue.STENCIL);r.stencil.setStencilMode(wt.DISABLED,n)}n--}else if(e.action==="popMaskEnd"){e.inverse?r.stencil.setStencilMode(wt.INVERSE_MASK_ACTIVE,n):r.stencil.setStencilMode(wt.MASK_ACTIVE,n);r.colorMask.setMask(15)}this._maskStackHash[s]=n}destroy(){this._renderer=null;this._maskStackHash=null;this._maskHash=null}}StencilMaskPipe.extension={type:[X.WebGLPipes,X.WebGPUPipes,X.CanvasPipes],name:"stencilMask"};"use strict";var ks=(e=>{e[e.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER";e[e.ARRAY_BUFFER=34962]="ARRAY_BUFFER";e[e.UNIFORM_BUFFER=35345]="UNIFORM_BUFFER";return e})(ks||{});"use strict";class GlBuffer{constructor(e,t){this._lastBindBaseLocation=-1;this._lastBindCallId=-1;this.buffer=e||null;this.updateID=-1;this.byteLength=-1;this.type=t}}"use strict";class GlBufferSystem{
/**
   * @param {Renderer} renderer - The renderer this System works for.
   */
constructor(e){this._gpuBuffers=Object.create(null);this._boundBufferBases=Object.create(null);this._minBaseLocation=0;this._nextBindBaseIndex=this._minBaseLocation;this._bindCallId=0;this._renderer=e;this._renderer.renderableGC.addManagedHash(this,"_gpuBuffers")}destroy(){this._renderer=null;this._gl=null;this._gpuBuffers=null;this._boundBufferBases=null}contextChange(){const e=this._gl=this._renderer.gl;this._gpuBuffers=Object.create(null);this._maxBindings=e.MAX_UNIFORM_BUFFER_BINDINGS?e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS):0}getGlBuffer(e){return this._gpuBuffers[e.uid]||this.createGLBuffer(e)}
/**
   * This binds specified buffer. On first run, it will create the webGL buffers for the context too
   * @param buffer - the buffer to bind to the renderer
   */bind(e){const{_gl:t}=this;const r=this.getGlBuffer(e);t.bindBuffer(r.type,r.buffer)}
/**
   * Binds an uniform buffer to at the given index.
   *
   * A cache is used so a buffer will not be bound again if already bound.
   * @param glBuffer - the buffer to bind
   * @param index - the base index to bind it to.
   */bindBufferBase(e,t){const{_gl:r}=this;if(this._boundBufferBases[t]!==e){this._boundBufferBases[t]=e;e._lastBindBaseLocation=t;r.bindBufferBase(r.UNIFORM_BUFFER,t,e.buffer)}}nextBindBase(e){this._bindCallId++;this._minBaseLocation=0;if(e){this._boundBufferBases[0]=null;this._minBaseLocation=1;this._nextBindBaseIndex<1&&(this._nextBindBaseIndex=1)}}freeLocationForBufferBase(e){let t=this.getLastBindBaseLocation(e);if(t>=this._minBaseLocation){e._lastBindCallId=this._bindCallId;return t}let r=0;let s=this._nextBindBaseIndex;while(r<2){if(s>=this._maxBindings){s=this._minBaseLocation;r++}const e=this._boundBufferBases[s];if(!e||e._lastBindCallId!==this._bindCallId)break;s++}t=s;this._nextBindBaseIndex=s+1;if(r>=2)return-1;e._lastBindCallId=this._bindCallId;this._boundBufferBases[t]=null;return t}getLastBindBaseLocation(e){const t=e._lastBindBaseLocation;return this._boundBufferBases[t]===e?t:-1}
/**
   * Binds a buffer whilst also binding its range.
   * This will make the buffer start from the offset supplied rather than 0 when it is read.
   * @param glBuffer - the buffer to bind
   * @param index - the base index to bind at, defaults to 0
   * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
   * @param size - the size to bind at (this is blocks of 256).
   */bindBufferRange(e,t,r,s){const{_gl:n}=this;r||(r=0);t||(t=0);this._boundBufferBases[t]=null;n.bindBufferRange(n.UNIFORM_BUFFER,t||0,e.buffer,r*256,s||256)}
/**
   * Will ensure the data in the buffer is uploaded to the GPU.
   * @param {Buffer} buffer - the buffer to update
   */updateBuffer(e){const{_gl:t}=this;const r=this.getGlBuffer(e);if(e._updateID===r.updateID)return r;r.updateID=e._updateID;t.bindBuffer(r.type,r.buffer);const s=e.data;const n=e.descriptor.usage&Mt.STATIC?t.STATIC_DRAW:t.DYNAMIC_DRAW;if(s)if(r.byteLength>=s.byteLength)t.bufferSubData(r.type,0,s,0,e._updateSize/s.BYTES_PER_ELEMENT);else{r.byteLength=s.byteLength;t.bufferData(r.type,s,n)}else{r.byteLength=e.descriptor.size;t.bufferData(r.type,r.byteLength,n)}return r}destroyAll(){const e=this._gl;for(const t in this._gpuBuffers)e.deleteBuffer(this._gpuBuffers[t].buffer);this._gpuBuffers=Object.create(null)}
/**
   * Disposes buffer
   * @param {Buffer} buffer - buffer with data
   * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
   */onBufferDestroy(e,t){const r=this._gpuBuffers[e.uid];const s=this._gl;t||s.deleteBuffer(r.buffer);this._gpuBuffers[e.uid]=null}
/**
   * creates and attaches a GLBuffer object tied to the current context.
   * @param buffer
   * @protected
   */createGLBuffer(e){const{_gl:t}=this;let r=ks.ARRAY_BUFFER;e.descriptor.usage&Mt.INDEX?r=ks.ELEMENT_ARRAY_BUFFER:e.descriptor.usage&Mt.UNIFORM&&(r=ks.UNIFORM_BUFFER);const s=new GlBuffer(t.createBuffer(),r);this._gpuBuffers[e.uid]=s;e.on("destroy",this.onBufferDestroy,this);return s}resetState(){this._boundBufferBases=Object.create(null)}}GlBufferSystem.extension={type:[X.WebGLSystem],name:"buffer"};"use strict";const Ls=class _GlContextSystem{
/** @param renderer - The renderer this System works for. */
constructor(e){
/**
     * Features supported by current renderer.
     * @type {object}
     * @readonly
     */
this.supports={uint32Indices:true,uniformBufferObject:true,vertexArrayObject:true,srgbTextures:true,nonPowOf2wrapping:true,msaa:true,nonPowOf2mipmaps:true};this._renderer=e;this.extensions=Object.create(null);this.handleContextLost=this.handleContextLost.bind(this);this.handleContextRestored=this.handleContextRestored.bind(this)}get isLost(){return!this.gl||this.gl.isContextLost()}
/**
   * Handles the context change event.
   * @param {WebGLRenderingContext} gl - New WebGL context.
   */contextChange(e){this.gl=e;this._renderer.gl=e}init(e){e={..._GlContextSystem.defaultOptions,...e};let t=this.multiView=e.multiView;if(e.context&&t){Fe("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.");t=false}this.canvas=t?ve.get().createCanvas(this._renderer.canvas.width,this._renderer.canvas.height):this._renderer.view.canvas;if(e.context)this.initFromContext(e.context);else{const t=this._renderer.background.alpha<1;const r=e.premultipliedAlpha??true;const s=e.antialias&&!this._renderer.backBuffer.useBackBuffer;this.createContext(e.preferWebGLVersion,{alpha:t,premultipliedAlpha:r,antialias:s,stencil:true,preserveDrawingBuffer:e.preserveDrawingBuffer,powerPreference:e.powerPreference??"default"})}}ensureCanvasSize(e){if(!this.multiView){e!==this.canvas&&Fe("multiView is disabled, but targetCanvas is not the main canvas");return}const{canvas:t}=this;if(t.width<e.width||t.height<e.height){t.width=Math.max(e.width,e.width);t.height=Math.max(e.height,e.height)}}
/**
   * Initializes the context.
   * @protected
   * @param {WebGLRenderingContext} gl - WebGL context
   */initFromContext(e){this.gl=e;this.webGLVersion=e instanceof ve.get().getWebGLRenderingContext()?1:2;this.getExtensions();this.validateContext(e);this._renderer.runners.contextChange.emit(e);const t=this._renderer.view.canvas;t.addEventListener("webglcontextlost",this.handleContextLost,false);t.addEventListener("webglcontextrestored",this.handleContextRestored,false)}
/**
   * Initialize from context options
   * @protected
   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
   * @param preferWebGLVersion
   * @param {object} options - context attributes
   */createContext(e,t){let r;const s=this.canvas;e===2&&(r=s.getContext("webgl2",t));if(!r){r=s.getContext("webgl",t);if(!r)throw new Error("This browser does not support WebGL. Try using the canvas renderer")}this.gl=r;this.initFromContext(this.gl)}getExtensions(){const{gl:e}=this;const t={anisotropicFiltering:e.getExtension("EXT_texture_filter_anisotropic"),floatTextureLinear:e.getExtension("OES_texture_float_linear"),s3tc:e.getExtension("WEBGL_compressed_texture_s3tc"),s3tc_sRGB:e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),etc:e.getExtension("WEBGL_compressed_texture_etc"),etc1:e.getExtension("WEBGL_compressed_texture_etc1"),pvrtc:e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),atc:e.getExtension("WEBGL_compressed_texture_atc"),astc:e.getExtension("WEBGL_compressed_texture_astc"),bptc:e.getExtension("EXT_texture_compression_bptc"),rgtc:e.getExtension("EXT_texture_compression_rgtc"),loseContext:e.getExtension("WEBGL_lose_context")};if(this.webGLVersion===1)this.extensions={...t,drawBuffers:e.getExtension("WEBGL_draw_buffers"),depthTexture:e.getExtension("WEBGL_depth_texture"),vertexArrayObject:e.getExtension("OES_vertex_array_object")||e.getExtension("MOZ_OES_vertex_array_object")||e.getExtension("WEBKIT_OES_vertex_array_object"),uint32ElementIndex:e.getExtension("OES_element_index_uint"),floatTexture:e.getExtension("OES_texture_float"),floatTextureLinear:e.getExtension("OES_texture_float_linear"),textureHalfFloat:e.getExtension("OES_texture_half_float"),textureHalfFloatLinear:e.getExtension("OES_texture_half_float_linear"),vertexAttribDivisorANGLE:e.getExtension("ANGLE_instanced_arrays"),srgb:e.getExtension("EXT_sRGB")};else{this.extensions={...t,colorBufferFloat:e.getExtension("EXT_color_buffer_float")};const r=e.getExtension("WEBGL_provoking_vertex");r&&r.provokingVertexWEBGL(r.FIRST_VERTEX_CONVENTION_WEBGL)}}
/**
   * Handles a lost webgl context
   * @param {WebGLContextEvent} event - The context lost event.
   */handleContextLost(e){e.preventDefault();if(this._contextLossForced){this._contextLossForced=false;setTimeout((()=>{this.gl.isContextLost()&&this.extensions.loseContext?.restoreContext()}),0)}}handleContextRestored(){this._renderer.runners.contextChange.emit(this.gl)}destroy(){const e=this._renderer.view.canvas;this._renderer=null;e.removeEventListener("webglcontextlost",this.handleContextLost);e.removeEventListener("webglcontextrestored",this.handleContextRestored);this.gl.useProgram(null);this.extensions.loseContext?.loseContext()}forceContextLoss(){this.extensions.loseContext?.loseContext();this._contextLossForced=true}
/**
   * Validate context.
   * @param {WebGLRenderingContext} gl - Render context.
   */validateContext(e){const t=e.getContextAttributes();t&&!t.stencil&&Fe("Provided WebGL context does not have a stencil buffer, masks may not render correctly");const r=this.supports;const s=this.webGLVersion===2;const n=this.extensions;r.uint32Indices=s||!!n.uint32ElementIndex;r.uniformBufferObject=s;r.vertexArrayObject=s||!!n.vertexArrayObject;r.srgbTextures=s||!!n.srgb;r.nonPowOf2wrapping=s;r.nonPowOf2mipmaps=s;r.msaa=s;r.uint32Indices||Fe("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly")}};Ls.extension={type:[X.WebGLSystem],name:"context"};Ls.defaultOptions={context:null,premultipliedAlpha:true,preserveDrawingBuffer:false,powerPreference:void 0,preferWebGLVersion:2,multiView:false};let Ds=Ls;"use strict";"use strict";"use strict";function ensureAttributes(e,t){for(const r in e.attributes){const s=e.attributes[r];const n=t[r];if(n){s.format??(s.format=n.format);s.offset??(s.offset=n.offset);s.instance??(s.instance=n.instance)}else Fe(`Attribute ${r} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`)}ensureStartAndStride(e)}function ensureStartAndStride(e){const{buffers:t,attributes:r}=e;const s={};const n={};for(const e in t){const r=t[e];s[r.uid]=0;n[r.uid]=0}for(const e in r){const t=r[e];s[t.buffer.uid]+=It(t.format).stride}for(const e in r){const t=r[e];t.stride??(t.stride=s[t.buffer.uid]);t.start??(t.start=n[t.buffer.uid]);n[t.buffer.uid]+=It(t.format).stride}}"use strict";var Ns=(e=>{e[e.RGBA=6408]="RGBA";e[e.RGB=6407]="RGB";e[e.RG=33319]="RG";e[e.RED=6403]="RED";e[e.RGBA_INTEGER=36249]="RGBA_INTEGER";e[e.RGB_INTEGER=36248]="RGB_INTEGER";e[e.RG_INTEGER=33320]="RG_INTEGER";e[e.RED_INTEGER=36244]="RED_INTEGER";e[e.ALPHA=6406]="ALPHA";e[e.LUMINANCE=6409]="LUMINANCE";e[e.LUMINANCE_ALPHA=6410]="LUMINANCE_ALPHA";e[e.DEPTH_COMPONENT=6402]="DEPTH_COMPONENT";e[e.DEPTH_STENCIL=34041]="DEPTH_STENCIL";return e})(Ns||{});var Hs=(e=>{e[e.TEXTURE_2D=3553]="TEXTURE_2D";e[e.TEXTURE_CUBE_MAP=34067]="TEXTURE_CUBE_MAP";e[e.TEXTURE_2D_ARRAY=35866]="TEXTURE_2D_ARRAY";e[e.TEXTURE_CUBE_MAP_POSITIVE_X=34069]="TEXTURE_CUBE_MAP_POSITIVE_X";e[e.TEXTURE_CUBE_MAP_NEGATIVE_X=34070]="TEXTURE_CUBE_MAP_NEGATIVE_X";e[e.TEXTURE_CUBE_MAP_POSITIVE_Y=34071]="TEXTURE_CUBE_MAP_POSITIVE_Y";e[e.TEXTURE_CUBE_MAP_NEGATIVE_Y=34072]="TEXTURE_CUBE_MAP_NEGATIVE_Y";e[e.TEXTURE_CUBE_MAP_POSITIVE_Z=34073]="TEXTURE_CUBE_MAP_POSITIVE_Z";e[e.TEXTURE_CUBE_MAP_NEGATIVE_Z=34074]="TEXTURE_CUBE_MAP_NEGATIVE_Z";return e})(Hs||{});var Vs=(e=>{e[e.CLAMP=33071]="CLAMP";e[e.REPEAT=10497]="REPEAT";e[e.MIRRORED_REPEAT=33648]="MIRRORED_REPEAT";return e})(Vs||{});var Ws=(e=>{e[e.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE";e[e.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT";e[e.UNSIGNED_SHORT_5_6_5=33635]="UNSIGNED_SHORT_5_6_5";e[e.UNSIGNED_SHORT_4_4_4_4=32819]="UNSIGNED_SHORT_4_4_4_4";e[e.UNSIGNED_SHORT_5_5_5_1=32820]="UNSIGNED_SHORT_5_5_5_1";e[e.UNSIGNED_INT=5125]="UNSIGNED_INT";e[e.UNSIGNED_INT_10F_11F_11F_REV=35899]="UNSIGNED_INT_10F_11F_11F_REV";e[e.UNSIGNED_INT_2_10_10_10_REV=33640]="UNSIGNED_INT_2_10_10_10_REV";e[e.UNSIGNED_INT_24_8=34042]="UNSIGNED_INT_24_8";e[e.UNSIGNED_INT_5_9_9_9_REV=35902]="UNSIGNED_INT_5_9_9_9_REV";e[e.BYTE=5120]="BYTE";e[e.SHORT=5122]="SHORT";e[e.INT=5124]="INT";e[e.FLOAT=5126]="FLOAT";e[e.FLOAT_32_UNSIGNED_INT_24_8_REV=36269]="FLOAT_32_UNSIGNED_INT_24_8_REV";e[e.HALF_FLOAT=36193]="HALF_FLOAT";return e})(Ws||{});"use strict";const js={uint8x2:Ws.UNSIGNED_BYTE,uint8x4:Ws.UNSIGNED_BYTE,sint8x2:Ws.BYTE,sint8x4:Ws.BYTE,unorm8x2:Ws.UNSIGNED_BYTE,unorm8x4:Ws.UNSIGNED_BYTE,snorm8x2:Ws.BYTE,snorm8x4:Ws.BYTE,uint16x2:Ws.UNSIGNED_SHORT,uint16x4:Ws.UNSIGNED_SHORT,sint16x2:Ws.SHORT,sint16x4:Ws.SHORT,unorm16x2:Ws.UNSIGNED_SHORT,unorm16x4:Ws.UNSIGNED_SHORT,snorm16x2:Ws.SHORT,snorm16x4:Ws.SHORT,float16x2:Ws.HALF_FLOAT,float16x4:Ws.HALF_FLOAT,float32:Ws.FLOAT,float32x2:Ws.FLOAT,float32x3:Ws.FLOAT,float32x4:Ws.FLOAT,uint32:Ws.UNSIGNED_INT,uint32x2:Ws.UNSIGNED_INT,uint32x3:Ws.UNSIGNED_INT,uint32x4:Ws.UNSIGNED_INT,sint32:Ws.INT,sint32x2:Ws.INT,sint32x3:Ws.INT,sint32x4:Ws.INT};function getGlTypeFromFormat(e){return js[e]??js.float32}"use strict";const zs={"point-list":0,"line-list":1,"line-strip":3,"triangle-list":4,"triangle-strip":5};class GlGeometrySystem{
/** @param renderer - The renderer this System works for. */
constructor(e){this._geometryVaoHash=Object.create(null);this._renderer=e;this._activeGeometry=null;this._activeVao=null;this.hasVao=true;this.hasInstance=true;this._renderer.renderableGC.addManagedHash(this,"_geometryVaoHash")}contextChange(){const e=this.gl=this._renderer.gl;if(!this._renderer.context.supports.vertexArrayObject)throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");const t=this._renderer.context.extensions.vertexArrayObject;if(t){e.createVertexArray=()=>t.createVertexArrayOES();e.bindVertexArray=e=>t.bindVertexArrayOES(e);e.deleteVertexArray=e=>t.deleteVertexArrayOES(e)}const r=this._renderer.context.extensions.vertexAttribDivisorANGLE;if(r){e.drawArraysInstanced=(e,t,s,n)=>{r.drawArraysInstancedANGLE(e,t,s,n)};e.drawElementsInstanced=(e,t,s,n,i)=>{r.drawElementsInstancedANGLE(e,t,s,n,i)};e.vertexAttribDivisor=(e,t)=>r.vertexAttribDivisorANGLE(e,t)}this._activeGeometry=null;this._activeVao=null;this._geometryVaoHash=Object.create(null)}
/**
   * Binds geometry so that is can be drawn. Creating a Vao if required
   * @param geometry - Instance of geometry to bind.
   * @param program - Instance of program to use vao for.
   */bind(e,t){const r=this.gl;this._activeGeometry=e;const s=this.getVao(e,t);if(this._activeVao!==s){this._activeVao=s;r.bindVertexArray(s)}this.updateBuffers()}resetState(){this.unbind()}updateBuffers(){const e=this._activeGeometry;const t=this._renderer.buffer;for(let r=0;r<e.buffers.length;r++){const s=e.buffers[r];t.updateBuffer(s)}}
/**
   * Check compatibility between a geometry and a program
   * @param geometry - Geometry instance.
   * @param program - Program instance.
   */checkCompatibility(e,t){const r=e.attributes;const s=t._attributeData;for(const e in s)if(!r[e])throw new Error(`shader and geometry incompatible, geometry missing the "${e}" attribute`)}
/**
   * Takes a geometry and program and generates a unique signature for them.
   * @param geometry - To get signature from.
   * @param program - To test geometry against.
   * @returns - Unique signature of the geometry and program
   */getSignature(e,t){const r=e.attributes;const s=t._attributeData;const n=["g",e.uid];for(const e in r)s[e]&&n.push(e,s[e].location);return n.join("-")}getVao(e,t){return this._geometryVaoHash[e.uid]?.[t._key]||this.initGeometryVao(e,t)}
/**
   * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
   * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
   * attribute locations.
   * @param geometry - Instance of geometry to to generate Vao for.
   * @param program
   * @param _incRefCount - Increment refCount of all geometry buffers.
   */initGeometryVao(e,t,r=true){const s=this._renderer.gl;const n=this._renderer.buffer;this._renderer.shader._getProgramData(t);this.checkCompatibility(e,t);const i=this.getSignature(e,t);if(!this._geometryVaoHash[e.uid]){this._geometryVaoHash[e.uid]=Object.create(null);e.on("destroy",this.onGeometryDestroy,this)}const o=this._geometryVaoHash[e.uid];let a=o[i];if(a){o[t._key]=a;return a}ensureAttributes(e,t._attributeData);const u=e.buffers;a=s.createVertexArray();s.bindVertexArray(a);for(let e=0;e<u.length;e++){const t=u[e];n.bind(t)}this.activateVao(e,t);o[t._key]=a;o[i]=a;s.bindVertexArray(null);return a}
/**
   * Disposes geometry.
   * @param geometry - Geometry with buffers. Only VAO will be disposed
   * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray
   */onGeometryDestroy(e,t){const r=this._geometryVaoHash[e.uid];const s=this.gl;if(r){if(t)for(const e in r){this._activeVao!==r[e]&&this.unbind();s.deleteVertexArray(r[e])}this._geometryVaoHash[e.uid]=null}}
/**
   * Dispose all WebGL resources of all managed geometries.
   * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
   */destroyAll(e=false){const t=this.gl;for(const r in this._geometryVaoHash){if(e)for(const e in this._geometryVaoHash[r]){const s=this._geometryVaoHash[r];this._activeVao!==s&&this.unbind();t.deleteVertexArray(s[e])}this._geometryVaoHash[r]=null}}
/**
   * Activate vertex array object.
   * @param geometry - Geometry instance.
   * @param program - Shader program instance.
   */activateVao(e,t){const r=this._renderer.gl;const s=this._renderer.buffer;const n=e.attributes;e.indexBuffer&&s.bind(e.indexBuffer);let i=null;for(const e in n){const o=n[e];const a=o.buffer;const u=s.getGlBuffer(a);const c=t._attributeData[e];if(c){if(i!==u){s.bind(a);i=u}const e=c.location;r.enableVertexAttribArray(e);const t=It(o.format);const n=getGlTypeFromFormat(o.format);c.format?.substring(1,4)==="int"?r.vertexAttribIPointer(e,t.size,n,o.stride,o.offset):r.vertexAttribPointer(e,t.size,n,t.normalised,o.stride,o.offset);if(o.instance){if(!this.hasInstance)throw new Error("geometry error, GPU Instancing is not supported on this device");{const t=o.divisor??1;r.vertexAttribDivisor(e,t)}}}}}
/**
   * Draws the currently bound geometry.
   * @param topology - The type primitive to render.
   * @param size - The number of elements to be rendered. If not specified, all vertices after the
   *  starting vertex will be drawn.
   * @param start - The starting vertex in the geometry to start drawing from. If not specified,
   *  drawing will start from the first vertex.
   * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
   *  all instances will be drawn.
   */draw(e,t,r,s){const{gl:n}=this._renderer;const i=this._activeGeometry;const o=zs[e||i.topology];s??(s=i.instanceCount);if(i.indexBuffer){const e=i.indexBuffer.data.BYTES_PER_ELEMENT;const a=e===2?n.UNSIGNED_SHORT:n.UNSIGNED_INT;s>1?n.drawElementsInstanced(o,t||i.indexBuffer.data.length,a,(r||0)*e,s):n.drawElements(o,t||i.indexBuffer.data.length,a,(r||0)*e)}else s>1?n.drawArraysInstanced(o,r||0,t||i.getSize(),s):n.drawArrays(o,r||0,t||i.getSize());return this}unbind(){this.gl.bindVertexArray(null);this._activeVao=null;this._activeGeometry=null}destroy(){this._renderer=null;this.gl=null;this._activeVao=null;this._activeGeometry=null}}GlGeometrySystem.extension={type:[X.WebGLSystem],name:"geometry"};"use strict";const Xs=new Ft({attributes:{aPosition:[-1,-1,3,-1,-1,3]}});const Ys=class _GlBackBufferSystem{constructor(e){this.useBackBuffer=false;this._useBackBufferThisRender=false;this._renderer=e}init(e={}){const{useBackBuffer:t,antialias:r}={..._GlBackBufferSystem.defaultOptions,...e};this.useBackBuffer=t;this._antialias=r;if(!this._renderer.context.supports.msaa){Fe("antialiasing, is not supported on when using the back buffer");this._antialias=false}this._state=ot.for2d();const s=new Ke({vertex:"\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n                    vUv = (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y = 1.0 - vUv.y;\n                }",fragment:"\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor = texture(uTexture, vUv);\n                }",name:"big-triangle"});this._bigTriangleShader=new $e({glProgram:s,resources:{uTexture:Ae.WHITE.source}})}
/**
   * This is called before the RenderTargetSystem is started. This is where
   * we replace the target with the back buffer if required.
   * @param options - The options for this render.
   */renderStart(e){const t=this._renderer.renderTarget.getRenderTarget(e.target);this._useBackBufferThisRender=this.useBackBuffer&&!!t.isRoot;if(this._useBackBufferThisRender){const t=this._renderer.renderTarget.getRenderTarget(e.target);this._targetTexture=t.colorTexture;e.target=this._getBackBufferTexture(t.colorTexture)}}renderEnd(){this._presentBackBuffer()}_presentBackBuffer(){const e=this._renderer;e.renderTarget.finishRenderPass();if(this._useBackBufferThisRender){e.renderTarget.bind(this._targetTexture,false);this._bigTriangleShader.resources.uTexture=this._backBufferTexture.source;e.encoder.draw({geometry:Xs,shader:this._bigTriangleShader,state:this._state})}}_getBackBufferTexture(e){this._backBufferTexture=this._backBufferTexture||new Ae({source:new Ce({width:e.width,height:e.height,resolution:e._resolution,antialias:this._antialias})});this._backBufferTexture.source.resize(e.width,e.height,e._resolution);return this._backBufferTexture}destroy(){if(this._backBufferTexture){this._backBufferTexture.destroy();this._backBufferTexture=null}}};Ys.extension={type:[X.WebGLSystem],name:"backBuffer",priority:1};Ys.defaultOptions={useBackBuffer:false};let Ks=Ys;"use strict";class GlColorMaskSystem{constructor(e){this._colorMaskCache=15;this._renderer=e}setMask(e){if(this._colorMaskCache!==e){this._colorMaskCache=e;this._renderer.gl.colorMask(!!(e&8),!!(e&4),!!(e&2),!!(e&1))}}}GlColorMaskSystem.extension={type:[X.WebGLSystem],name:"colorMask"};"use strict";class GlEncoderSystem{constructor(e){this.commandFinished=Promise.resolve();this._renderer=e}setGeometry(e,t){this._renderer.geometry.bind(e,t.glProgram)}finishRenderPass(){}draw(e){const t=this._renderer;const{geometry:r,shader:s,state:n,skipSync:i,topology:o,size:a,start:u,instanceCount:c}=e;t.shader.bind(s,i);t.geometry.bind(r,t.shader._activeProgram);n&&t.state.set(n);t.geometry.draw(o,a,u,c??r.instanceCount)}destroy(){this._renderer=null}}GlEncoderSystem.extension={type:[X.WebGLSystem],name:"encoder"};"use strict";class GlRenderTarget{constructor(){this.width=-1;this.height=-1;this.msaa=false;this.msaaRenderBuffer=[]}}"use strict";const $s=[];$s[wt.NONE]=void 0;$s[wt.DISABLED]={stencilWriteMask:0,stencilReadMask:0};$s[wt.RENDERING_MASK_ADD]={stencilFront:{compare:"equal",passOp:"increment-clamp"},stencilBack:{compare:"equal",passOp:"increment-clamp"}};$s[wt.RENDERING_MASK_REMOVE]={stencilFront:{compare:"equal",passOp:"decrement-clamp"},stencilBack:{compare:"equal",passOp:"decrement-clamp"}};$s[wt.MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"equal",passOp:"keep"},stencilBack:{compare:"equal",passOp:"keep"}};$s[wt.INVERSE_MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"not-equal",passOp:"replace"},stencilBack:{compare:"not-equal",passOp:"replace"}};"use strict";class GlStencilSystem{constructor(e){this._stencilCache={enabled:false,stencilReference:0,stencilMode:wt.NONE};this._renderTargetStencilState=Object.create(null);e.renderTarget.onRenderTargetChange.add(this)}contextChange(e){this._gl=e;this._comparisonFuncMapping={always:e.ALWAYS,never:e.NEVER,equal:e.EQUAL,"not-equal":e.NOTEQUAL,less:e.LESS,"less-equal":e.LEQUAL,greater:e.GREATER,"greater-equal":e.GEQUAL};this._stencilOpsMapping={keep:e.KEEP,zero:e.ZERO,replace:e.REPLACE,invert:e.INVERT,"increment-clamp":e.INCR,"decrement-clamp":e.DECR,"increment-wrap":e.INCR_WRAP,"decrement-wrap":e.DECR_WRAP};this.resetState()}onRenderTargetChange(e){if(this._activeRenderTarget===e)return;this._activeRenderTarget=e;let t=this._renderTargetStencilState[e.uid];t||(t=this._renderTargetStencilState[e.uid]={stencilMode:wt.DISABLED,stencilReference:0});this.setStencilMode(t.stencilMode,t.stencilReference)}resetState(){this._stencilCache.enabled=false;this._stencilCache.stencilMode=wt.NONE;this._stencilCache.stencilReference=0}setStencilMode(e,t){const r=this._renderTargetStencilState[this._activeRenderTarget.uid];const s=this._gl;const n=$s[e];const i=this._stencilCache;r.stencilMode=e;r.stencilReference=t;if(e!==wt.DISABLED){if(!this._stencilCache.enabled){this._stencilCache.enabled=true;s.enable(s.STENCIL_TEST)}if(e!==i.stencilMode||i.stencilReference!==t){i.stencilMode=e;i.stencilReference=t;s.stencilFunc(this._comparisonFuncMapping[n.stencilBack.compare],t,255);s.stencilOp(s.KEEP,s.KEEP,this._stencilOpsMapping[n.stencilBack.passOp])}}else if(this._stencilCache.enabled){this._stencilCache.enabled=false;s.disable(s.STENCIL_TEST)}}}GlStencilSystem.extension={type:[X.WebGLSystem],name:"stencil"};"use strict";class GlRenderTargetAdaptor{constructor(){this._clearColorCache=[0,0,0,0];this._viewPortCache=new Ee}init(e,t){this._renderer=e;this._renderTargetSystem=t;e.runners.contextChange.add(this)}contextChange(){this._clearColorCache=[0,0,0,0];this._viewPortCache=new Ee}copyToTexture(e,t,r,s,n){const i=this._renderTargetSystem;const o=this._renderer;const a=i.getGpuRenderTarget(e);const u=o.gl;this.finishRenderPass(e);u.bindFramebuffer(u.FRAMEBUFFER,a.resolveTargetFramebuffer);o.texture.bind(t,0);u.copyTexSubImage2D(u.TEXTURE_2D,0,n.x,n.y,r.x,r.y,s.width,s.height);return t}startRenderPass(e,t=true,r,s){const n=this._renderTargetSystem;const i=e.colorTexture;const o=n.getGpuRenderTarget(e);let a=s.y;e.isRoot&&(a=i.pixelHeight-s.height);e.colorTextures.forEach((e=>{this._renderer.texture.unbind(e)}));const u=this._renderer.gl;u.bindFramebuffer(u.FRAMEBUFFER,o.framebuffer);const c=this._viewPortCache;if(c.x!==s.x||c.y!==a||c.width!==s.width||c.height!==s.height){c.x=s.x;c.y=a;c.width=s.width;c.height=s.height;u.viewport(s.x,a,s.width,s.height)}o.depthStencilRenderBuffer||!e.stencil&&!e.depth||this._initStencil(o);this.clear(e,t,r)}finishRenderPass(e){const t=this._renderTargetSystem;const r=t.getGpuRenderTarget(e);if(!r.msaa)return;const s=this._renderer.gl;s.bindFramebuffer(s.FRAMEBUFFER,r.resolveTargetFramebuffer);s.bindFramebuffer(s.READ_FRAMEBUFFER,r.framebuffer);s.blitFramebuffer(0,0,r.width,r.height,0,0,r.width,r.height,s.COLOR_BUFFER_BIT,s.NEAREST);s.bindFramebuffer(s.FRAMEBUFFER,r.framebuffer)}initGpuRenderTarget(e){const t=this._renderer;const r=t.gl;const s=new GlRenderTarget;const n=e.colorTexture;if(Ht.test(n.resource)){this._renderer.context.ensureCanvasSize(e.colorTexture.resource);s.framebuffer=null;return s}this._initColor(e,s);r.bindFramebuffer(r.FRAMEBUFFER,null);return s}destroyGpuRenderTarget(e){const t=this._renderer.gl;if(e.framebuffer){t.deleteFramebuffer(e.framebuffer);e.framebuffer=null}if(e.resolveTargetFramebuffer){t.deleteFramebuffer(e.resolveTargetFramebuffer);e.resolveTargetFramebuffer=null}if(e.depthStencilRenderBuffer){t.deleteRenderbuffer(e.depthStencilRenderBuffer);e.depthStencilRenderBuffer=null}e.msaaRenderBuffer.forEach((e=>{t.deleteRenderbuffer(e)}));e.msaaRenderBuffer=null}clear(e,t,r){if(!t)return;const s=this._renderTargetSystem;typeof t==="boolean"&&(t=t?ue.ALL:ue.NONE);const n=this._renderer.gl;if(t&ue.COLOR){r??(r=s.defaultClearColor);const e=this._clearColorCache;const t=r;if(e[0]!==t[0]||e[1]!==t[1]||e[2]!==t[2]||e[3]!==t[3]){e[0]=t[0];e[1]=t[1];e[2]=t[2];e[3]=t[3];n.clearColor(t[0],t[1],t[2],t[3])}}n.clear(t)}resizeGpuRenderTarget(e){if(e.isRoot)return;const t=this._renderTargetSystem;const r=t.getGpuRenderTarget(e);this._resizeColor(e,r);(e.stencil||e.depth)&&this._resizeStencil(r)}_initColor(e,t){const r=this._renderer;const s=r.gl;const n=s.createFramebuffer();t.resolveTargetFramebuffer=n;s.bindFramebuffer(s.FRAMEBUFFER,n);t.width=e.colorTexture.source.pixelWidth;t.height=e.colorTexture.source.pixelHeight;e.colorTextures.forEach(((e,n)=>{const i=e.source;i.antialias&&(r.context.supports.msaa?t.msaa=true:Fe("[RenderTexture] Antialiasing on textures is not supported in WebGL1"));r.texture.bindSource(i,0);const o=r.texture.getGlSource(i);const a=o.texture;s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0+n,3553,a,0)}));if(t.msaa){const r=s.createFramebuffer();t.framebuffer=r;s.bindFramebuffer(s.FRAMEBUFFER,r);e.colorTextures.forEach(((e,r)=>{const n=s.createRenderbuffer();t.msaaRenderBuffer[r]=n}))}else t.framebuffer=n;this._resizeColor(e,t)}_resizeColor(e,t){const r=e.colorTexture.source;t.width=r.pixelWidth;t.height=r.pixelHeight;e.colorTextures.forEach(((e,t)=>{t!==0&&e.source.resize(r.width,r.height,r._resolution)}));if(t.msaa){const r=this._renderer;const s=r.gl;const n=t.framebuffer;s.bindFramebuffer(s.FRAMEBUFFER,n);e.colorTextures.forEach(((e,n)=>{const i=e.source;r.texture.bindSource(i,0);const o=r.texture.getGlSource(i);const a=o.internalFormat;const u=t.msaaRenderBuffer[n];s.bindRenderbuffer(s.RENDERBUFFER,u);s.renderbufferStorageMultisample(s.RENDERBUFFER,4,a,i.pixelWidth,i.pixelHeight);s.framebufferRenderbuffer(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0+n,s.RENDERBUFFER,u)}))}}_initStencil(e){if(e.framebuffer===null)return;const t=this._renderer.gl;const r=t.createRenderbuffer();e.depthStencilRenderBuffer=r;t.bindRenderbuffer(t.RENDERBUFFER,r);t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.RENDERBUFFER,r);this._resizeStencil(e)}_resizeStencil(e){const t=this._renderer.gl;t.bindRenderbuffer(t.RENDERBUFFER,e.depthStencilRenderBuffer);e.msaa?t.renderbufferStorageMultisample(t.RENDERBUFFER,4,t.DEPTH24_STENCIL8,e.width,e.height):t.renderbufferStorage(t.RENDERBUFFER,this._renderer.context.webGLVersion===2?t.DEPTH24_STENCIL8:t.DEPTH_STENCIL,e.width,e.height)}prerender(e){const t=e.colorTexture.resource;this._renderer.context.multiView&&Ht.test(t)&&this._renderer.context.ensureCanvasSize(t)}postrender(e){if(this._renderer.context.multiView&&Ht.test(e.colorTexture.resource)){const t=this._renderer.context.canvas;const r=e.colorTexture;r.context2D.drawImage(t,0,r.pixelHeight-t.height)}}}"use strict";function calculateProjection(e,t,r,s,n,i){const o=i?1:-1;e.identity();e.a=1/s*2;e.d=o*(1/n*2);e.tx=-1-t*e.a;e.ty=-o-r*e.d;return e}"use strict";const qs=new Map;function getCanvasTexture(e,t){if(!qs.has(e)){const r=new Ae({source:new Ht({resource:e,...t})});const onDestroy=()=>{qs.get(e)===r&&qs.delete(e)};r.once("destroy",onDestroy);r.source.once("destroy",onDestroy);qs.set(e,r)}return qs.get(e)}function hasCachedCanvasTexture(e){return qs.has(e)}"use strict";function isRenderingToScreen(e){const t=e.colorTexture.source.resource;return globalThis.HTMLCanvasElement&&t instanceof HTMLCanvasElement&&document.body.contains(t)}"use strict";const Qs=class _RenderTarget{
/**
   * @param [descriptor] - Options for creating a render target.
   */
constructor(e={}){this.uid=tt("renderTarget");this.colorTextures=[];this.dirtyId=0;this.isRoot=false;this._size=new Float32Array(2);this._managedColorTextures=false;e={..._RenderTarget.defaultOptions,...e};this.stencil=e.stencil;this.depth=e.depth;this.isRoot=e.isRoot;if(typeof e.colorTextures==="number"){this._managedColorTextures=true;for(let t=0;t<e.colorTextures;t++)this.colorTextures.push(new Ce({width:e.width,height:e.height,resolution:e.resolution,antialias:e.antialias}))}else{this.colorTextures=[...e.colorTextures.map((e=>e.source))];const t=this.colorTexture.source;this.resize(t.width,t.height,t._resolution)}this.colorTexture.source.on("resize",this.onSourceResize,this);(e.depthStencilTexture||this.stencil)&&(e.depthStencilTexture instanceof Ae||e.depthStencilTexture instanceof Ce?this.depthStencilTexture=e.depthStencilTexture.source:this.ensureDepthStencilTexture())}get size(){const e=this._size;e[0]=this.pixelWidth;e[1]=this.pixelHeight;return e}get width(){return this.colorTexture.source.width}get height(){return this.colorTexture.source.height}get pixelWidth(){return this.colorTexture.source.pixelWidth}get pixelHeight(){return this.colorTexture.source.pixelHeight}get resolution(){return this.colorTexture.source._resolution}get colorTexture(){return this.colorTextures[0]}onSourceResize(e){this.resize(e.width,e.height,e._resolution,true)}ensureDepthStencilTexture(){this.depthStencilTexture||(this.depthStencilTexture=new Ce({width:this.width,height:this.height,resolution:this.resolution,format:"depth24plus-stencil8",autoGenerateMipmaps:false,antialias:false,mipLevelCount:1}))}resize(e,t,r=this.resolution,s=false){this.dirtyId++;this.colorTextures.forEach(((n,i)=>{s&&i===0||n.source.resize(e,t,r)}));this.depthStencilTexture&&this.depthStencilTexture.source.resize(e,t,r)}destroy(){this.colorTexture.source.off("resize",this.onSourceResize,this);this._managedColorTextures&&this.colorTextures.forEach((e=>{e.destroy()}));if(this.depthStencilTexture){this.depthStencilTexture.destroy();delete this.depthStencilTexture}}};Qs.defaultOptions={width:0,height:0,resolution:1,colorTextures:1,stencil:false,depth:false,antialias:false,isRoot:false};let Zs=Qs;"use strict";class RenderTargetSystem{constructor(e){this.rootViewPort=new Ee;this.viewport=new Ee;this.onRenderTargetChange=new ce("onRenderTargetChange");this.projectionMatrix=new et;this.defaultClearColor=[0,0,0,0];this._renderSurfaceToRenderTargetHash=new Map;this._gpuRenderTargetHash=Object.create(null);this._renderTargetStack=[];this._renderer=e;e.renderableGC.addManagedHash(this,"_gpuRenderTargetHash")}finishRenderPass(){this.adaptor.finishRenderPass(this.renderTarget)}
/**
   * called when the renderer starts to render a scene.
   * @param options
   * @param options.target - the render target to render to
   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
   * @param options.clearColor - the color to clear to
   * @param options.frame - the frame to render to
   */renderStart({target:e,clear:t,clearColor:r,frame:s}){this._renderTargetStack.length=0;this.push(e,t,r,s);this.rootViewPort.copyFrom(this.viewport);this.rootRenderTarget=this.renderTarget;this.renderingToScreen=isRenderingToScreen(this.rootRenderTarget);this.adaptor.prerender?.(this.rootRenderTarget)}postrender(){this.adaptor.postrender?.(this.rootRenderTarget)}
/**
   * Binding a render surface! This is the main function of the render target system.
   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.
   * Once bound all draw calls will be rendered to the render surface.
   *
   * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.
   * @param renderSurface - the render surface to bind
   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
   * @param clearColor - the color to clear to
   * @param frame - the frame to render to
   * @returns the render target that was bound
   */bind(e,t=true,r,s){const n=this.getRenderTarget(e);const i=this.renderTarget!==n;this.renderTarget=n;this.renderSurface=e;const o=this.getGpuRenderTarget(n);if(n.pixelWidth!==o.width||n.pixelHeight!==o.height){this.adaptor.resizeGpuRenderTarget(n);o.width=n.pixelWidth;o.height=n.pixelHeight}const a=n.colorTexture;const u=this.viewport;const c=a.pixelWidth;const l=a.pixelHeight;!s&&e instanceof Ae&&(s=e.frame);if(s){const e=a._resolution;u.x=s.x*e+.5|0;u.y=s.y*e+.5|0;u.width=s.width*e+.5|0;u.height=s.height*e+.5|0}else{u.x=0;u.y=0;u.width=c;u.height=l}calculateProjection(this.projectionMatrix,0,0,u.width/a.resolution,u.height/a.resolution,!n.isRoot);this.adaptor.startRenderPass(n,t,r,u);i&&this.onRenderTargetChange.emit(n);return n}clear(e,t=ue.ALL,r){if(t){e&&(e=this.getRenderTarget(e));this.adaptor.clear(e||this.renderTarget,t,r,this.viewport)}}contextChange(){this._gpuRenderTargetHash=Object.create(null)}
/**
   * Push a render surface to the renderer. This will bind the render surface to the renderer,
   * @param renderSurface - the render surface to push
   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
   * @param clearColor - the color to clear to
   * @param frame - the frame to use when rendering to the render surface
   */push(e,t=ue.ALL,r,s){const n=this.bind(e,t,r,s);this._renderTargetStack.push({renderTarget:n,frame:s});return n}pop(){this._renderTargetStack.pop();const e=this._renderTargetStack[this._renderTargetStack.length-1];this.bind(e.renderTarget,false,null,e.frame)}
/**
   * Gets the render target from the provide render surface. Eg if its a texture,
   * it will return the render target for the texture.
   * If its a render target, it will return the same render target.
   * @param renderSurface - the render surface to get the render target for
   * @returns the render target for the render surface
   */getRenderTarget(e){e.isTexture&&(e=e.source);return this._renderSurfaceToRenderTargetHash.get(e)??this._initRenderTarget(e)}
/**
   * Copies a render surface to another texture.
   *
   * NOTE:
   * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer
   *
   * The following is not valid:
   * @example
   * const canvas = document.createElement('canvas')
   * canvas.width = 200;
   * canvas.height = 200;
   *
   * const ctx = canvas2.getContext('2d')!
   * ctx.fillStyle = 'red'
   * ctx.fillRect(0, 0, 200, 200);
   *
   * const texture = RenderTexture.create({
   *   width: 200,
   *   height: 200,
   * })
   * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);
   *
   * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});
   *
   * The best way to copy a canvas is to create a texture from it. Then render with that.
   *
   * Parsing in a RenderTarget canvas context (with a 2d context)
   * @param sourceRenderSurfaceTexture - the render surface to copy from
   * @param destinationTexture - the texture to copy to
   * @param originSrc - the origin of the copy
   * @param originSrc.x - the x origin of the copy
   * @param originSrc.y - the y origin of the copy
   * @param size - the size of the copy
   * @param size.width - the width of the copy
   * @param size.height - the height of the copy
   * @param originDest - the destination origin (top left to paste from!)
   * @param originDest.x - the x origin of the paste
   * @param originDest.y - the y origin of the paste
   */copyToTexture(e,t,r,s,n){if(r.x<0){s.width+=r.x;n.x-=r.x;r.x=0}if(r.y<0){s.height+=r.y;n.y-=r.y;r.y=0}const{pixelWidth:i,pixelHeight:o}=e;s.width=Math.min(s.width,i-r.x);s.height=Math.min(s.height,o-r.y);return this.adaptor.copyToTexture(e,t,r,s,n)}ensureDepthStencil(){if(!this.renderTarget.stencil){this.renderTarget.stencil=true;this.adaptor.startRenderPass(this.renderTarget,false,null,this.viewport)}}destroy(){this._renderer=null;this._renderSurfaceToRenderTargetHash.forEach(((e,t)=>{e!==t&&e.destroy()}));this._renderSurfaceToRenderTargetHash.clear();this._gpuRenderTargetHash=Object.create(null)}_initRenderTarget(e){let t=null;Ht.test(e)&&(e=getCanvasTexture(e).source);if(e instanceof Zs)t=e;else if(e instanceof Ce){t=new Zs({colorTextures:[e]});Ht.test(e.source.resource)&&(t.isRoot=true);e.once("destroy",(()=>{t.destroy();this._renderSurfaceToRenderTargetHash.delete(e);const r=this._gpuRenderTargetHash[t.uid];if(r){this._gpuRenderTargetHash[t.uid]=null;this.adaptor.destroyGpuRenderTarget(r)}}))}this._renderSurfaceToRenderTargetHash.set(e,t);return t}getGpuRenderTarget(e){return this._gpuRenderTargetHash[e.uid]||(this._gpuRenderTargetHash[e.uid]=this.adaptor.initGpuRenderTarget(e))}resetState(){this.renderTarget=null;this.renderSurface=null}}"use strict";class GlRenderTargetSystem extends RenderTargetSystem{constructor(e){super(e);this.adaptor=new GlRenderTargetAdaptor;this.adaptor.init(e,this)}}GlRenderTargetSystem.extension={type:[X.WebGLSystem],name:"renderTarget"};"use strict";"use strict";function migrateFragmentFromV7toV8(e){e=e.replaceAll("texture2D","texture").replaceAll("gl_FragColor","finalColor").replaceAll("varying","in");e=`\n        out vec4 finalColor;\n    ${e}\n    `;return e}"use strict";const Js={float:1,vec2:2,vec3:3,vec4:4,int:1,ivec2:2,ivec3:3,ivec4:4,uint:1,uvec2:2,uvec3:3,uvec4:4,bool:1,bvec2:2,bvec3:3,bvec4:4,mat2:4,mat3:9,mat4:16,sampler2D:1};function mapSize(e){return Js[e]}"use strict";function mapWebGLBlendModesToPixi(e){const t={};t.normal=[e.ONE,e.ONE_MINUS_SRC_ALPHA];t.add=[e.ONE,e.ONE];t.multiply=[e.DST_COLOR,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA];t.screen=[e.ONE,e.ONE_MINUS_SRC_COLOR,e.ONE,e.ONE_MINUS_SRC_ALPHA];t.none=[0,0];t["normal-npm"]=[e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA];t["add-npm"]=[e.SRC_ALPHA,e.ONE,e.ONE,e.ONE];t["screen-npm"]=[e.SRC_ALPHA,e.ONE_MINUS_SRC_COLOR,e.ONE,e.ONE_MINUS_SRC_ALPHA];t.erase=[e.ZERO,e.ONE_MINUS_SRC_ALPHA];const r=!(e instanceof ve.get().getWebGLRenderingContext());if(r){t.min=[e.ONE,e.ONE,e.ONE,e.ONE,e.MIN,e.MIN];t.max=[e.ONE,e.ONE,e.ONE,e.ONE,e.MAX,e.MAX]}else{const r=e.getExtension("EXT_blend_minmax");if(r){t.min=[e.ONE,e.ONE,e.ONE,e.ONE,r.MIN_EXT,r.MIN_EXT];t.max=[e.ONE,e.ONE,e.ONE,e.ONE,r.MAX_EXT,r.MAX_EXT]}}return t}"use strict";const en=0;const tn=1;const rn=2;const sn=3;const nn=4;const on=5;const an=class _GlStateSystem{constructor(){this.gl=null;this.stateId=0;this.polygonOffset=0;this.blendMode="none";this._blendEq=false;this.map=[];this.map[en]=this.setBlend;this.map[tn]=this.setOffset;this.map[rn]=this.setCullFace;this.map[sn]=this.setDepthTest;this.map[nn]=this.setFrontFace;this.map[on]=this.setDepthMask;this.checks=[];this.defaultState=ot.for2d()}contextChange(e){this.gl=e;this.blendModesMap=mapWebGLBlendModesToPixi(e);this.resetState()}
/**
   * Sets the current state
   * @param {*} state - The state to set.
   */set(e){e||(e=this.defaultState);if(this.stateId!==e.data){let t=this.stateId^e.data;let r=0;while(t){t&1&&this.map[r].call(this,!!(e.data&1<<r));t>>=1;r++}this.stateId=e.data}for(let t=0;t<this.checks.length;t++)this.checks[t](this,e)}
/**
   * Sets the state, when previous state is unknown.
   * @param {*} state - The state to set
   */forceState(e){e||(e=this.defaultState);for(let t=0;t<this.map.length;t++)this.map[t].call(this,!!(e.data&1<<t));for(let t=0;t<this.checks.length;t++)this.checks[t](this,e);this.stateId=e.data}
/**
   * Sets whether to enable or disable blending.
   * @param value - Turn on or off WebGl blending.
   */setBlend(e){this._updateCheck(_GlStateSystem._checkBlendMode,e);this.gl[e?"enable":"disable"](this.gl.BLEND)}
/**
   * Sets whether to enable or disable polygon offset fill.
   * @param value - Turn on or off webgl polygon offset testing.
   */setOffset(e){this._updateCheck(_GlStateSystem._checkPolygonOffset,e);this.gl[e?"enable":"disable"](this.gl.POLYGON_OFFSET_FILL)}
/**
   * Sets whether to enable or disable depth test.
   * @param value - Turn on or off webgl depth testing.
   */setDepthTest(e){this.gl[e?"enable":"disable"](this.gl.DEPTH_TEST)}
/**
   * Sets whether to enable or disable depth mask.
   * @param value - Turn on or off webgl depth mask.
   */setDepthMask(e){this.gl.depthMask(e)}
/**
   * Sets whether to enable or disable cull face.
   * @param {boolean} value - Turn on or off webgl cull face.
   */setCullFace(e){this.gl[e?"enable":"disable"](this.gl.CULL_FACE)}
/**
   * Sets the gl front face.
   * @param {boolean} value - true is clockwise and false is counter-clockwise
   */setFrontFace(e){this.gl.frontFace(this.gl[e?"CW":"CCW"])}
/**
   * Sets the blend mode.
   * @param {number} value - The blend mode to set to.
   */setBlendMode(e){this.blendModesMap[e]||(e="normal");if(e===this.blendMode)return;this.blendMode=e;const t=this.blendModesMap[e];const r=this.gl;t.length===2?r.blendFunc(t[0],t[1]):r.blendFuncSeparate(t[0],t[1],t[2],t[3]);if(t.length===6){this._blendEq=true;r.blendEquationSeparate(t[4],t[5])}else if(this._blendEq){this._blendEq=false;r.blendEquationSeparate(r.FUNC_ADD,r.FUNC_ADD)}}
/**
   * Sets the polygon offset.
   * @param {number} value - the polygon offset
   * @param {number} scale - the polygon offset scale
   */setPolygonOffset(e,t){this.gl.polygonOffset(e,t)}resetState(){this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL,false);this.forceState(this.defaultState);this._blendEq=true;this.blendMode="";this.setBlendMode("normal")}
/**
   * Checks to see which updates should be checked based on which settings have been activated.
   *
   * For example, if blend is enabled then we should check the blend modes each time the state is changed
   * or if polygon fill is activated then we need to check if the polygon offset changes.
   * The idea is that we only check what we have too.
   * @param func - the checking function to add or remove
   * @param value - should the check function be added or removed.
   */_updateCheck(e,t){const r=this.checks.indexOf(e);t&&r===-1?this.checks.push(e):t||r===-1||this.checks.splice(r,1)}
/**
   * A private little wrapper function that we call to check the blend mode.
   * @param system - the System to perform the state check on
   * @param state - the state that the blendMode will pulled from
   */static _checkBlendMode(e,t){e.setBlendMode(t.blendMode)}
/**
   * A private little wrapper function that we call to check the polygon offset.
   * @param system - the System to perform the state check on
   * @param state - the state that the blendMode will pulled from
   */static _checkPolygonOffset(e,t){e.setPolygonOffset(1,t.polygonOffset)}destroy(){this.gl=null;this.checks.length=0}};an.extension={type:[X.WebGLSystem],name:"state"};let un=an;"use strict";class GlTexture{constructor(e){this.target=Hs.TEXTURE_2D;this.texture=e;this.width=-1;this.height=-1;this.type=Ws.UNSIGNED_BYTE;this.internalFormat=Ns.RGBA;this.format=Ns.RGBA;this.samplerType=0}}"use strict";const cn={id:"buffer",upload(e,t,r){t.width===e.width||t.height===e.height?r.texSubImage2D(r.TEXTURE_2D,0,0,0,e.width,e.height,t.format,t.type,e.resource):r.texImage2D(t.target,0,t.internalFormat,e.width,e.height,0,t.format,t.type,e.resource);t.width=e.width;t.height=e.height}};"use strict";const ln={"bc1-rgba-unorm":true,"bc1-rgba-unorm-srgb":true,"bc2-rgba-unorm":true,"bc2-rgba-unorm-srgb":true,"bc3-rgba-unorm":true,"bc3-rgba-unorm-srgb":true,"bc4-r-unorm":true,"bc4-r-snorm":true,"bc5-rg-unorm":true,"bc5-rg-snorm":true,"bc6h-rgb-ufloat":true,"bc6h-rgb-float":true,"bc7-rgba-unorm":true,"bc7-rgba-unorm-srgb":true,"etc2-rgb8unorm":true,"etc2-rgb8unorm-srgb":true,"etc2-rgb8a1unorm":true,"etc2-rgb8a1unorm-srgb":true,"etc2-rgba8unorm":true,"etc2-rgba8unorm-srgb":true,"eac-r11unorm":true,"eac-r11snorm":true,"eac-rg11unorm":true,"eac-rg11snorm":true,"astc-4x4-unorm":true,"astc-4x4-unorm-srgb":true,"astc-5x4-unorm":true,"astc-5x4-unorm-srgb":true,"astc-5x5-unorm":true,"astc-5x5-unorm-srgb":true,"astc-6x5-unorm":true,"astc-6x5-unorm-srgb":true,"astc-6x6-unorm":true,"astc-6x6-unorm-srgb":true,"astc-8x5-unorm":true,"astc-8x5-unorm-srgb":true,"astc-8x6-unorm":true,"astc-8x6-unorm-srgb":true,"astc-8x8-unorm":true,"astc-8x8-unorm-srgb":true,"astc-10x5-unorm":true,"astc-10x5-unorm-srgb":true,"astc-10x6-unorm":true,"astc-10x6-unorm-srgb":true,"astc-10x8-unorm":true,"astc-10x8-unorm-srgb":true,"astc-10x10-unorm":true,"astc-10x10-unorm-srgb":true,"astc-12x10-unorm":true,"astc-12x10-unorm-srgb":true,"astc-12x12-unorm":true,"astc-12x12-unorm-srgb":true};const dn={id:"compressed",upload(e,t,r){r.pixelStorei(r.UNPACK_ALIGNMENT,4);let s=e.pixelWidth;let n=e.pixelHeight;const i=!!ln[e.format];for(let o=0;o<e.resource.length;o++){const a=e.resource[o];i?r.compressedTexImage2D(r.TEXTURE_2D,o,t.internalFormat,s,n,0,a):r.texImage2D(r.TEXTURE_2D,o,t.internalFormat,s,n,0,t.format,t.type,a);s=Math.max(s>>1,1);n=Math.max(n>>1,1)}}};"use strict";const hn={id:"image",upload(e,t,r,s){const n=t.width;const i=t.height;const o=e.pixelWidth;const a=e.pixelHeight;const u=e.resourceWidth;const c=e.resourceHeight;if(u<o||c<a){n===o&&i===a||r.texImage2D(t.target,0,t.internalFormat,o,a,0,t.format,t.type,null);s===2?r.texSubImage2D(r.TEXTURE_2D,0,0,0,u,c,t.format,t.type,e.resource):r.texSubImage2D(r.TEXTURE_2D,0,0,0,t.format,t.type,e.resource)}else n===o&&i===a?r.texSubImage2D(r.TEXTURE_2D,0,0,0,t.format,t.type,e.resource):s===2?r.texImage2D(t.target,0,t.internalFormat,o,a,0,t.format,t.type,e.resource):r.texImage2D(t.target,0,t.internalFormat,t.format,t.type,e.resource);t.width=o;t.height=a}};"use strict";const pn={id:"video",upload(e,t,r,s){e.isValid?hn.upload(e,t,r,s):r.texImage2D(t.target,0,t.internalFormat,1,1,0,t.format,t.type,null)}};"use strict";const fn={linear:9729,nearest:9728};const mn={linear:{linear:9987,nearest:9985},nearest:{linear:9986,nearest:9984}};const gn={"clamp-to-edge":33071,repeat:10497,"mirror-repeat":33648};const _n={never:512,less:513,equal:514,"less-equal":515,greater:516,"not-equal":517,"greater-equal":518,always:519};"use strict";function applyStyleParams(e,t,r,s,n,i,o,a){const u=i;if(!a||e.addressModeU!=="repeat"||e.addressModeV!=="repeat"||e.addressModeW!=="repeat"){const r=gn[o?"clamp-to-edge":e.addressModeU];const s=gn[o?"clamp-to-edge":e.addressModeV];const i=gn[o?"clamp-to-edge":e.addressModeW];t[n](u,t.TEXTURE_WRAP_S,r);t[n](u,t.TEXTURE_WRAP_T,s);t.TEXTURE_WRAP_R&&t[n](u,t.TEXTURE_WRAP_R,i)}a&&e.magFilter==="linear"||t[n](u,t.TEXTURE_MAG_FILTER,fn[e.magFilter]);if(r){if(!a||e.mipmapFilter!=="linear"){const r=mn[e.minFilter][e.mipmapFilter];t[n](u,t.TEXTURE_MIN_FILTER,r)}}else t[n](u,t.TEXTURE_MIN_FILTER,fn[e.minFilter]);if(s&&e.maxAnisotropy>1){const r=Math.min(e.maxAnisotropy,t.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT));t[n](u,s.TEXTURE_MAX_ANISOTROPY_EXT,r)}e.compare&&t[n](u,t.TEXTURE_COMPARE_FUNC,_n[e.compare])}"use strict";function mapFormatToGlFormat(e){return{r8unorm:e.RED,r8snorm:e.RED,r8uint:e.RED,r8sint:e.RED,r16uint:e.RED,r16sint:e.RED,r16float:e.RED,rg8unorm:e.RG,rg8snorm:e.RG,rg8uint:e.RG,rg8sint:e.RG,r32uint:e.RED,r32sint:e.RED,r32float:e.RED,rg16uint:e.RG,rg16sint:e.RG,rg16float:e.RG,rgba8unorm:e.RGBA,"rgba8unorm-srgb":e.RGBA,rgba8snorm:e.RGBA,rgba8uint:e.RGBA,rgba8sint:e.RGBA,bgra8unorm:e.RGBA,"bgra8unorm-srgb":e.RGBA,rgb9e5ufloat:e.RGB,rgb10a2unorm:e.RGBA,rg11b10ufloat:e.RGB,rg32uint:e.RG,rg32sint:e.RG,rg32float:e.RG,rgba16uint:e.RGBA,rgba16sint:e.RGBA,rgba16float:e.RGBA,rgba32uint:e.RGBA,rgba32sint:e.RGBA,rgba32float:e.RGBA,stencil8:e.STENCIL_INDEX8,depth16unorm:e.DEPTH_COMPONENT,depth24plus:e.DEPTH_COMPONENT,"depth24plus-stencil8":e.DEPTH_STENCIL,depth32float:e.DEPTH_COMPONENT,"depth32float-stencil8":e.DEPTH_STENCIL}}"use strict";function mapFormatToGlInternalFormat(e,t){let r={};let s=e.RGBA;if(e instanceof ve.get().getWebGLRenderingContext())t.srgb&&(r={"rgba8unorm-srgb":t.srgb.SRGB8_ALPHA8_EXT,"bgra8unorm-srgb":t.srgb.SRGB8_ALPHA8_EXT});else{r={"rgba8unorm-srgb":e.SRGB8_ALPHA8,"bgra8unorm-srgb":e.SRGB8_ALPHA8};s=e.RGBA8}return{r8unorm:e.R8,r8snorm:e.R8_SNORM,r8uint:e.R8UI,r8sint:e.R8I,r16uint:e.R16UI,r16sint:e.R16I,r16float:e.R16F,rg8unorm:e.RG8,rg8snorm:e.RG8_SNORM,rg8uint:e.RG8UI,rg8sint:e.RG8I,r32uint:e.R32UI,r32sint:e.R32I,r32float:e.R32F,rg16uint:e.RG16UI,rg16sint:e.RG16I,rg16float:e.RG16F,rgba8unorm:e.RGBA,...r,rgba8snorm:e.RGBA8_SNORM,rgba8uint:e.RGBA8UI,rgba8sint:e.RGBA8I,bgra8unorm:s,rgb9e5ufloat:e.RGB9_E5,rgb10a2unorm:e.RGB10_A2,rg11b10ufloat:e.R11F_G11F_B10F,rg32uint:e.RG32UI,rg32sint:e.RG32I,rg32float:e.RG32F,rgba16uint:e.RGBA16UI,rgba16sint:e.RGBA16I,rgba16float:e.RGBA16F,rgba32uint:e.RGBA32UI,rgba32sint:e.RGBA32I,rgba32float:e.RGBA32F,stencil8:e.STENCIL_INDEX8,depth16unorm:e.DEPTH_COMPONENT16,depth24plus:e.DEPTH_COMPONENT24,"depth24plus-stencil8":e.DEPTH24_STENCIL8,depth32float:e.DEPTH_COMPONENT32F,"depth32float-stencil8":e.DEPTH32F_STENCIL8,...t.s3tc?{"bc1-rgba-unorm":t.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,"bc2-rgba-unorm":t.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,"bc3-rgba-unorm":t.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT}:{},...t.s3tc_sRGB?{"bc1-rgba-unorm-srgb":t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,"bc2-rgba-unorm-srgb":t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,"bc3-rgba-unorm-srgb":t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}:{},...t.rgtc?{"bc4-r-unorm":t.rgtc.COMPRESSED_RED_RGTC1_EXT,"bc4-r-snorm":t.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,"bc5-rg-unorm":t.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,"bc5-rg-snorm":t.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}:{},...t.bptc?{"bc6h-rgb-float":t.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,"bc6h-rgb-ufloat":t.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,"bc7-rgba-unorm":t.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,"bc7-rgba-unorm-srgb":t.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT}:{},...t.etc?{"etc2-rgb8unorm":t.etc.COMPRESSED_RGB8_ETC2,"etc2-rgb8unorm-srgb":t.etc.COMPRESSED_SRGB8_ETC2,"etc2-rgb8a1unorm":t.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,"etc2-rgb8a1unorm-srgb":t.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,"etc2-rgba8unorm":t.etc.COMPRESSED_RGBA8_ETC2_EAC,"etc2-rgba8unorm-srgb":t.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,"eac-r11unorm":t.etc.COMPRESSED_R11_EAC,"eac-rg11unorm":t.etc.COMPRESSED_SIGNED_RG11_EAC}:{},...t.astc?{"astc-4x4-unorm":t.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,"astc-4x4-unorm-srgb":t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,"astc-5x4-unorm":t.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,"astc-5x4-unorm-srgb":t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,"astc-5x5-unorm":t.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,"astc-5x5-unorm-srgb":t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,"astc-6x5-unorm":t.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,"astc-6x5-unorm-srgb":t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,"astc-6x6-unorm":t.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,"astc-6x6-unorm-srgb":t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,"astc-8x5-unorm":t.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,"astc-8x5-unorm-srgb":t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,"astc-8x6-unorm":t.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,"astc-8x6-unorm-srgb":t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,"astc-8x8-unorm":t.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,"astc-8x8-unorm-srgb":t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,"astc-10x5-unorm":t.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,"astc-10x5-unorm-srgb":t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,"astc-10x6-unorm":t.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,"astc-10x6-unorm-srgb":t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,"astc-10x8-unorm":t.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,"astc-10x8-unorm-srgb":t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,"astc-10x10-unorm":t.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,"astc-10x10-unorm-srgb":t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,"astc-12x10-unorm":t.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,"astc-12x10-unorm-srgb":t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,"astc-12x12-unorm":t.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,"astc-12x12-unorm-srgb":t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR}:{}}}"use strict";function mapFormatToGlType(e){return{r8unorm:e.UNSIGNED_BYTE,r8snorm:e.BYTE,r8uint:e.UNSIGNED_BYTE,r8sint:e.BYTE,r16uint:e.UNSIGNED_SHORT,r16sint:e.SHORT,r16float:e.HALF_FLOAT,rg8unorm:e.UNSIGNED_BYTE,rg8snorm:e.BYTE,rg8uint:e.UNSIGNED_BYTE,rg8sint:e.BYTE,r32uint:e.UNSIGNED_INT,r32sint:e.INT,r32float:e.FLOAT,rg16uint:e.UNSIGNED_SHORT,rg16sint:e.SHORT,rg16float:e.HALF_FLOAT,rgba8unorm:e.UNSIGNED_BYTE,"rgba8unorm-srgb":e.UNSIGNED_BYTE,rgba8snorm:e.BYTE,rgba8uint:e.UNSIGNED_BYTE,rgba8sint:e.BYTE,bgra8unorm:e.UNSIGNED_BYTE,"bgra8unorm-srgb":e.UNSIGNED_BYTE,rgb9e5ufloat:e.UNSIGNED_INT_5_9_9_9_REV,rgb10a2unorm:e.UNSIGNED_INT_2_10_10_10_REV,rg11b10ufloat:e.UNSIGNED_INT_10F_11F_11F_REV,rg32uint:e.UNSIGNED_INT,rg32sint:e.INT,rg32float:e.FLOAT,rgba16uint:e.UNSIGNED_SHORT,rgba16sint:e.SHORT,rgba16float:e.HALF_FLOAT,rgba32uint:e.UNSIGNED_INT,rgba32sint:e.INT,rgba32float:e.FLOAT,stencil8:e.UNSIGNED_BYTE,depth16unorm:e.UNSIGNED_SHORT,depth24plus:e.UNSIGNED_INT,"depth24plus-stencil8":e.UNSIGNED_INT_24_8,depth32float:e.FLOAT,"depth32float-stencil8":e.FLOAT_32_UNSIGNED_INT_24_8_REV}}"use strict";function unpremultiplyAlpha$1(e){e instanceof Uint8ClampedArray&&(e=new Uint8Array(e.buffer));const t=e.length;for(let r=0;r<t;r+=4){const t=e[r+3];if(t!==0){const s=255.001/t;e[r]=e[r]*s+.5;e[r+1]=e[r+1]*s+.5;e[r+2]=e[r+2]*s+.5}}}"use strict";const xn=4;class GlTextureSystem{constructor(e){this.managedTextures=[];this._glTextures=Object.create(null);this._glSamplers=Object.create(null);this._boundTextures=[];this._activeTextureLocation=-1;this._boundSamplers=Object.create(null);this._uploads={image:hn,buffer:cn,video:pn,compressed:dn};this._premultiplyAlpha=false;this._useSeparateSamplers=false;this._renderer=e;this._renderer.renderableGC.addManagedHash(this,"_glTextures");this._renderer.renderableGC.addManagedHash(this,"_glSamplers")}contextChange(e){this._gl=e;if(!this._mapFormatToInternalFormat){this._mapFormatToInternalFormat=mapFormatToGlInternalFormat(e,this._renderer.context.extensions);this._mapFormatToType=mapFormatToGlType(e);this._mapFormatToFormat=mapFormatToGlFormat(e)}this._glTextures=Object.create(null);this._glSamplers=Object.create(null);this._boundSamplers=Object.create(null);this._premultiplyAlpha=false;for(let e=0;e<16;e++)this.bind(Ae.EMPTY,e)}initSource(e){this.bind(e)}bind(e,t=0){const r=e.source;if(e){this.bindSource(r,t);this._useSeparateSamplers&&this._bindSampler(r.style,t)}else{this.bindSource(null,t);this._useSeparateSamplers&&this._bindSampler(null,t)}}bindSource(e,t=0){const r=this._gl;e._touched=this._renderer.textureGC.count;if(this._boundTextures[t]!==e){this._boundTextures[t]=e;this._activateLocation(t);e||(e=Ae.EMPTY.source);const s=this.getGlSource(e);r.bindTexture(s.target,s.texture)}}_bindSampler(e,t=0){const r=this._gl;if(!e){this._boundSamplers[t]=null;r.bindSampler(t,null);return}const s=this._getGlSampler(e);if(this._boundSamplers[t]!==s){this._boundSamplers[t]=s;r.bindSampler(t,s)}}unbind(e){const t=e.source;const r=this._boundTextures;const s=this._gl;for(let e=0;e<r.length;e++)if(r[e]===t){this._activateLocation(e);const n=this.getGlSource(t);s.bindTexture(n.target,null);r[e]=null}}_activateLocation(e){if(this._activeTextureLocation!==e){this._activeTextureLocation=e;this._gl.activeTexture(this._gl.TEXTURE0+e)}}_initSource(e){const t=this._gl;const r=new GlTexture(t.createTexture());r.type=this._mapFormatToType[e.format];r.internalFormat=this._mapFormatToInternalFormat[e.format];r.format=this._mapFormatToFormat[e.format];if(e.autoGenerateMipmaps&&(this._renderer.context.supports.nonPowOf2mipmaps||e.isPowerOfTwo)){const t=Math.max(e.width,e.height);e.mipLevelCount=Math.floor(Math.log2(t))+1}this._glTextures[e.uid]=r;if(!this.managedTextures.includes(e)){e.on("update",this.onSourceUpdate,this);e.on("resize",this.onSourceUpdate,this);e.on("styleChange",this.onStyleChange,this);e.on("destroy",this.onSourceDestroy,this);e.on("unload",this.onSourceUnload,this);e.on("updateMipmaps",this.onUpdateMipmaps,this);this.managedTextures.push(e)}this.onSourceUpdate(e);this.updateStyle(e,false);return r}onStyleChange(e){this.updateStyle(e,false)}updateStyle(e,t){const r=this._gl;const s=this.getGlSource(e);r.bindTexture(r.TEXTURE_2D,s.texture);this._boundTextures[this._activeTextureLocation]=e;applyStyleParams(e.style,r,e.mipLevelCount>1,this._renderer.context.extensions.anisotropicFiltering,"texParameteri",r.TEXTURE_2D,!this._renderer.context.supports.nonPowOf2wrapping&&!e.isPowerOfTwo,t)}onSourceUnload(e){const t=this._glTextures[e.uid];if(t){this.unbind(e);this._glTextures[e.uid]=null;this._gl.deleteTexture(t.texture)}}onSourceUpdate(e){const t=this._gl;const r=this.getGlSource(e);t.bindTexture(t.TEXTURE_2D,r.texture);this._boundTextures[this._activeTextureLocation]=e;const s=e.alphaMode==="premultiply-alpha-on-upload";if(this._premultiplyAlpha!==s){this._premultiplyAlpha=s;t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,s)}this._uploads[e.uploadMethodId]?this._uploads[e.uploadMethodId].upload(e,r,t,this._renderer.context.webGLVersion):t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e.pixelWidth,e.pixelHeight,0,t.RGBA,t.UNSIGNED_BYTE,null);e.autoGenerateMipmaps&&e.mipLevelCount>1&&this.onUpdateMipmaps(e,false)}onUpdateMipmaps(e,t=true){t&&this.bindSource(e,0);const r=this.getGlSource(e);this._gl.generateMipmap(r.target)}onSourceDestroy(e){e.off("destroy",this.onSourceDestroy,this);e.off("update",this.onSourceUpdate,this);e.off("resize",this.onSourceUpdate,this);e.off("unload",this.onSourceUnload,this);e.off("styleChange",this.onStyleChange,this);e.off("updateMipmaps",this.onUpdateMipmaps,this);this.managedTextures.splice(this.managedTextures.indexOf(e),1);this.onSourceUnload(e)}_initSampler(e){const t=this._gl;const r=this._gl.createSampler();this._glSamplers[e._resourceId]=r;applyStyleParams(e,t,this._boundTextures[this._activeTextureLocation].mipLevelCount>1,this._renderer.context.extensions.anisotropicFiltering,"samplerParameteri",r,false,true);return this._glSamplers[e._resourceId]}_getGlSampler(e){return this._glSamplers[e._resourceId]||this._initSampler(e)}getGlSource(e){return this._glTextures[e.uid]||this._initSource(e)}generateCanvas(e){const{pixels:t,width:r,height:s}=this.getPixels(e);const n=ve.get().createCanvas();n.width=r;n.height=s;const i=n.getContext("2d");if(i){const e=i.createImageData(r,s);e.data.set(t);i.putImageData(e,0,0)}return n}getPixels(e){const t=e.source.resolution;const r=e.frame;const s=Math.max(Math.round(r.width*t),1);const n=Math.max(Math.round(r.height*t),1);const i=new Uint8Array(xn*s*n);const o=this._renderer;const a=o.renderTarget.getRenderTarget(e);const u=o.renderTarget.getGpuRenderTarget(a);const c=o.gl;c.bindFramebuffer(c.FRAMEBUFFER,u.resolveTargetFramebuffer);c.readPixels(Math.round(r.x*t),Math.round(r.y*t),s,n,c.RGBA,c.UNSIGNED_BYTE,i);false;return{pixels:new Uint8ClampedArray(i.buffer),width:s,height:n}}destroy(){this.managedTextures.slice().forEach((e=>this.onSourceDestroy(e)));this.managedTextures=null;this._renderer=null}resetState(){this._activeTextureLocation=-1;this._boundTextures.fill(Ae.EMPTY.source);this._boundSamplers=Object.create(null)}}GlTextureSystem.extension={type:[X.WebGLSystem],name:"texture"};"use strict";"use strict";class GlGraphicsAdaptor{init(){const e=new qe({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new et,type:"mat3x3<f32>"},uRound:{value:0,type:"f32"}});const t=at();const r=vt({name:"graphics",bits:[lt,dt(t),Pt,Gt]});this.shader=new $e({glProgram:r,resources:{localUniforms:e,batchSamplers:ht(t)}})}execute(e,t){const r=t.context;const s=r.customShader||this.shader;const n=e.renderer;const i=n.graphicsContext;const{batcher:o,instructions:a}=i.getContextRenderData(r);s.groups[0]=n.globalUniforms.bindGroup;n.state.set(e.state);n.shader.bind(s);n.geometry.bind(o.geometry,s.glProgram);const u=a.instructions;for(let e=0;e<a.instructionSize;e++){const t=u[e];if(t.size){for(let e=0;e<t.textures.count;e++)n.texture.bind(t.textures.textures[e],e);n.geometry.draw(t.topology,t.size,t.start)}}}destroy(){this.shader.destroy(true);this.shader=null}}GlGraphicsAdaptor.extension={type:[X.WebGLPipesAdaptor],name:"graphics"};"use strict";class GlMeshAdaptor{init(){const e=vt({name:"mesh",bits:[Pt,Is,Gt]});this._shader=new $e({glProgram:e,resources:{uTexture:Ae.EMPTY.source,textureUniforms:{uTextureMatrix:{type:"mat3x3<f32>",value:new et}}}})}execute(e,t){const r=e.renderer;let s=t._shader;if(s){if(!s.glProgram){Fe("Mesh shader has no glProgram",t.shader);return}}else{s=this._shader;const e=t.texture;const r=e.source;s.resources.uTexture=r;s.resources.uSampler=r.style;s.resources.textureUniforms.uniforms.uTextureMatrix=e.textureMatrix.mapCoord}s.groups[100]=r.globalUniforms.bindGroup;s.groups[101]=e.localUniformsBindGroup;r.encoder.draw({geometry:t._geometry,shader:s,state:t.state})}destroy(){this._shader.destroy(true);this._shader=null}}GlMeshAdaptor.extension={type:[X.WebGLPipesAdaptor],name:"mesh"};"use strict";class CustomRenderPipe{constructor(e){this._renderer=e}updateRenderable(){}destroyRenderable(){}validateRenderable(){return false}addRenderable(e,t){this._renderer.renderPipes.batch.break(t);t.add(e)}execute(e){e.isRenderable&&e.render(this._renderer)}destroy(){this._renderer=null}}CustomRenderPipe.extension={type:[X.WebGLPipes,X.WebGPUPipes,X.CanvasPipes],name:"customRender"};"use strict";function executeInstructions(e,t){const r=e.instructionSet;const s=r.instructions;for(let e=0;e<r.instructionSize;e++){const r=s[e];t[r.renderPipeId].execute(r)}}"use strict";const bn=new et;class RenderGroupPipe{constructor(e){this._renderer=e}addRenderGroup(e,t){e.isCachedAsTexture?this._addRenderableCacheAsTexture(e,t):this._addRenderableDirect(e,t)}execute(e){e.isRenderable&&(e.isCachedAsTexture?this._executeCacheAsTexture(e):this._executeDirect(e))}destroy(){this._renderer=null}_addRenderableDirect(e,t){this._renderer.renderPipes.batch.break(t);if(e._batchableRenderGroup){Bt.return(e._batchableRenderGroup);e._batchableRenderGroup=null}t.add(e)}_addRenderableCacheAsTexture(e,t){const r=e._batchableRenderGroup??(e._batchableRenderGroup=Bt.get(Vt));r.renderable=e.root;r.transform=e.root.relativeGroupTransform;r.texture=e.texture;r.bounds=e._textureBounds;t.add(e);this._renderer.renderPipes.batch.addToBatch(r,t)}_executeCacheAsTexture(e){if(e.textureNeedsUpdate){e.textureNeedsUpdate=false;const t=bn.identity().translate(-e._textureBounds.x,-e._textureBounds.y);this._renderer.renderTarget.push(e.texture,true,null,e.texture.frame);this._renderer.globalUniforms.push({worldTransformMatrix:t,worldColor:4294967295});executeInstructions(e,this._renderer.renderPipes);this._renderer.renderTarget.finishRenderPass();this._renderer.renderTarget.pop();this._renderer.globalUniforms.pop()}e._batchableRenderGroup._batcher.updateElement(e._batchableRenderGroup);e._batchableRenderGroup._batcher.geometry.buffers[0].update()}_executeDirect(e){this._renderer.globalUniforms.push({worldTransformMatrix:e.inverseParentTextureTransform,worldColor:e.worldColorAlpha});executeInstructions(e,this._renderer.renderPipes);this._renderer.globalUniforms.pop()}}RenderGroupPipe.extension={type:[X.WebGLPipes,X.WebGPUPipes,X.CanvasPipes],name:"renderGroup"};"use strict";function clearList(e,t){t||(t=0);for(let r=t;r<e.length;r++){if(!e[r])break;e[r]=null}}"use strict";const yn=new le;const Tn=pe|fe|me;function updateRenderGroupTransforms(e,t=false){updateRenderGroupTransform(e);const r=e.childrenToUpdate;const s=e.updateTick++;for(const t in r){const n=Number(t);const i=r[t];const o=i.list;const a=i.index;for(let t=0;t<a;t++){const r=o[t];r.parentRenderGroup===e&&r.relativeRenderGroupDepth===n&&updateTransformAndChildren(r,s,0)}clearList(o,a);i.index=0}if(t)for(let r=0;r<e.renderGroupChildren.length;r++)updateRenderGroupTransforms(e.renderGroupChildren[r],t)}function updateRenderGroupTransform(e){const t=e.root;let r;if(e.renderGroupParent){const s=e.renderGroupParent;e.worldTransform.appendFrom(t.relativeGroupTransform,s.worldTransform);e.worldColor=ge(t.groupColor,s.worldColor);r=t.groupAlpha*s.worldAlpha}else{e.worldTransform.copyFrom(t.localTransform);e.worldColor=t.localColor;r=t.localAlpha}r=r<0?0:r>1?1:r;e.worldAlpha=r;e.worldColorAlpha=e.worldColor+(r*255<<24)}function updateTransformAndChildren(e,t,r){if(t===e.updateTick)return;e.updateTick=t;e.didChange=false;const s=e.localTransform;e.updateLocalTransform();const n=e.parent;if(n&&!n.renderGroup){r|=e._updateFlags;e.relativeGroupTransform.appendFrom(s,n.relativeGroupTransform);r&Tn&&updateColorBlendVisibility(e,n,r)}else{r=e._updateFlags;e.relativeGroupTransform.copyFrom(s);r&Tn&&updateColorBlendVisibility(e,yn,r)}if(!e.renderGroup){const s=e.children;const n=s.length;for(let e=0;e<n;e++)updateTransformAndChildren(s[e],t,r);const i=e.parentRenderGroup;const o=e;o.renderPipeId&&!i.structureDidChange&&i.updateRenderable(o)}}function updateColorBlendVisibility(e,t,r){if(r&fe){e.groupColor=ge(e.localColor,t.groupColor);let r=e.localAlpha*t.groupAlpha;r=r<0?0:r>1?1:r;e.groupAlpha=r;e.groupColorAlpha=e.groupColor+(r*255<<24)}r&me&&(e.groupBlendMode=e.localBlendMode==="inherit"?t.groupBlendMode:e.localBlendMode);r&pe&&(e.globalDisplayStatus=e.localDisplayStatus&t.globalDisplayStatus);e._updateFlags=0}"use strict";function validateRenderables(e,t){const{list:r,index:s}=e.childrenRenderablesToUpdate;let n=false;for(let e=0;e<s;e++){const s=r[e];const i=s;const o=t[i.renderPipeId];n=o.validateRenderable(s);if(n)break}e.structureDidChange=n;return n}"use strict";const Sn=new et;class RenderGroupSystem{constructor(e){this._renderer=e}render({container:e,transform:t}){const r=e.parent;const s=e.renderGroup.renderGroupParent;e.parent=null;e.renderGroup.renderGroupParent=null;const n=this._renderer;let i=Sn;if(t){i=i.copyFrom(e.renderGroup.localTransform);e.renderGroup.localTransform.copyFrom(t)}const o=n.renderPipes;this._updateCachedRenderGroups(e.renderGroup,null);this._updateRenderGroups(e.renderGroup);n.globalUniforms.start({worldTransformMatrix:t?e.renderGroup.localTransform:e.renderGroup.worldTransform,worldColor:e.renderGroup.worldColorAlpha});executeInstructions(e.renderGroup,o);o.uniformBatch&&o.uniformBatch.renderEnd();t&&e.renderGroup.localTransform.copyFrom(i);e.parent=r;e.renderGroup.renderGroupParent=s}destroy(){this._renderer=null}_updateCachedRenderGroups(e,t){if(e.isCachedAsTexture){if(!e.updateCacheTexture)return;t=e}e._parentCacheAsTextureRenderGroup=t;for(let r=e.renderGroupChildren.length-1;r>=0;r--)this._updateCachedRenderGroups(e.renderGroupChildren[r],t);e.invalidateMatrices();if(e.isCachedAsTexture){if(e.textureNeedsUpdate){const t=e.root.getLocalBounds();t.ceil();const r=e.texture;e.texture&&Ze.returnTexture(e.texture);const s=this._renderer;const n=e.textureOptions.resolution||s.view.resolution;const i=e.textureOptions.antialias??s.view.antialias;e.texture=Ze.getOptimalTexture(t.width,t.height,n,i);e._textureBounds||(e._textureBounds=new ze);e._textureBounds.copyFrom(t);r!==e.texture&&e.renderGroupParent&&(e.renderGroupParent.structureDidChange=true)}}else if(e.texture){Ze.returnTexture(e.texture);e.texture=null}}_updateRenderGroups(e){const t=this._renderer;const r=t.renderPipes;e.runOnRender(t);e.instructionSet.renderPipes=r;e.structureDidChange?clearList(e.childrenRenderablesToUpdate.list,0):validateRenderables(e,r);updateRenderGroupTransforms(e);if(e.structureDidChange){e.structureDidChange=false;this._buildInstructions(e,t)}else this._updateRenderables(e);e.childrenRenderablesToUpdate.index=0;t.renderPipes.batch.upload(e.instructionSet);if(!e.isCachedAsTexture||e.textureNeedsUpdate)for(let t=0;t<e.renderGroupChildren.length;t++)this._updateRenderGroups(e.renderGroupChildren[t])}_updateRenderables(e){const{list:t,index:r}=e.childrenRenderablesToUpdate;for(let s=0;s<r;s++){const r=t[s];r.didViewUpdate&&e.updateRenderable(r)}clearList(t,r)}_buildInstructions(e,t){const r=e.root;const s=e.instructionSet;s.reset();const n=t.renderPipes?t:t.batch.renderer;const i=n.renderPipes;i.batch.buildStart(s);i.blendMode.buildStart();i.colorMask.buildStart();r.sortableChildren&&r.sortChildren();r.collectRenderablesWithEffects(s,n,null);i.batch.buildEnd(s);i.blendMode.buildEnd(s)}}RenderGroupSystem.extension={type:[X.WebGLSystem,X.WebGPUSystem,X.CanvasSystem],name:"renderGroup"};"use strict";class SpritePipe{constructor(e){this._gpuSpriteHash=Object.create(null);this._destroyRenderableBound=this.destroyRenderable.bind(this);this._renderer=e;this._renderer.renderableGC.addManagedHash(this,"_gpuSpriteHash")}addRenderable(e,t){const r=this._getGpuSprite(e);e.didViewUpdate&&this._updateBatchableSprite(e,r);this._renderer.renderPipes.batch.addToBatch(r,t)}updateRenderable(e){const t=this._gpuSpriteHash[e.uid];e.didViewUpdate&&this._updateBatchableSprite(e,t);t._batcher.updateElement(t)}validateRenderable(e){const t=this._getGpuSprite(e);return!t._batcher.checkAndUpdateTexture(t,e._texture)}destroyRenderable(e){const t=this._gpuSpriteHash[e.uid];Bt.return(t);this._gpuSpriteHash[e.uid]=null;e.off("destroyed",this._destroyRenderableBound)}_updateBatchableSprite(e,t){t.bounds=e.visualBounds;t.texture=e._texture}_getGpuSprite(e){return this._gpuSpriteHash[e.uid]||this._initGPUSprite(e)}_initGPUSprite(e){const t=Bt.get(Vt);t.renderable=e;t.transform=e.groupTransform;t.texture=e._texture;t.bounds=e.visualBounds;t.roundPixels=this._renderer._roundPixels|e._roundPixels;this._gpuSpriteHash[e.uid]=t;e.on("destroyed",this._destroyRenderableBound);return t}destroy(){for(const e in this._gpuSpriteHash)Bt.return(this._gpuSpriteHash[e]);this._gpuSpriteHash=null;this._renderer=null}}SpritePipe.extension={type:[X.WebGLPipes,X.WebGPUPipes,X.CanvasPipes],name:"sprite"};"use strict";const vn=class _BackgroundSystem{constructor(){this.clearBeforeRender=true;this._backgroundColor=new je(0);this.color=this._backgroundColor;this.alpha=1}
/**
   * initiates the background system
   * @param options - the options for the background colors
   */init(e){e={..._BackgroundSystem.defaultOptions,...e};this.clearBeforeRender=e.clearBeforeRender;this.color=e.background||e.backgroundColor||this._backgroundColor;this.alpha=e.backgroundAlpha;this._backgroundColor.setAlpha(e.backgroundAlpha)}get color(){return this._backgroundColor}set color(e){this._backgroundColor.setValue(e)}get alpha(){return this._backgroundColor.alpha}set alpha(e){this._backgroundColor.setAlpha(e)}get colorRgba(){return this._backgroundColor.toArray()}destroy(){}};vn.extension={type:[X.WebGLSystem,X.WebGPUSystem,X.CanvasSystem],name:"background",priority:0};vn.defaultOptions={backgroundAlpha:1,backgroundColor:0,clearBeforeRender:true};let Gn=vn;"use strict";const En={};Y.handle(X.BlendMode,(e=>{if(!e.name)throw new Error("BlendMode extension must have a name property");En[e.name]=e.ref}),(e=>{delete En[e.name]}));class BlendModePipe{constructor(e){this._isAdvanced=false;this._filterHash=Object.create(null);this._renderer=e;this._renderer.runners.prerender.add(this)}prerender(){this._activeBlendMode="normal";this._isAdvanced=false}
/**
   * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.
   * @param renderable - The renderable we are adding to the instruction set
   * @param blendMode - The blend mode of the renderable
   * @param instructionSet - The instruction set we are adding to
   */setBlendMode(e,t,r){if(this._activeBlendMode!==t){this._activeBlendMode=t;this._isAdvanced&&this._endAdvancedBlendMode(r);this._isAdvanced=!!En[t];if(this._isAdvanced){this._beginAdvancedBlendMode(r);this._renderableList.push(e)}}else this._isAdvanced&&this._renderableList.push(e)}_beginAdvancedBlendMode(e){this._renderer.renderPipes.batch.break(e);const t=this._activeBlendMode;if(!En[t]){Fe(`Unable to assign BlendMode: '${t}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);return}let r=this._filterHash[t];if(!r){r=this._filterHash[t]=new he;r.filters=[new En[t]]}const s={renderPipeId:"filter",action:"pushFilter",renderables:[],filterEffect:r,canBundle:false};this._renderableList=s.renderables;e.add(s)}_endAdvancedBlendMode(e){this._renderableList=null;this._renderer.renderPipes.batch.break(e);e.add({renderPipeId:"filter",action:"popFilter",canBundle:false})}buildStart(){this._isAdvanced=false}
/**
   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode
   * active, we add the final render instructions added to the instruction set
   * @param instructionSet - The instruction set we are adding to
   * @internal
   * @ignore
   */buildEnd(e){this._isAdvanced&&this._endAdvancedBlendMode(e)}destroy(){this._renderer=null;this._renderableList=null;for(const e in this._filterHash)this._filterHash[e].destroy();this._filterHash=null}}BlendModePipe.extension={type:[X.WebGLPipes,X.WebGPUPipes,X.CanvasPipes],name:"blendMode"};"use strict";const An={png:"image/png",jpg:"image/jpeg",webp:"image/webp"};const Pn=class _ExtractSystem{
/** @param renderer - The renderer this System works for. */
constructor(e){this._renderer=e}_normalizeOptions(e,t={}){return e instanceof le||e instanceof Ae?{target:e,...t}:{...t,...e}}
/**
   * Will return a HTML Image of the target
   * @param options - The options for creating the image, or the target to extract
   * @returns - HTML Image of the target
   */async image(e){const t=new Image;t.src=await this.base64(e);return t}
/**
   * Will return a base64 encoded string of this target. It works by calling
   * `Extract.canvas` and then running toDataURL on that.
   * @param options - The options for creating the image, or the target to extract
   */async base64(e){e=this._normalizeOptions(e,_ExtractSystem.defaultImageOptions);const{format:t,quality:r}=e;const s=this.canvas(e);if(s.toBlob!==void 0)return new Promise(((e,n)=>{s.toBlob((t=>{if(!t){n(new Error("ICanvas.toBlob failed!"));return}const r=new FileReader;r.onload=()=>e(r.result);r.onerror=n;r.readAsDataURL(t)}),An[t],r)}));if(s.toDataURL!==void 0)return s.toDataURL(An[t],r);if(s.convertToBlob!==void 0){const e=await s.convertToBlob({type:An[t],quality:r});return new Promise(((t,r)=>{const s=new FileReader;s.onload=()=>t(s.result);s.onerror=r;s.readAsDataURL(e)}))}throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")}
/**
   * Creates a Canvas element, renders this target to it and then returns it.
   * @param options - The options for creating the canvas, or the target to extract
   * @returns - A Canvas element with the texture rendered on.
   */canvas(e){e=this._normalizeOptions(e);const t=e.target;const r=this._renderer;if(t instanceof Ae)return r.texture.generateCanvas(t);const s=r.textureGenerator.generateTexture(e);const n=r.texture.generateCanvas(s);s.destroy(true);return n}
/**
   * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
   * order, with integer values between 0 and 255 (included).
   * @param options - The options for extracting the image, or the target to extract
   * @returns - One-dimensional array containing the pixel data of the entire texture
   */pixels(e){e=this._normalizeOptions(e);const t=e.target;const r=this._renderer;const s=t instanceof Ae?t:r.textureGenerator.generateTexture(e);const n=r.texture.getPixels(s);t instanceof le&&s.destroy(true);return n}
/**
   * Will return a texture of the target
   * @param options - The options for creating the texture, or the target to extract
   * @returns - A texture of the target
   */texture(e){e=this._normalizeOptions(e);return e.target instanceof Ae?e.target:this._renderer.textureGenerator.generateTexture(e)}
/**
   * Will extract a HTMLImage of the target and download it
   * @param options - The options for downloading and extracting the image, or the target to extract
   */download(e){e=this._normalizeOptions(e);const t=this.canvas(e);const r=document.createElement("a");r.download=e.filename??"image.png";r.href=t.toDataURL("image/png");document.body.appendChild(r);r.click();document.body.removeChild(r)}
/**
   * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.
   * @param options - The options for logging the image, or the target to log
   */log(e){const t=e.width??200;e=this._normalizeOptions(e);const r=this.canvas(e);const s=r.toDataURL();console.log(`[Pixi Texture] ${r.width}px ${r.height}px`);const n=["font-size: 1px;",`padding: ${t}px 300px;`,`background: url(${s}) no-repeat;`,"background-size: contain;"].join(" ");console.log("%c ",n)}destroy(){this._renderer=null}};Pn.extension={type:[X.WebGLSystem,X.WebGPUSystem],name:"extract"};Pn.defaultImageOptions={format:"png",quality:1};let Cn=Pn;"use strict";class RenderTexture extends Ae{static create(e){return new RenderTexture({source:new Ce(e)})}
/**
   * Resizes the render texture.
   * @param width - The new width of the render texture.
   * @param height - The new height of the render texture.
   * @param resolution - The new resolution of the render texture.
   * @returns This texture.
   */resize(e,t,r){this.source.resize(e,t,r);return this}}"use strict";const Rn=new Ee;const Bn=new ze;const wn=[0,0,0,0];class GenerateTextureSystem{constructor(e){this._renderer=e}
/**
   * A Useful function that returns a texture of the display object that can then be used to create sprites
   * This can be quite useful if your container is complicated and needs to be reused multiple times.
   * @param {GenerateTextureOptions | Container} options - Generate texture options.
   * @param {Container} [options.container] - If not given, the renderer's resolution is used.
   * @param {Rectangle} options.region - The region of the container, that shall be rendered,
   * @param {number} [options.resolution] - The resolution of the texture being generated.
   *        if no region is specified, defaults to the local bounds of the container.
   * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.
   * @returns a shiny new texture of the container passed in
   */generateTexture(e){e instanceof le&&(e={target:e,frame:void 0,textureSourceOptions:{},resolution:void 0});const t=e.resolution||this._renderer.resolution;const r=e.antialias||this._renderer.view.antialias;const s=e.target;let n=e.clearColor;if(n){const e=Array.isArray(n)&&n.length===4;n=e?n:je.shared.setValue(n).toArray()}else n=wn;const i=e.frame?.copyTo(Rn)||_e(s,Bn).rectangle;i.width=Math.max(i.width,1/t)|0;i.height=Math.max(i.height,1/t)|0;const o=RenderTexture.create({...e.textureSourceOptions,width:i.width,height:i.height,resolution:t,antialias:r});const a=et.shared.translate(-i.x,-i.y);this._renderer.render({container:s,transform:a,target:o,clearColor:n});o.source.updateMipmaps();return o}destroy(){this._renderer=null}}GenerateTextureSystem.extension={type:[X.WebGLSystem,X.WebGPUSystem],name:"textureGenerator"};"use strict";class GlobalUniformSystem{constructor(e){this._stackIndex=0;this._globalUniformDataStack=[];this._uniformsPool=[];this._activeUniforms=[];this._bindGroupPool=[];this._activeBindGroups=[];this._renderer=e}reset(){this._stackIndex=0;for(let e=0;e<this._activeUniforms.length;e++)this._uniformsPool.push(this._activeUniforms[e]);for(let e=0;e<this._activeBindGroups.length;e++)this._bindGroupPool.push(this._activeBindGroups[e]);this._activeUniforms.length=0;this._activeBindGroups.length=0}start(e){this.reset();this.push(e)}bind({size:e,projectionMatrix:t,worldTransformMatrix:r,worldColor:s,offset:n}){const i=this._renderer.renderTarget.renderTarget;const o=this._stackIndex?this._globalUniformDataStack[this._stackIndex-1]:{projectionData:i,worldTransformMatrix:new et,worldColor:4294967295,offset:new rt};const a={projectionMatrix:t||this._renderer.renderTarget.projectionMatrix,resolution:e||i.size,worldTransformMatrix:r||o.worldTransformMatrix,worldColor:s||o.worldColor,offset:n||o.offset,bindGroup:null};const u=this._uniformsPool.pop()||this._createUniforms();this._activeUniforms.push(u);const c=u.uniforms;c.uProjectionMatrix=a.projectionMatrix;c.uResolution=a.resolution;c.uWorldTransformMatrix.copyFrom(a.worldTransformMatrix);c.uWorldTransformMatrix.tx-=a.offset.x;c.uWorldTransformMatrix.ty-=a.offset.y;Wt(a.worldColor,c.uWorldColorAlpha,0);u.update();let l;if(this._renderer.renderPipes.uniformBatch)l=this._renderer.renderPipes.uniformBatch.getUniformBindGroup(u,false);else{l=this._bindGroupPool.pop()||new jt;this._activeBindGroups.push(l);l.setResource(u,0)}a.bindGroup=l;this._currentGlobalUniformData=a}push(e){this.bind(e);this._globalUniformDataStack[this._stackIndex++]=this._currentGlobalUniformData}pop(){this._currentGlobalUniformData=this._globalUniformDataStack[--this._stackIndex-1];this._renderer.type===Je.WEBGL&&this._currentGlobalUniformData.bindGroup.resources[0].update()}get bindGroup(){return this._currentGlobalUniformData.bindGroup}get globalUniformData(){return this._currentGlobalUniformData}get uniformGroup(){return this._currentGlobalUniformData.bindGroup.resources[0]}_createUniforms(){const e=new qe({uProjectionMatrix:{value:new et,type:"mat3x3<f32>"},uWorldTransformMatrix:{value:new et,type:"mat3x3<f32>"},uWorldColorAlpha:{value:new Float32Array(4),type:"vec4<f32>"},uResolution:{value:[0,0],type:"vec2<f32>"}},{isStatic:true});return e}destroy(){this._renderer=null}}GlobalUniformSystem.extension={type:[X.WebGLSystem,X.WebGPUSystem,X.CanvasSystem],name:"globalUniforms"};"use strict";let Mn=1;class SchedulerSystem{constructor(){this._tasks=[];this._offset=0}init(){zt.system.add(this._update,this)}
/**
   * Schedules a repeating task.
   * @param func - The function to execute.
   * @param duration - The interval duration in milliseconds.
   * @param useOffset - this will spread out tasks so that they do not all run at the same time
   * @returns The unique identifier for the scheduled task.
   */repeat(e,t,r=true){const s=Mn++;let n=0;if(r){this._offset+=1e3;n=this._offset}this._tasks.push({func:e,duration:t,start:performance.now(),offset:n,last:performance.now(),repeat:true,id:s});return s}
/**
   * Cancels a scheduled task.
   * @param id - The unique identifier of the task to cancel.
   */cancel(e){for(let t=0;t<this._tasks.length;t++)if(this._tasks[t].id===e){this._tasks.splice(t,1);return}}_update(){const e=performance.now();for(let t=0;t<this._tasks.length;t++){const r=this._tasks[t];if(e-r.offset-r.last>=r.duration){const t=e-r.start;r.func(t);r.last=e}}}destroy(){zt.system.remove(this._update,this);this._tasks.length=0}}SchedulerSystem.extension={type:[X.WebGLSystem,X.WebGPUSystem,X.CanvasSystem],name:"scheduler",priority:0};"use strict";let Fn=false;function sayHello(e){if(!Fn){if(ve.get().getNavigator().userAgent.toLowerCase().indexOf("chrome")>-1){const t=[`%c  %c  %c  %c  %c PixiJS %c v${tr} (${e}) http://www.pixijs.com/\n\n`,"background: #E72264; padding:5px 0;","background: #6CA2EA; padding:5px 0;","background: #B5D33D; padding:5px 0;","background: #FED23F; padding:5px 0;","color: #FFFFFF; background: #E72264; padding:5px 0;","color: #E72264; background: #FFFFFF; padding:5px 0;"];globalThis.console.log(...t)}else globalThis.console&&globalThis.console.log(`PixiJS ${tr} - ${e} - http://www.pixijs.com/`);Fn=true}}"use strict";class HelloSystem{constructor(e){this._renderer=e}
/**
   * It all starts here! This initiates every system, passing in the options for any system by name.
   * @param options - the config for the renderer and all its systems
   */init(e){if(e.hello){let e=this._renderer.name;this._renderer.type===Je.WEBGL&&(e+=` ${this._renderer.context.webGLVersion}`);sayHello(e)}}}HelloSystem.extension={type:[X.WebGLSystem,X.WebGPUSystem,X.CanvasSystem],name:"hello",priority:-2};HelloSystem.defaultOptions={hello:false};"use strict";function cleanHash(e){let t=false;for(const r in e)if(e[r]==void 0){t=true;break}if(!t)return e;const r=Object.create(null);for(const t in e){const s=e[t];s&&(r[t]=s)}return r}function cleanArray(e){let t=0;for(let r=0;r<e.length;r++)e[r]==void 0?t++:e[r-t]=e[r];e.length-=t;return e}"use strict";let Un=0;const In=class _RenderableGCSystem{
/**
   * Creates a new RenderableGCSystem instance.
   * @param renderer - The renderer this garbage collection system works for
   */
constructor(e){this._managedRenderables=[];this._managedHashes=[];this._managedArrays=[];this._renderer=e}
/**
   * Initializes the garbage collection system with the provided options.
   * @param options - Configuration options for the renderer
   */init(e){e={..._RenderableGCSystem.defaultOptions,...e};this.maxUnusedTime=e.renderableGCMaxUnusedTime;this._frequency=e.renderableGCFrequency;this.enabled=e.renderableGCActive}
/**
   * Gets whether the garbage collection system is currently enabled.
   * @returns True if GC is enabled, false otherwise
   */get enabled(){return!!this._handler}set enabled(e){if(this.enabled!==e)if(e){this._handler=this._renderer.scheduler.repeat((()=>this.run()),this._frequency,false);this._hashHandler=this._renderer.scheduler.repeat((()=>{for(const e of this._managedHashes)e.context[e.hash]=cleanHash(e.context[e.hash])}),this._frequency);this._arrayHandler=this._renderer.scheduler.repeat((()=>{for(const e of this._managedArrays)cleanArray(e.context[e.hash])}),this._frequency)}else{this._renderer.scheduler.cancel(this._handler);this._renderer.scheduler.cancel(this._hashHandler);this._renderer.scheduler.cancel(this._arrayHandler)}}
/**
   * Adds a hash table to be managed by the garbage collector.
   * @param context - The object containing the hash table
   * @param hash - The property name of the hash table
   */addManagedHash(e,t){this._managedHashes.push({context:e,hash:t})}
/**
   * Adds an array to be managed by the garbage collector.
   * @param context - The object containing the array
   * @param hash - The property name of the array
   */addManagedArray(e,t){this._managedArrays.push({context:e,hash:t})}
/**
   * Updates the GC timestamp and tracking before rendering.
   * @param options - The render options
   * @param options.container - The container to render
   */prerender({container:e}){this._now=performance.now();e.renderGroup.gcTick=Un++;this._updateInstructionGCTick(e.renderGroup,e.renderGroup.gcTick)}
/**
   * Starts tracking a renderable for garbage collection.
   * @param renderable - The renderable to track
   */addRenderable(e){if(this.enabled){if(e._lastUsed===-1){this._managedRenderables.push(e);e.once("destroyed",this._removeRenderable,this)}e._lastUsed=this._now}}run(){const e=this._now;const t=this._managedRenderables;const r=this._renderer.renderPipes;let s=0;for(let n=0;n<t.length;n++){const i=t[n];if(i===null){s++;continue}const o=i.renderGroup??i.parentRenderGroup;const a=o?.instructionSet?.gcTick??-1;(o?.gcTick??0)===a&&(i._lastUsed=e);if(e-i._lastUsed>this.maxUnusedTime){if(!i.destroyed){const e=r;o&&(o.structureDidChange=true);e[i.renderPipeId].destroyRenderable(i)}i._lastUsed=-1;s++;i.off("destroyed",this._removeRenderable,this)}else t[n-s]=i}t.length-=s}destroy(){this.enabled=false;this._renderer=null;this._managedRenderables.length=0;this._managedHashes.length=0;this._managedArrays.length=0}
/**
   * Removes a renderable from being tracked when it's destroyed.
   * @param renderable - The renderable to stop tracking
   */_removeRenderable(e){const t=this._managedRenderables.indexOf(e);if(t>=0){e.off("destroyed",this._removeRenderable,this);this._managedRenderables[t]=null}}
/**
   * Updates the GC tick counter for a render group and its children.
   * @param renderGroup - The render group to update
   * @param gcTick - The new tick value
   */_updateInstructionGCTick(e,t){e.instructionSet.gcTick=t;for(const r of e.renderGroupChildren)this._updateInstructionGCTick(r,t)}};In.extension={type:[X.WebGLSystem,X.WebGPUSystem],name:"renderableGC",priority:0};In.defaultOptions={renderableGCActive:true,renderableGCMaxUnusedTime:6e4,renderableGCFrequency:3e4};let On=In;"use strict";const kn=class _TextureGCSystem{
/** @param renderer - The renderer this System works for. */
constructor(e){this._renderer=e;this.count=0;this.checkCount=0}init(e){e={..._TextureGCSystem.defaultOptions,...e};this.checkCountMax=e.textureGCCheckCountMax;this.maxIdle=e.textureGCAMaxIdle??e.textureGCMaxIdle;this.active=e.textureGCActive}postrender(){if(this._renderer.renderingToScreen){this.count++;if(this.active){this.checkCount++;if(this.checkCount>this.checkCountMax){this.checkCount=0;this.run()}}}}run(){const e=this._renderer.texture.managedTextures;for(let t=0;t<e.length;t++){const r=e[t];if(r.autoGarbageCollect&&r.resource&&r._touched>-1&&this.count-r._touched>this.maxIdle){r._touched=-1;r.unload()}}}destroy(){this._renderer=null}};kn.extension={type:[X.WebGLSystem,X.WebGPUSystem],name:"textureGC"};kn.defaultOptions={textureGCActive:true,
/**
   * @deprecated since 8.3.0
   * @see {@link TextureGCSystem.textureGCMaxIdle}
   */
textureGCAMaxIdle:null,textureGCMaxIdle:3600,textureGCCheckCountMax:600};let Ln=kn;"use strict";const Dn=class _ViewSystem{get autoDensity(){return this.texture.source.autoDensity}set autoDensity(e){this.texture.source.autoDensity=e}get resolution(){return this.texture.source._resolution}set resolution(e){this.texture.source.resize(this.texture.source.width,this.texture.source.height,e)}
/**
   * initiates the view system
   * @param options - the options for the view
   */init(e){e={..._ViewSystem.defaultOptions,...e};if(e.view){ye(Te,"ViewSystem.view has been renamed to ViewSystem.canvas");e.canvas=e.view}this.screen=new Ee(0,0,e.width,e.height);this.canvas=e.canvas||ve.get().createCanvas();this.antialias=!!e.antialias;this.texture=getCanvasTexture(this.canvas,e);this.renderTarget=new Zs({colorTextures:[this.texture],depth:!!e.depth,isRoot:true});this.texture.source.transparent=e.backgroundAlpha<1;this.resolution=e.resolution}
/**
   * Resizes the screen and canvas to the specified dimensions.
   * @param desiredScreenWidth - The new width of the screen.
   * @param desiredScreenHeight - The new height of the screen.
   * @param resolution
   */resize(e,t,r){this.texture.source.resize(e,t,r);this.screen.width=this.texture.frame.width;this.screen.height=this.texture.frame.height}
/**
   * Destroys this System and optionally removes the canvas from the dom.
   * @param {options | false} options - The options for destroying the view, or "false".
   * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.
   */destroy(e=false){const t=typeof e==="boolean"?e:!!e?.removeView;t&&this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas)}};Dn.extension={type:[X.WebGLSystem,X.WebGPUSystem,X.CanvasSystem],name:"view",priority:0};Dn.defaultOptions={width:800,height:600,autoDensity:false,antialias:false};let Nn=Dn;"use strict";const Hn=[Gn,GlobalUniformSystem,HelloSystem,Nn,RenderGroupSystem,Ln,GenerateTextureSystem,Cn,RendererInitHook,On,SchedulerSystem];const Vn=[BlendModePipe,Fs,SpritePipe,RenderGroupPipe,AlphaMaskPipe,StencilMaskPipe,ColorMaskPipe,CustomRenderPipe];"use strict";const Wn=[...Hn,Ot,Ks,Ds,GlBufferSystem,GlTextureSystem,GlRenderTargetSystem,GlGeometrySystem,kt,Lt,GlEncoderSystem,un,GlStencilSystem,GlColorMaskSystem];const jn=[...Vn];const zn=[GlBatchAdaptor,GlMeshAdaptor,GlGraphicsAdaptor];const Xn=[];const Yn=[];const Kn=[];Y.handleByNamedList(X.WebGLSystem,Xn);Y.handleByNamedList(X.WebGLPipes,Yn);Y.handleByNamedList(X.WebGLPipesAdaptor,Kn);Y.add(...Wn,...jn,...zn);class WebGLRenderer extends ae{constructor(){const e={name:"webgl",type:Je.WEBGL,systems:Xn,renderPipes:Yn,renderPipeAdaptors:Kn};super(e)}}var $n=Object.freeze(Object.defineProperty({__proto__:null,WebGLRenderer:WebGLRenderer},Symbol.toStringTag,{value:"Module"}));"use strict";class BindGroupSystem{constructor(e){this._hash=Object.create(null);this._renderer=e;this._renderer.renderableGC.addManagedHash(this,"_hash")}contextChange(e){this._gpu=e}getBindGroup(e,t,r){e._updateKey();const s=this._hash[e._key]||this._createBindGroup(e,t,r);return s}_createBindGroup(e,t,r){const s=this._gpu.device;const n=t.layout[r];const i=[];const o=this._renderer;for(const t in n){const r=e.resources[t]??e.resources[n[t]];let s;if(r._resourceType==="uniformGroup"){const e=r;o.ubo.updateUniformGroup(e);const t=e.buffer;s={buffer:o.buffer.getGPUBuffer(t),offset:0,size:t.descriptor.size}}else if(r._resourceType==="buffer"){const e=r;s={buffer:o.buffer.getGPUBuffer(e),offset:0,size:e.descriptor.size}}else if(r._resourceType==="bufferResource"){const e=r;s={buffer:o.buffer.getGPUBuffer(e.buffer),offset:e.offset,size:e.size}}else if(r._resourceType==="textureSampler"){const e=r;s=o.texture.getGpuSampler(e)}else if(r._resourceType==="textureSource"){const e=r;s=o.texture.getGpuSource(e).createView({})}i.push({binding:n[t],resource:s})}const a=o.shader.getProgramData(t).bindGroups[r];const u=s.createBindGroup({layout:a,entries:i});this._hash[e._key]=u;return u}destroy(){for(const e of Object.keys(this._hash))this._hash[e]=null;this._hash=null;this._renderer=null}}BindGroupSystem.extension={type:[X.WebGPUSystem],name:"bindGroup"};"use strict";class GpuBufferSystem{constructor(e){this._gpuBuffers=Object.create(null);this._managedBuffers=[];e.renderableGC.addManagedHash(this,"_gpuBuffers")}contextChange(e){this._gpu=e}getGPUBuffer(e){return this._gpuBuffers[e.uid]||this.createGPUBuffer(e)}updateBuffer(e){const t=this._gpuBuffers[e.uid]||this.createGPUBuffer(e);const r=e.data;if(e._updateID&&r){e._updateID=0;this._gpu.device.queue.writeBuffer(t,0,r.buffer,0,(e._updateSize||r.byteLength)+3&-4)}return t}destroyAll(){for(const e in this._gpuBuffers)this._gpuBuffers[e].destroy();this._gpuBuffers={}}createGPUBuffer(e){if(!this._gpuBuffers[e.uid]){e.on("update",this.updateBuffer,this);e.on("change",this.onBufferChange,this);e.on("destroy",this.onBufferDestroy,this);this._managedBuffers.push(e)}const t=this._gpu.device.createBuffer(e.descriptor);e._updateID=0;if(e.data){pt(e.data.buffer,t.getMappedRange());t.unmap()}this._gpuBuffers[e.uid]=t;return t}onBufferChange(e){const t=this._gpuBuffers[e.uid];t.destroy();e._updateID=0;this._gpuBuffers[e.uid]=this.createGPUBuffer(e)}
/**
   * Disposes buffer
   * @param buffer - buffer with data
   */onBufferDestroy(e){this._managedBuffers.splice(this._managedBuffers.indexOf(e),1);this._destroyBuffer(e)}destroy(){this._managedBuffers.forEach((e=>this._destroyBuffer(e)));this._managedBuffers=null;this._gpuBuffers=null}_destroyBuffer(e){const t=this._gpuBuffers[e.uid];t.destroy();e.off("update",this.updateBuffer,this);e.off("change",this.onBufferChange,this);e.off("destroy",this.onBufferDestroy,this);this._gpuBuffers[e.uid]=null}}GpuBufferSystem.extension={type:[X.WebGPUSystem],name:"buffer"};"use strict";function GpuReadBuffer(e,t){const r=e.descriptor.size;const s=t.gpu.device;const n=new Ut({data:new Float32Array(24e5),usage:Mt.MAP_READ|Mt.COPY_DST});const i=t.buffer.createGPUBuffer(n);const o=s.createCommandEncoder();o.copyBufferToBuffer(t.buffer.getGPUBuffer(e),0,i,0,r);s.queue.submit([o.finish()]);void i.mapAsync(GPUMapMode.READ,0,r).then((()=>{i.getMappedRange(0,r);i.unmap()}))}"use strict";class UboBatch{constructor({minUniformOffsetAlignment:e}){this._minUniformOffsetAlignment=256;this.byteIndex=0;this._minUniformOffsetAlignment=e;this.data=new Float32Array(65535)}clear(){this.byteIndex=0}addEmptyGroup(e){if(e>this._minUniformOffsetAlignment/4)throw new Error("UniformBufferBatch: array is too large: "+e*4);const t=this.byteIndex;let r=t+e*4;r=Math.ceil(r/this._minUniformOffsetAlignment)*this._minUniformOffsetAlignment;if(r>this.data.length*4)throw new Error("UniformBufferBatch: ubo batch got too big");this.byteIndex=r;return t}addGroup(e){const t=this.addEmptyGroup(e.length);for(let r=0;r<e.length;r++)this.data[t/4+r]=e[r];return t}destroy(){this.data=null}}"use strict";class GpuColorMaskSystem{constructor(e){this._colorMaskCache=15;this._renderer=e}setMask(e){if(this._colorMaskCache!==e){this._colorMaskCache=e;this._renderer.pipeline.setColorMask(e)}}destroy(){this._renderer=null;this._colorMaskCache=null}}GpuColorMaskSystem.extension={type:[X.WebGPUSystem],name:"colorMask"};"use strict";class GpuDeviceSystem{
/**
   * @param {WebGPURenderer} renderer - The renderer this System works for.
   */
constructor(e){this._renderer=e}async init(e){if(this._initPromise)return this._initPromise;this._initPromise=this._createDeviceAndAdaptor(e).then((e=>{this.gpu=e;this._renderer.runners.contextChange.emit(this.gpu)}));return this._initPromise}
/**
   * Handle the context change event
   * @param gpu
   */contextChange(e){this._renderer.gpu=e}
/**
   * Helper class to create a WebGL Context
   * @param {object} options - An options object that gets passed in to the canvas element containing the
   *    context attributes
   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
   * @returns {WebGLRenderingContext} the WebGL context
   */async _createDeviceAndAdaptor(e){const t=await ve.get().getNavigator().gpu.requestAdapter({powerPreference:e.powerPreference,forceFallbackAdapter:e.forceFallbackAdapter});const r=["texture-compression-bc","texture-compression-astc","texture-compression-etc2"].filter((e=>t.features.has(e)));const s=await t.requestDevice({requiredFeatures:r});return{adapter:t,device:s}}destroy(){this.gpu=null;this._renderer=null}}GpuDeviceSystem.extension={type:[X.WebGPUSystem],name:"device"};GpuDeviceSystem.defaultOptions={powerPreference:void 0,forceFallbackAdapter:false};"use strict";class GpuEncoderSystem{constructor(e){this._boundBindGroup=Object.create(null);this._boundVertexBuffer=Object.create(null);this._renderer=e}renderStart(){this.commandFinished=new Promise((e=>{this._resolveCommandFinished=e}));this.commandEncoder=this._renderer.gpu.device.createCommandEncoder()}beginRenderPass(e){this.endRenderPass();this._clearCache();this.renderPassEncoder=this.commandEncoder.beginRenderPass(e.descriptor)}endRenderPass(){this.renderPassEncoder&&this.renderPassEncoder.end();this.renderPassEncoder=null}setViewport(e){this.renderPassEncoder.setViewport(e.x,e.y,e.width,e.height,0,1)}setPipelineFromGeometryProgramAndState(e,t,r,s){const n=this._renderer.pipeline.getPipeline(e,t,r,s);this.setPipeline(n)}setPipeline(e){if(this._boundPipeline!==e){this._boundPipeline=e;this.renderPassEncoder.setPipeline(e)}}_setVertexBuffer(e,t){if(this._boundVertexBuffer[e]!==t){this._boundVertexBuffer[e]=t;this.renderPassEncoder.setVertexBuffer(e,this._renderer.buffer.updateBuffer(t))}}_setIndexBuffer(e){if(this._boundIndexBuffer===e)return;this._boundIndexBuffer=e;const t=e.data.BYTES_PER_ELEMENT===2?"uint16":"uint32";this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(e),t)}resetBindGroup(e){this._boundBindGroup[e]=null}setBindGroup(e,t,r){if(this._boundBindGroup[e]===t)return;this._boundBindGroup[e]=t;t._touch(this._renderer.textureGC.count);const s=this._renderer.bindGroup.getBindGroup(t,r,e);this.renderPassEncoder.setBindGroup(e,s)}setGeometry(e,t){const r=this._renderer.pipeline.getBufferNamesToBind(e,t);for(const t in r)this._setVertexBuffer(t,e.attributes[r[t]].buffer);e.indexBuffer&&this._setIndexBuffer(e.indexBuffer)}_setShaderBindGroups(e,t){for(const r in e.groups){const s=e.groups[r];t||this._syncBindGroup(s);this.setBindGroup(r,s,e.gpuProgram)}}_syncBindGroup(e){for(const t in e.resources){const r=e.resources[t];r.isUniformGroup&&this._renderer.ubo.updateUniformGroup(r)}}draw(e){const{geometry:t,shader:r,state:s,topology:n,size:i,start:o,instanceCount:a,skipSync:u}=e;this.setPipelineFromGeometryProgramAndState(t,r.gpuProgram,s,n);this.setGeometry(t,r.gpuProgram);this._setShaderBindGroups(r,u);t.indexBuffer?this.renderPassEncoder.drawIndexed(i||t.indexBuffer.data.length,a??t.instanceCount,o||0):this.renderPassEncoder.draw(i||t.getSize(),a??t.instanceCount,o||0)}finishRenderPass(){if(this.renderPassEncoder){this.renderPassEncoder.end();this.renderPassEncoder=null}}postrender(){this.finishRenderPass();this._gpu.device.queue.submit([this.commandEncoder.finish()]);this._resolveCommandFinished();this.commandEncoder=null}restoreRenderPass(){const e=this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget,false,[0,0,0,1]);this.renderPassEncoder=this.commandEncoder.beginRenderPass(e);const t=this._boundPipeline;const r={...this._boundVertexBuffer};const s=this._boundIndexBuffer;const n={...this._boundBindGroup};this._clearCache();const i=this._renderer.renderTarget.viewport;this.renderPassEncoder.setViewport(i.x,i.y,i.width,i.height,0,1);this.setPipeline(t);for(const e in r)this._setVertexBuffer(e,r[e]);for(const e in n)this.setBindGroup(e,n[e],null);this._setIndexBuffer(s)}_clearCache(){for(let e=0;e<16;e++){this._boundBindGroup[e]=null;this._boundVertexBuffer[e]=null}this._boundIndexBuffer=null;this._boundPipeline=null}destroy(){this._renderer=null;this._gpu=null;this._boundBindGroup=null;this._boundVertexBuffer=null;this._boundIndexBuffer=null;this._boundPipeline=null}contextChange(e){this._gpu=e}}GpuEncoderSystem.extension={type:[X.WebGPUSystem],name:"encoder",priority:1};"use strict";class GpuStencilSystem{constructor(e){this._renderTargetStencilState=Object.create(null);this._renderer=e;e.renderTarget.onRenderTargetChange.add(this)}onRenderTargetChange(e){let t=this._renderTargetStencilState[e.uid];t||(t=this._renderTargetStencilState[e.uid]={stencilMode:wt.DISABLED,stencilReference:0});this._activeRenderTarget=e;this.setStencilMode(t.stencilMode,t.stencilReference)}setStencilMode(e,t){const r=this._renderTargetStencilState[this._activeRenderTarget.uid];r.stencilMode=e;r.stencilReference=t;const s=this._renderer;s.pipeline.setStencilMode(e);s.encoder.renderPassEncoder.setStencilReference(t)}destroy(){this._renderer.renderTarget.onRenderTargetChange.remove(this);this._renderer=null;this._activeRenderTarget=null;this._renderTargetStencilState=null}}GpuStencilSystem.extension={type:[X.WebGPUSystem],name:"stencil"};"use strict";const qn=128;class GpuUniformBatchPipe{constructor(e){this._bindGroupHash=Object.create(null);this._buffers=[];this._bindGroups=[];this._bufferResources=[];this._renderer=e;this._renderer.renderableGC.addManagedHash(this,"_bindGroupHash");this._batchBuffer=new UboBatch({minUniformOffsetAlignment:qn});const t=256/qn;for(let e=0;e<t;e++){let t=Mt.UNIFORM|Mt.COPY_DST;e===0&&(t|=Mt.COPY_SRC);this._buffers.push(new Ut({data:this._batchBuffer.data,usage:t}))}}renderEnd(){this._uploadBindGroups();this._resetBindGroups()}_resetBindGroups(){for(const e in this._bindGroupHash)this._bindGroupHash[e]=null;this._batchBuffer.clear()}getUniformBindGroup(e,t){if(!t&&this._bindGroupHash[e.uid])return this._bindGroupHash[e.uid];this._renderer.ubo.ensureUniformGroup(e);const r=e.buffer.data;const s=this._batchBuffer.addEmptyGroup(r.length);this._renderer.ubo.syncUniformGroup(e,this._batchBuffer.data,s/4);this._bindGroupHash[e.uid]=this._getBindGroup(s/qn);return this._bindGroupHash[e.uid]}getUboResource(e){this._renderer.ubo.updateUniformGroup(e);const t=e.buffer.data;const r=this._batchBuffer.addGroup(t);return this._getBufferResource(r/qn)}getArrayBindGroup(e){const t=this._batchBuffer.addGroup(e);return this._getBindGroup(t/qn)}getArrayBufferResource(e){const t=this._batchBuffer.addGroup(e);const r=t/qn;return this._getBufferResource(r)}_getBufferResource(e){if(!this._bufferResources[e]){const t=this._buffers[e%2];this._bufferResources[e]=new Dt({buffer:t,offset:256*(e/2|0),size:qn})}return this._bufferResources[e]}_getBindGroup(e){if(!this._bindGroups[e]){const t=new jt({0:this._getBufferResource(e)});this._bindGroups[e]=t}return this._bindGroups[e]}_uploadBindGroups(){const e=this._renderer.buffer;const t=this._buffers[0];t.update(this._batchBuffer.byteIndex);e.updateBuffer(t);const r=this._renderer.gpu.device.createCommandEncoder();for(let s=1;s<this._buffers.length;s++){const n=this._buffers[s];r.copyBufferToBuffer(e.getGPUBuffer(t),qn,e.getGPUBuffer(n),0,this._batchBuffer.byteIndex)}this._renderer.gpu.device.queue.submit([r.finish()])}destroy(){for(let e=0;e<this._bindGroups.length;e++)this._bindGroups[e].destroy();this._bindGroups=null;this._bindGroupHash=null;for(let e=0;e<this._buffers.length;e++)this._buffers[e].destroy();this._buffers=null;for(let e=0;e<this._bufferResources.length;e++)this._bufferResources[e].destroy();this._bufferResources=null;this._batchBuffer.destroy();this._bindGroupHash=null;this._renderer=null}}GpuUniformBatchPipe.extension={type:[X.WebGPUPipes],name:"uniformBatch"};"use strict";const Qn={"point-list":0,"line-list":1,"line-strip":2,"triangle-list":3,"triangle-strip":4};function getGraphicsStateKey(e,t,r,s,n){return e<<24|t<<16|r<<10|s<<5|n}function getGlobalStateKey(e,t,r,s){return r<<6|e<<3|s<<1|t}class PipelineSystem{constructor(e){this._moduleCache=Object.create(null);this._bufferLayoutsCache=Object.create(null);this._bindingNamesCache=Object.create(null);this._pipeCache=Object.create(null);this._pipeStateCaches=Object.create(null);this._colorMask=15;this._multisampleCount=1;this._renderer=e}contextChange(e){this._gpu=e;this.setStencilMode(wt.DISABLED);this._updatePipeHash()}setMultisampleCount(e){if(this._multisampleCount!==e){this._multisampleCount=e;this._updatePipeHash()}}setRenderTarget(e){this._multisampleCount=e.msaaSamples;this._depthStencilAttachment=e.descriptor.depthStencilAttachment?1:0;this._updatePipeHash()}setColorMask(e){if(this._colorMask!==e){this._colorMask=e;this._updatePipeHash()}}setStencilMode(e){if(this._stencilMode!==e){this._stencilMode=e;this._stencilState=$s[e];this._updatePipeHash()}}setPipeline(e,t,r,s){const n=this.getPipeline(e,t,r);s.setPipeline(n)}getPipeline(e,t,r,s){if(!e._layoutKey){ensureAttributes(e,t.attributeData);this._generateBufferKey(e)}s||(s=e.topology);const n=getGraphicsStateKey(e._layoutKey,t._layoutKey,r.data,r._blendModeId,Qn[s]);if(this._pipeCache[n])return this._pipeCache[n];this._pipeCache[n]=this._createPipeline(e,t,r,s);return this._pipeCache[n]}_createPipeline(e,t,r,s){const n=this._gpu.device;const i=this._createVertexBufferLayouts(e,t);const o=this._renderer.state.getColorTargets(r);o[0].writeMask=this._stencilMode===wt.RENDERING_MASK_ADD?0:this._colorMask;const a=this._renderer.shader.getProgramData(t).pipeline;const u={vertex:{module:this._getModule(t.vertex.source),entryPoint:t.vertex.entryPoint,buffers:i},fragment:{module:this._getModule(t.fragment.source),entryPoint:t.fragment.entryPoint,targets:o},primitive:{topology:s,cullMode:r.cullMode},layout:a,multisample:{count:this._multisampleCount},label:"PIXI Pipeline"};this._depthStencilAttachment&&(u.depthStencil={...this._stencilState,format:"depth24plus-stencil8",depthWriteEnabled:r.depthTest,depthCompare:r.depthTest?"less":"always"});const c=n.createRenderPipeline(u);return c}_getModule(e){return this._moduleCache[e]||this._createModule(e)}_createModule(e){const t=this._gpu.device;this._moduleCache[e]=t.createShaderModule({code:e});return this._moduleCache[e]}_generateBufferKey(e){const t=[];let r=0;const s=Object.keys(e.attributes).sort();for(let n=0;n<s.length;n++){const i=e.attributes[s[n]];t[r++]=i.offset;t[r++]=i.format;t[r++]=i.stride;t[r++]=i.instance}const n=t.join("|");e._layoutKey=Qe(n,"geometry");return e._layoutKey}_generateAttributeLocationsKey(e){const t=[];let r=0;const s=Object.keys(e.attributeData).sort();for(let n=0;n<s.length;n++){const i=e.attributeData[s[n]];t[r++]=i.location}const n=t.join("|");e._attributeLocationsKey=Qe(n,"programAttributes");return e._attributeLocationsKey}
/**
   * Returns a hash of buffer names mapped to bind locations.
   * This is used to bind the correct buffer to the correct location in the shader.
   * @param geometry - The geometry where to get the buffer names
   * @param program - The program where to get the buffer names
   * @returns An object of buffer names mapped to the bind location.
   */getBufferNamesToBind(e,t){const r=e._layoutKey<<16|t._attributeLocationsKey;if(this._bindingNamesCache[r])return this._bindingNamesCache[r];const s=this._createVertexBufferLayouts(e,t);const n=Object.create(null);const i=t.attributeData;for(let e=0;e<s.length;e++){const t=Object.values(s[e].attributes);const r=t[0].shaderLocation;for(const t in i)if(i[t].location===r){n[e]=t;break}}this._bindingNamesCache[r]=n;return n}_createVertexBufferLayouts(e,t){t._attributeLocationsKey||this._generateAttributeLocationsKey(t);const r=e._layoutKey<<16|t._attributeLocationsKey;if(this._bufferLayoutsCache[r])return this._bufferLayoutsCache[r];const s=[];e.buffers.forEach((r=>{const n={arrayStride:0,stepMode:"vertex",attributes:[]};const i=n.attributes;for(const s in t.attributeData){const o=e.attributes[s];(o.divisor??1)!==1&&Fe(`Attribute ${s} has an invalid divisor value of '${o.divisor}'. WebGPU only supports a divisor value of 1`);if(o.buffer===r){n.arrayStride=o.stride;n.stepMode=o.instance?"instance":"vertex";i.push({shaderLocation:t.attributeData[s].location,offset:o.offset,format:o.format})}}i.length&&s.push(n)}));this._bufferLayoutsCache[r]=s;return s}_updatePipeHash(){const e=getGlobalStateKey(this._stencilMode,this._multisampleCount,this._colorMask,this._depthStencilAttachment);this._pipeStateCaches[e]||(this._pipeStateCaches[e]=Object.create(null));this._pipeCache=this._pipeStateCaches[e]}destroy(){this._renderer=null;this._bufferLayoutsCache=null}}PipelineSystem.extension={type:[X.WebGPUSystem],name:"pipeline"};"use strict";class GpuRenderTarget{constructor(){this.contexts=[];this.msaaTextures=[];this.msaaSamples=1}}"use strict";class GpuRenderTargetAdaptor{init(e,t){this._renderer=e;this._renderTargetSystem=t}copyToTexture(e,t,r,s,n){const i=this._renderer;const o=this._getGpuColorTexture(e);const a=i.texture.getGpuSource(t.source);i.encoder.commandEncoder.copyTextureToTexture({texture:o,origin:r},{texture:a,origin:n},s);return t}startRenderPass(e,t=true,r,s){const n=this._renderTargetSystem;const i=n.getGpuRenderTarget(e);const o=this.getDescriptor(e,t,r);i.descriptor=o;this._renderer.pipeline.setRenderTarget(i);this._renderer.encoder.beginRenderPass(i);this._renderer.encoder.setViewport(s)}finishRenderPass(){this._renderer.encoder.endRenderPass()}
/**
   * returns the gpu texture for the first color texture in the render target
   * mainly used by the filter manager to get copy the texture for blending
   * @param renderTarget
   * @returns a gpu texture
   */_getGpuColorTexture(e){const t=this._renderTargetSystem.getGpuRenderTarget(e);return t.contexts[0]?t.contexts[0].getCurrentTexture():this._renderer.texture.getGpuSource(e.colorTextures[0].source)}getDescriptor(e,t,r){typeof t==="boolean"&&(t=t?ue.ALL:ue.NONE);const s=this._renderTargetSystem;const n=s.getGpuRenderTarget(e);const i=e.colorTextures.map(((e,i)=>{const o=n.contexts[i];let a;let u;if(o){const e=o.getCurrentTexture();const t=e.createView();a=t}else a=this._renderer.texture.getGpuSource(e).createView({mipLevelCount:1});if(n.msaaTextures[i]){u=a;a=this._renderer.texture.getTextureView(n.msaaTextures[i])}const c=t&ue.COLOR?"clear":"load";r??(r=s.defaultClearColor);return{view:a,resolveTarget:u,clearValue:r,storeOp:"store",loadOp:c}}));let o;if((e.stencil||e.depth)&&!e.depthStencilTexture){e.ensureDepthStencilTexture();e.depthStencilTexture.source.sampleCount=n.msaa?4:1}if(e.depthStencilTexture){const r=t&ue.STENCIL?"clear":"load";const s=t&ue.DEPTH?"clear":"load";o={view:this._renderer.texture.getGpuSource(e.depthStencilTexture.source).createView(),stencilStoreOp:"store",stencilLoadOp:r,depthClearValue:1,depthLoadOp:s,depthStoreOp:"store"}}const a={colorAttachments:i,depthStencilAttachment:o};return a}clear(e,t=true,r,s){if(!t)return;const{gpu:n,encoder:i}=this._renderer;const o=n.device;const a=i.commandEncoder===null;if(a){const n=o.createCommandEncoder();const i=this.getDescriptor(e,t,r);const a=n.beginRenderPass(i);a.setViewport(s.x,s.y,s.width,s.height,0,1);a.end();const u=n.finish();o.queue.submit([u])}else this.startRenderPass(e,t,r,s)}initGpuRenderTarget(e){e.isRoot=true;const t=new GpuRenderTarget;e.colorTextures.forEach(((e,r)=>{if(Ht.test(e.resource)){const s=e.resource.getContext("webgpu");const n=e.transparent?"premultiplied":"opaque";try{s.configure({device:this._renderer.gpu.device,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,format:"bgra8unorm",alphaMode:n})}catch(e){console.error(e)}t.contexts[r]=s}t.msaa=e.source.antialias;if(e.source.antialias){const e=new Ce({width:0,height:0,sampleCount:4});t.msaaTextures[r]=e}}));if(t.msaa){t.msaaSamples=4;e.depthStencilTexture&&(e.depthStencilTexture.source.sampleCount=4)}return t}destroyGpuRenderTarget(e){e.contexts.forEach((e=>{e.unconfigure()}));e.msaaTextures.forEach((e=>{e.destroy()}));e.msaaTextures.length=0;e.contexts.length=0}ensureDepthStencilTexture(e){const t=this._renderTargetSystem.getGpuRenderTarget(e);e.depthStencilTexture&&t.msaa&&(e.depthStencilTexture.source.sampleCount=4)}resizeGpuRenderTarget(e){const t=this._renderTargetSystem.getGpuRenderTarget(e);t.width=e.width;t.height=e.height;t.msaa&&e.colorTextures.forEach(((e,r)=>{const s=t.msaaTextures[r];s?.resize(e.source.width,e.source.height,e.source._resolution)}))}}"use strict";class GpuRenderTargetSystem extends RenderTargetSystem{constructor(e){super(e);this.adaptor=new GpuRenderTargetAdaptor;this.adaptor.init(e,this)}}GpuRenderTargetSystem.extension={type:[X.WebGPUSystem],name:"renderTarget"};"use strict";"use strict";class GpuShaderSystem{constructor(){this._gpuProgramData=Object.create(null)}contextChange(e){this._gpu=e;this.maxTextures=e.device.limits.maxSampledTexturesPerShaderStage}getProgramData(e){return this._gpuProgramData[e._layoutKey]||this._createGPUProgramData(e)}_createGPUProgramData(e){const t=this._gpu.device;const r=e.gpuLayout.map((e=>t.createBindGroupLayout({entries:e})));const s={bindGroupLayouts:r};this._gpuProgramData[e._layoutKey]={bindGroups:r,pipeline:t.createPipelineLayout(s)};return this._gpuProgramData[e._layoutKey]}destroy(){this._gpu=null;this._gpuProgramData=null}}GpuShaderSystem.extension={type:[X.WebGPUSystem],name:"shader"};"use strict";const Zn={};Zn.normal={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}};Zn.add={alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one",operation:"add"}};Zn.multiply={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"dst",dstFactor:"one-minus-src-alpha",operation:"add"}};Zn.screen={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}};Zn.overlay={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}};Zn.none={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"zero",operation:"add"}};Zn["normal-npm"]={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}};Zn["add-npm"]={alpha:{srcFactor:"one",dstFactor:"one",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one",operation:"add"}};Zn["screen-npm"]={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src",operation:"add"}};Zn.erase={alpha:{srcFactor:"zero",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"one-minus-src",operation:"add"}};Zn.min={alpha:{srcFactor:"one",dstFactor:"one",operation:"min"},color:{srcFactor:"one",dstFactor:"one",operation:"min"}};Zn.max={alpha:{srcFactor:"one",dstFactor:"one",operation:"max"},color:{srcFactor:"one",dstFactor:"one",operation:"max"}};"use strict";class GpuStateSystem{constructor(){this.defaultState=new ot;this.defaultState.blend=true}contextChange(e){this.gpu=e}
/**
   * Gets the blend mode data for the current state
   * @param state - The state to get the blend mode from
   */getColorTargets(e){const t=Zn[e.blendMode]||Zn.normal;return[{format:"bgra8unorm",writeMask:0,blend:t}]}destroy(){this.gpu=null}}GpuStateSystem.extension={type:[X.WebGPUSystem],name:"state"};"use strict";const Jn={type:"image",upload(e,t,r){const s=e.resource;const n=(e.pixelWidth|0)*(e.pixelHeight|0);const i=s.byteLength/n;r.device.queue.writeTexture({texture:t},s,{offset:0,rowsPerImage:e.pixelHeight,bytesPerRow:e.pixelHeight*i},{width:e.pixelWidth,height:e.pixelHeight,depthOrArrayLayers:1})}};"use strict";const ei={"bc1-rgba-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"bc2-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc3-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc7-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"etc1-rgb-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"etc2-rgba8unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"astc-4x4-unorm":{blockBytes:16,blockWidth:4,blockHeight:4}};const ti={blockBytes:4,blockWidth:1,blockHeight:1};const ri={type:"compressed",upload(e,t,r){let s=e.pixelWidth;let n=e.pixelHeight;const i=ei[e.format]||ti;for(let o=0;o<e.resource.length;o++){const a=e.resource[o];const u=Math.ceil(s/i.blockWidth)*i.blockBytes;r.device.queue.writeTexture({texture:t,mipLevel:o},a,{offset:0,bytesPerRow:u},{width:Math.ceil(s/i.blockWidth)*i.blockWidth,height:Math.ceil(n/i.blockHeight)*i.blockHeight,depthOrArrayLayers:1});s=Math.max(s>>1,1);n=Math.max(n>>1,1)}}};"use strict";const si={type:"image",upload(e,t,r){const s=e.resource;if(!s)return;const n=Math.min(t.width,e.resourceWidth||e.pixelWidth);const i=Math.min(t.height,e.resourceHeight||e.pixelHeight);const o=e.alphaMode==="premultiply-alpha-on-upload";r.device.queue.copyExternalImageToTexture({source:s},{texture:t,premultipliedAlpha:o},{width:n,height:i})}};"use strict";const ni={type:"video",upload(e,t,r){si.upload(e,t,r)}};"use strict";class GpuMipmapGenerator{constructor(e){this.device=e;this.sampler=e.createSampler({minFilter:"linear"});this.pipelines={}}_getMipmapPipeline(e){let t=this.pipelines[e];if(!t){this.mipmapShaderModule||(this.mipmapShaderModule=this.device.createShaderModule({code:"\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    "}));t=this.device.createRenderPipeline({layout:"auto",vertex:{module:this.mipmapShaderModule,entryPoint:"vertexMain"},fragment:{module:this.mipmapShaderModule,entryPoint:"fragmentMain",targets:[{format:e}]}});this.pipelines[e]=t}return t}
/**
   * Generates mipmaps for the given GPUTexture from the data in level 0.
   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.
   * @returns {module:External.GPUTexture} - The originally passed texture
   */generateMipmap(e){const t=this._getMipmapPipeline(e.format);if(e.dimension==="3d"||e.dimension==="1d")throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");let r=e;const s=e.depthOrArrayLayers||1;const n=e.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!n){const t={size:{width:Math.ceil(e.width/2),height:Math.ceil(e.height/2),depthOrArrayLayers:s},format:e.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:e.mipLevelCount-1};r=this.device.createTexture(t)}const i=this.device.createCommandEncoder({});const o=t.getBindGroupLayout(0);for(let a=0;a<s;++a){let s=e.createView({baseMipLevel:0,mipLevelCount:1,dimension:"2d",baseArrayLayer:a,arrayLayerCount:1});let u=n?1:0;for(let n=1;n<e.mipLevelCount;++n){const e=r.createView({baseMipLevel:u++,mipLevelCount:1,dimension:"2d",baseArrayLayer:a,arrayLayerCount:1});const n=i.beginRenderPass({colorAttachments:[{view:e,storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:0}}]});const c=this.device.createBindGroup({layout:o,entries:[{binding:0,resource:this.sampler},{binding:1,resource:s}]});n.setPipeline(t);n.setBindGroup(0,c);n.draw(3,1,0,0);n.end();s=e}}if(!n){const t={width:Math.ceil(e.width/2),height:Math.ceil(e.height/2),depthOrArrayLayers:s};for(let s=1;s<e.mipLevelCount;++s){i.copyTextureToTexture({texture:r,mipLevel:s-1},{texture:e,mipLevel:s},t);t.width=Math.ceil(t.width/2);t.height=Math.ceil(t.height/2)}}this.device.queue.submit([i.finish()]);n||r.destroy();return e}}"use strict";class GpuTextureSystem{constructor(e){this.managedTextures=[];this._gpuSources=Object.create(null);this._gpuSamplers=Object.create(null);this._bindGroupHash=Object.create(null);this._textureViewHash=Object.create(null);this._uploads={image:si,buffer:Jn,video:ni,compressed:ri};this._renderer=e;e.renderableGC.addManagedHash(this,"_gpuSources");e.renderableGC.addManagedHash(this,"_gpuSamplers");e.renderableGC.addManagedHash(this,"_bindGroupHash");e.renderableGC.addManagedHash(this,"_textureViewHash")}contextChange(e){this._gpu=e}initSource(e){if(e.autoGenerateMipmaps){const t=Math.max(e.pixelWidth,e.pixelHeight);e.mipLevelCount=Math.floor(Math.log2(t))+1}let t=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST;if(e.uploadMethodId!=="compressed"){t|=GPUTextureUsage.RENDER_ATTACHMENT;t|=GPUTextureUsage.COPY_SRC}const r=ei[e.format]||{blockBytes:4,blockWidth:1,blockHeight:1};const s=Math.ceil(e.pixelWidth/r.blockWidth)*r.blockWidth;const n=Math.ceil(e.pixelHeight/r.blockHeight)*r.blockHeight;const i={label:e.label,size:{width:s,height:n},format:e.format,sampleCount:e.sampleCount,mipLevelCount:e.mipLevelCount,dimension:e.dimension,usage:t};const o=this._gpu.device.createTexture(i);this._gpuSources[e.uid]=o;if(!this.managedTextures.includes(e)){e.on("update",this.onSourceUpdate,this);e.on("resize",this.onSourceResize,this);e.on("destroy",this.onSourceDestroy,this);e.on("unload",this.onSourceUnload,this);e.on("updateMipmaps",this.onUpdateMipmaps,this);this.managedTextures.push(e)}this.onSourceUpdate(e);return o}onSourceUpdate(e){const t=this.getGpuSource(e);if(t){this._uploads[e.uploadMethodId]&&this._uploads[e.uploadMethodId].upload(e,t,this._gpu);e.autoGenerateMipmaps&&e.mipLevelCount>1&&this.onUpdateMipmaps(e)}}onSourceUnload(e){const t=this._gpuSources[e.uid];if(t){this._gpuSources[e.uid]=null;t.destroy()}}onUpdateMipmaps(e){this._mipmapGenerator||(this._mipmapGenerator=new GpuMipmapGenerator(this._gpu.device));const t=this.getGpuSource(e);this._mipmapGenerator.generateMipmap(t)}onSourceDestroy(e){e.off("update",this.onSourceUpdate,this);e.off("unload",this.onSourceUnload,this);e.off("destroy",this.onSourceDestroy,this);e.off("resize",this.onSourceResize,this);e.off("updateMipmaps",this.onUpdateMipmaps,this);this.managedTextures.splice(this.managedTextures.indexOf(e),1);this.onSourceUnload(e)}onSourceResize(e){const t=this._gpuSources[e.uid];if(t){if(t.width!==e.pixelWidth||t.height!==e.pixelHeight){this._textureViewHash[e.uid]=null;this._bindGroupHash[e.uid]=null;this.onSourceUnload(e);this.initSource(e)}}else this.initSource(e)}_initSampler(e){this._gpuSamplers[e._resourceId]=this._gpu.device.createSampler(e);return this._gpuSamplers[e._resourceId]}getGpuSampler(e){return this._gpuSamplers[e._resourceId]||this._initSampler(e)}getGpuSource(e){return this._gpuSources[e.uid]||this.initSource(e)}
/**
   * this returns s bind group for a specific texture, the bind group contains
   * - the texture source
   * - the texture style
   * - the texture matrix
   * This is cached so the bind group should only be created once per texture
   * @param texture - the texture you want the bindgroup for
   * @returns the bind group for the texture
   */getTextureBindGroup(e){return this._bindGroupHash[e.uid]??this._createTextureBindGroup(e)}_createTextureBindGroup(e){const t=e.source;this._bindGroupHash[e.uid]=new jt({0:t,1:t.style,2:new qe({uTextureMatrix:{type:"mat3x3<f32>",value:e.textureMatrix.mapCoord}})});return this._bindGroupHash[e.uid]}getTextureView(e){const t=e.source;return this._textureViewHash[t.uid]??this._createTextureView(t)}_createTextureView(e){this._textureViewHash[e.uid]=this.getGpuSource(e).createView();return this._textureViewHash[e.uid]}generateCanvas(e){const t=this._renderer;const r=t.gpu.device.createCommandEncoder();const s=ve.get().createCanvas();s.width=e.source.pixelWidth;s.height=e.source.pixelHeight;const n=s.getContext("webgpu");n.configure({device:t.gpu.device,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,format:ve.get().getNavigator().gpu.getPreferredCanvasFormat(),alphaMode:"premultiplied"});r.copyTextureToTexture({texture:t.texture.getGpuSource(e.source),origin:{x:0,y:0}},{texture:n.getCurrentTexture()},{width:s.width,height:s.height});t.gpu.device.queue.submit([r.finish()]);return s}getPixels(e){const t=this.generateCanvas(e);const r=He.getOptimalCanvasAndContext(t.width,t.height);const s=r.context;s.drawImage(t,0,0);const{width:n,height:i}=t;const o=s.getImageData(0,0,n,i);const a=new Uint8ClampedArray(o.data.buffer);He.returnCanvasAndContext(r);return{pixels:a,width:n,height:i}}destroy(){this.managedTextures.slice().forEach((e=>this.onSourceDestroy(e)));this.managedTextures=null;for(const e of Object.keys(this._bindGroupHash)){const t=Number(e);const r=this._bindGroupHash[t];r?.destroy();this._bindGroupHash[t]=null}this._gpu=null;this._mipmapGenerator=null;this._gpuSources=null;this._bindGroupHash=null;this._textureViewHash=null;this._gpuSamplers=null}}GpuTextureSystem.extension={type:[X.WebGPUSystem],name:"texture"};"use strict";"use strict";class GpuGraphicsAdaptor{init(){const e=new qe({uTransformMatrix:{value:new et,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}});const t=Et({name:"graphics",bits:[ft,mt(at()),Ct,At]});this.shader=new $e({gpuProgram:t,resources:{localUniforms:e}})}execute(e,t){const r=t.context;const s=r.customShader||this.shader;const n=e.renderer;const i=n.graphicsContext;const{batcher:o,instructions:a}=i.getContextRenderData(r);const u=n.encoder;u.setGeometry(o.geometry,s.gpuProgram);const c=n.globalUniforms.bindGroup;u.setBindGroup(0,c,s.gpuProgram);const l=n.renderPipes.uniformBatch.getUniformBindGroup(s.resources.localUniforms,true);u.setBindGroup(2,l,s.gpuProgram);const d=a.instructions;let h=null;for(let t=0;t<a.instructionSize;t++){const r=d[t];if(r.topology!==h){h=r.topology;u.setPipelineFromGeometryProgramAndState(o.geometry,s.gpuProgram,e.state,r.topology)}s.groups[1]=r.bindGroup;if(!r.gpuBindGroup){const e=r.textures;r.bindGroup=ut(e.textures,e.count);r.gpuBindGroup=n.bindGroup.getBindGroup(r.bindGroup,s.gpuProgram,1)}u.setBindGroup(1,r.bindGroup,s.gpuProgram);u.renderPassEncoder.drawIndexed(r.size,1,r.start)}}destroy(){this.shader.destroy(true);this.shader=null}}GpuGraphicsAdaptor.extension={type:[X.WebGPUPipesAdaptor],name:"graphics"};"use strict";class GpuMeshAdapter{init(){const e=Et({name:"mesh",bits:[Rt,Us,At]});this._shader=new $e({gpuProgram:e,resources:{uTexture:Ae.EMPTY._source,uSampler:Ae.EMPTY._source.style,textureUniforms:{uTextureMatrix:{type:"mat3x3<f32>",value:new et}}}})}execute(e,t){const r=e.renderer;let s=t._shader;if(s){if(!s.gpuProgram){Fe("Mesh shader has no gpuProgram",t.shader);return}}else{s=this._shader;s.groups[2]=r.texture.getTextureBindGroup(t.texture)}const n=s.gpuProgram;n.autoAssignGlobalUniforms&&(s.groups[0]=r.globalUniforms.bindGroup);if(n.autoAssignLocalUniforms){const t=e.localUniforms;s.groups[1]=r.renderPipes.uniformBatch.getUniformBindGroup(t,true)}r.encoder.draw({geometry:t._geometry,shader:s,state:t.state})}destroy(){this._shader.destroy(true);this._shader=null}}GpuMeshAdapter.extension={type:[X.WebGPUPipesAdaptor],name:"mesh"};"use strict";const ii=[...Hn,Nt,GpuEncoderSystem,GpuDeviceSystem,GpuBufferSystem,GpuTextureSystem,GpuRenderTargetSystem,GpuShaderSystem,GpuStateSystem,PipelineSystem,GpuColorMaskSystem,GpuStencilSystem,BindGroupSystem];const oi=[...Vn,GpuUniformBatchPipe];const ai=[GpuBatchAdaptor,GpuMeshAdapter,GpuGraphicsAdaptor];const ui=[];const ci=[];const li=[];Y.handleByNamedList(X.WebGPUSystem,ui);Y.handleByNamedList(X.WebGPUPipes,ci);Y.handleByNamedList(X.WebGPUPipesAdaptor,li);Y.add(...ii,...oi,...ai);class WebGPURenderer extends ae{constructor(){const e={name:"webgpu",type:Je.WEBGPU,systems:ui,renderPipes:ci,renderPipeAdaptors:li};super(e)}}var di=Object.freeze(Object.defineProperty({__proto__:null,WebGPURenderer:WebGPURenderer},Symbol.toStringTag,{value:"Module"}));"use strict";const hi={POINTS:"point-list",LINES:"line-list",LINE_STRIP:"line-strip",TRIANGLES:"triangle-list",TRIANGLE_STRIP:"triangle-strip"};const pi=new Proxy(hi,{get(e,t){ye(Te,`DRAW_MODES.${t} is deprecated, use '${hi[t]}' instead`);return e[t]}});"use strict";"use strict";"use strict";"use strict";const fi=new Ee(0,0,1,1);function viewportFromFrame(e,t,r){r||(r=fi);const s=t.pixelWidth;const n=t.pixelHeight;e.x=r.x*s|0;e.y=r.y*n|0;e.width=r.width*s|0;e.height=r.height*n|0;return e}"use strict";"use strict";"use strict";"use strict";var mi=(e=>{e[e.NONE=0]="NONE";e[e.LOW=2]="LOW";e[e.MEDIUM=4]="MEDIUM";e[e.HIGH=8]="HIGH";return e})(mi||{});var gi=(e=>{e.CLAMP="clamp-to-edge";e.REPEAT="repeat";e.MIRRORED_REPEAT="mirror-repeat";return e})(gi||{});const _i=new Proxy(gi,{get(e,t){ye(Te,`DRAW_MODES.${t} is deprecated, use '${gi[t]}' instead`);return e[t]}});var xi=(e=>{e.NEAREST="nearest";e.LINEAR="linear";return e})(xi||{});const bi=new Proxy(xi,{get(e,t){ye(Te,`DRAW_MODES.${t} is deprecated, use '${xi[t]}' instead`);return e[t]}});"use strict";"use strict";class TextureUvs{constructor(){this.x0=0;this.y0=0;this.x1=1;this.y1=0;this.x2=1;this.y2=1;this.x3=0;this.y3=1;this.uvsFloat32=new Float32Array(8)}
/**
   * Sets the texture Uvs based on the given frame information.
   * @protected
   * @param frame - The frame of the texture
   * @param baseFrame - The base frame of the texture
   * @param rotate - Rotation of frame, see {@link groupD8}
   */set(e,t,r){const s=t.width;const n=t.height;if(r){const t=e.width/2/s;const i=e.height/2/n;const o=e.x/s+t;const a=e.y/n+i;r=Re.add(r,Re.NW);this.x0=o+t*Re.uX(r);this.y0=a+i*Re.uY(r);r=Re.add(r,2);this.x1=o+t*Re.uX(r);this.y1=a+i*Re.uY(r);r=Re.add(r,2);this.x2=o+t*Re.uX(r);this.y2=a+i*Re.uY(r);r=Re.add(r,2);this.x3=o+t*Re.uX(r);this.y3=a+i*Re.uY(r)}else{this.x0=e.x/s;this.y0=e.y/n;this.x1=(e.x+e.width)/s;this.y1=e.y/n;this.x2=(e.x+e.width)/s;this.y2=(e.y+e.height)/n;this.x3=e.x/s;this.y3=(e.y+e.height)/n}this.uvsFloat32[0]=this.x0;this.uvsFloat32[1]=this.y0;this.uvsFloat32[2]=this.x1;this.uvsFloat32[3]=this.y1;this.uvsFloat32[4]=this.x2;this.uvsFloat32[5]=this.y2;this.uvsFloat32[6]=this.x3;this.uvsFloat32[7]=this.y3}toString(){return`[pixi.js/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`}}"use strict";let yi=0;function generateUID(){return yi++}"use strict";function parseFunctionBody(e){const t=e.toString();const r=t.indexOf("{");const s=t.lastIndexOf("}");if(r===-1||s===-1)throw new Error("getFunctionBody: No body found in function definition");return t.slice(r+1,s).trim()}"use strict";"use strict";"use strict";function getFastGlobalBounds(e,t){ye("8.7.0","Use container.getFastGlobalBounds() instead");return e.getFastGlobalBounds(true,t)}"use strict";"use strict";"use strict";class RenderContainer extends Xt{
/**
   * @param options - The options for the container.
   */
constructor(e){typeof e==="function"&&(e={render:e});const{render:t,...r}=e;super({label:"RenderContainer",...r});this.renderPipeId="customRender";this.batched=false;t&&(this.render=t);this.containsPoint=e.containsPoint??(()=>false);this.addBounds=e.addBounds??(()=>false)}updateBounds(){this._bounds.clear();this.addBounds(this._bounds)}
/**
   * An overridable function that can be used to render the object using the current renderer.
   * @param _renderer - The current renderer
   */render(e){}}"use strict";function collectAllRenderables(e,t,r){ye("8.7.0","Please use container.collectRenderables instead.");const s=r.renderPipes?r:r.batch.renderer;return e.collectRenderables(t,s,null)}"use strict";function mixHexColors(e,t,r){const s=e>>16&255;const n=e>>8&255;const i=e&255;const o=t>>16&255;const a=t>>8&255;const u=t&255;const c=s+(o-s)*r;const l=n+(a-n)*r;const d=i+(u-i)*r;return(c<<16)+(l<<8)+d}"use strict";function updateLocalTransform(e,t){const r=t._scale;const s=t._pivot;const n=t._position;const i=r._x;const o=r._y;const a=s._x;const u=s._y;e.a=t._cx*i;e.b=t._sx*i;e.c=t._cy*o;e.d=t._sy*o;e.tx=n._x-(a*e.a+u*e.c);e.ty=n._y-(a*e.b+u*e.d)}"use strict";function updateWorldTransform(e,t,r){const s=e.a;const n=e.b;const i=e.c;const o=e.d;const a=e.tx;const u=e.ty;const c=t.a;const l=t.b;const d=t.c;const h=t.d;r.a=s*c+n*d;r.b=s*l+n*h;r.c=i*c+o*d;r.d=i*l+o*h;r.tx=a*c+u*d+t.tx;r.ty=a*l+u*h+t.ty}"use strict";"use strict";"use strict";const Ti={rectangle:bt,polygon:xt,triangle:_t,circle:gt,ellipse:gt,roundedRectangle:gt};function buildGeometryFromPath(e){e instanceof Ve&&(e={path:e,textureMatrix:null,out:null});const t=[];const r=[];const s=[];const n=e.path.shapePath;const i=e.textureMatrix;n.shapePrimitives.forEach((({shape:e,transform:n})=>{const o=s.length;const a=t.length/2;const u=[];const c=Ti[e.type];c.build(e,u);n&&yt(u,n);c.triangulate(u,t,2,a,s,o);const l=r.length/2;if(i){n&&i.append(n.clone().invert());Tt(t,2,a,r,l,2,t.length/2-a,i)}else St(r,l,2,t.length/2-a)}));const o=e.out;if(o){o.positions=new Float32Array(t);o.uvs=new Float32Array(r);o.indices=new Uint32Array(s);return o}const a=new Yt({positions:new Float32Array(t),uvs:new Float32Array(r),indices:new Uint32Array(s)});return a}"use strict";const Si=class _RenderLayerClass extends le{
/**
   * Creates a new RenderLayer instance
   * @param options - Configuration options for the RenderLayer
   * @param {boolean} [options.sortableChildren=false] - If true, layer children will be automatically sorted each render
   * @param {Function} [options.sortFunction] - Custom function to sort layer children. Default sorts by zIndex
   */
constructor(e={}){e={..._RenderLayerClass.defaultOptions,...e};super();this.renderLayerChildren=[];this.sortableChildren=e.sortableChildren;this.sortFunction=e.sortFunction}
/**
   * Add an Container to this render layer. The Container will be rendered as part of this layer
   * while maintaining its original parent in the scene graph.
   * If the Container already belongs to a layer, it will be removed from the old layer before being added to this one.
   * @param children - The Container(s) to add to this layer
   */attach(...e){for(let t=0;t<e.length;t++){const r=e[t];if(r.parentRenderLayer){if(r.parentRenderLayer===this)continue;r.parentRenderLayer.detach(r)}this.renderLayerChildren.push(r);r.parentRenderLayer=this;const s=this.renderGroup||this.parentRenderGroup;s&&(s.structureDidChange=true)}return e[0]}
/**
   * Remove an Container from this render layer. The Container will no longer be rendered
   * as part of this layer but maintains its original parent.
   * @param children - The Container(s) to remove from this layer
   */detach(...e){for(let t=0;t<e.length;t++){const r=e[t];const s=this.renderLayerChildren.indexOf(r);s!==-1&&this.renderLayerChildren.splice(s,1);r.parentRenderLayer=null;const n=this.renderGroup||this.parentRenderGroup;n&&(n.structureDidChange=true)}return e[0]}detachAll(){const e=this.renderLayerChildren;for(let t=0;t<e.length;t++)e[t].parentRenderLayer=null;this.renderLayerChildren.length=0}collectRenderables(e,t,r){const s=this.renderLayerChildren;const n=s.length;this.sortableChildren&&this.sortRenderLayerChildren();for(let r=0;r<n;r++){s[r].parent||Fe("Container must be added to both layer and scene graph. Layers only handle render order - the scene graph is required for transforms (addChild)",s[r]);s[r].collectRenderables(e,t,this)}}sortRenderLayerChildren(){this.renderLayerChildren.sort(this.sortFunction)}_getGlobalBoundsRecursive(e,t,r){if(!e)return;const s=this.renderLayerChildren;for(let e=0;e<s.length;e++)s[e]._getGlobalBoundsRecursive(true,t,this)}};Si.defaultOptions={sortableChildren:false,sortFunction:(e,t)=>e.zIndex-t.zIndex};let vi=Si;const Gi=vi;"use strict";function applyProjectiveTransformationToPlane(e,t,r,s){const n=r.buffers[0];const i=n.data;const{verticesX:o,verticesY:a}=r;const u=e/(o-1);const c=t/(a-1);let l=0;const d=s[0];const h=s[1];const p=s[2];const f=s[3];const m=s[4];const g=s[5];const _=s[6];const x=s[7];const b=s[8];for(let e=0;e<i.length;e+=2){const t=l%o*u;const r=(l/o|0)*c;const s=d*t+h*r+p;const n=f*t+m*r+g;const a=_*t+x*r+b;i[e]=s/a;i[e+1]=n/a;l++}n.update()}"use strict";function computeAdjugate(e,t){const r=t[0];const s=t[1];const n=t[2];const i=t[3];const o=t[4];const a=t[5];const u=t[6];const c=t[7];const l=t[8];e[0]=o*l-a*c;e[1]=n*c-s*l;e[2]=s*a-n*o;e[3]=a*u-i*l;e[4]=r*l-n*u;e[5]=n*i-r*a;e[6]=i*c-o*u;e[7]=s*u-r*c;e[8]=r*o-s*i;return e}function multiplyMatrix3x3(e,t,r){const s=t[0];const n=t[1];const i=t[2];const o=t[3];const a=t[4];const u=t[5];const c=t[6];const l=t[7];const d=t[8];const h=r[0];const p=r[1];const f=r[2];const m=r[3];const g=r[4];const _=r[5];const x=r[6];const b=r[7];const y=r[8];e[0]=h*s+p*o+f*c;e[1]=h*n+p*a+f*l;e[2]=h*i+p*u+f*d;e[3]=m*s+g*o+_*c;e[4]=m*n+g*a+_*l;e[5]=m*i+g*u+_*d;e[6]=x*s+b*o+y*c;e[7]=x*n+b*a+y*l;e[8]=x*i+b*u+y*d;return e}function multiplyMatrixAndVector(e,t,r){const s=r[0];const n=r[1];const i=r[2];e[0]=t[0]*s+t[1]*n+t[2]*i;e[1]=t[3]*s+t[4]*n+t[5]*i;e[2]=t[6]*s+t[7]*n+t[8]*i;return e}const Ei=[0,0,0,0,0,0,0,0,0];const Ai=[0,0,0];const Pi=[0,0,0];function generateBasisToPointsMatrix(e,t,r,s,n,i,o,a,u){const c=Ei;c[0]=t;c[1]=s;c[2]=i;c[3]=r;c[4]=n;c[5]=o;c[6]=1;c[7]=1;c[8]=1;const l=computeAdjugate(e,c);Pi[0]=a;Pi[1]=u;Pi[2]=1;const d=multiplyMatrixAndVector(Ai,l,Pi);const h=e;e[0]=d[0];e[1]=0;e[2]=0;e[3]=0;e[4]=d[1];e[5]=0;e[6]=0;e[7]=0;e[8]=d[2];return multiplyMatrix3x3(e,h,c)}const Ci=[0,0,0,0,0,0,0,0,0];const Ri=[0,0,0,0,0,0,0,0,0];function compute2DProjection(e,t,r,s,n,i,o,a,u,c,l,d,h,p,f,m,g){const _=generateBasisToPointsMatrix(Ci,t,r,i,o,c,l,p,f);const x=generateBasisToPointsMatrix(Ri,s,n,a,u,d,h,m,g);return multiplyMatrix3x3(e,computeAdjugate(_,_),x)}"use strict";class PerspectivePlaneGeometry extends Kt{
/**
   * @param options - Options to be applied to MeshPlane
   * @param options.width - The width of the plane
   * @param options.height - The height of the plane
   * @param options.verticesX - The amount of vertices on the x axis
   * @param options.verticesY - The amount of vertices on the y axis
   */
constructor(e){super(e);this._projectionMatrix=[0,0,0,0,0,0,0,0,0];const{width:t,height:r}=e;this.corners=[0,0,t,0,t,r,0,r]}
/**
   * Will set the corners of the quad to the given coordinates
   * Calculating the perspective so it looks correct!
   * @param x0 - x coordinate of the first corner
   * @param y0 - y coordinate of the first corner
   * @param x1 - x coordinate of the second corner
   * @param y1 - y coordinate of the second corner
   * @param x2 - x coordinate of the third corner
   * @param y2 - y coordinate of the third corner
   * @param x3 - x coordinate of the fourth corner
   * @param y3 - y coordinate of the fourth corner
   */setCorners(e,t,r,s,n,i,o,a){const u=this.corners;u[0]=e;u[1]=t;u[2]=r;u[3]=s;u[4]=n;u[5]=i;u[6]=o;u[7]=a;this.updateProjection()}updateProjection(){const{width:e,height:t}=this;const r=this.corners;const s=compute2DProjection(this._projectionMatrix,0,0,r[0],r[1],e,0,r[2],r[3],e,t,r[4],r[5],0,t,r[6],r[7]);applyProjectiveTransformationToPlane(e,t,this,s)}}"use strict";const Bi=class _PerspectiveMesh extends it{
/**
   * @param options - Options to be applied to PerspectiveMesh
   */
constructor(e){e={..._PerspectiveMesh.defaultOptions,...e};const{texture:t,verticesX:r,verticesY:s,...n}=e;const i=new PerspectivePlaneGeometry(Be({width:t.width,height:t.height,verticesX:r,verticesY:s}));super(Be({...n,geometry:i}));this._texture=t;this.geometry.setCorners(e.x0,e.y0,e.x1,e.y1,e.x2,e.y2,e.x3,e.y3)}textureUpdated(){const e=this.geometry;if(!e)return;const{width:t,height:r}=this.texture;if(e.width!==t||e.height!==r){e.width=t;e.height=r;e.updateProjection()}}set texture(e){if(this._texture!==e){super.texture=e;this.textureUpdated()}}get texture(){return this._texture}
/**
   * Set the corners of the quad to the given coordinates
   * The mesh will then calculate the perspective so it looks correct!
   * @param x0 - x coordinate of the first corner
   * @param y0 - y coordinate of the first corner
   * @param x1 - x coordinate of the second corner
   * @param y1 - y coordinate of the second corner
   * @param x2 - x coordinate of the third corner
   * @param y2 - y coordinate of the third corner
   * @param x3 - x coordinate of the fourth corner
   * @param y3 - y coordinate of the fourth corner
   */setCorners(e,t,r,s,n,i,o,a){this.geometry.setCorners(e,t,r,s,n,i,o,a)}};Bi.defaultOptions={texture:Ae.WHITE,verticesX:10,verticesY:10,x0:0,y0:0,x1:100,y1:0,x2:100,y2:100,x3:0,y3:100};let wi=Bi;"use strict";class MeshPlane extends it{
/**
   * @param options - Options to be applied to MeshPlane
   */
constructor(e){const{texture:t,verticesX:r,verticesY:s,...n}=e;const i=new Kt(Be({width:t.width,height:t.height,verticesX:r,verticesY:s}));super(Be({...n,geometry:i,texture:t}));this.texture=t;this.autoResize=true}textureUpdated(){const e=this.geometry;const{width:t,height:r}=this.texture;if(this.autoResize&&(e.width!==t||e.height!==r)){e.width=t;e.height=r;e.build({})}}set texture(e){this._texture?.off("update",this.textureUpdated,this);super.texture=e;e.on("update",this.textureUpdated,this);this.textureUpdated()}get texture(){return this._texture}
/**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */destroy(e){this.texture.off("update",this.textureUpdated,this);super.destroy(e)}}"use strict";const Mi=class _RopeGeometry extends Yt{
/**
   * @param options - Options to be applied to rope geometry
   */
constructor(e){const{width:t,points:r,textureScale:s}={..._RopeGeometry.defaultOptions,...e};super({positions:new Float32Array(r.length*4),uvs:new Float32Array(r.length*4),indices:new Uint32Array(6*(r.length-1))});this.points=r;this._width=t;this.textureScale=s;this._build()}get width(){return this._width}_build(){const e=this.points;if(!e)return;const t=this.getBuffer("aPosition");const r=this.getBuffer("aUV");const s=this.getIndex();if(e.length<1)return;if(t.data.length/4!==e.length){t.data=new Float32Array(e.length*4);r.data=new Float32Array(e.length*4);s.data=new Uint16Array(6*(e.length-1))}const n=r.data;const i=s.data;n[0]=0;n[1]=0;n[2]=0;n[3]=1;let o=0;let a=e[0];const u=this._width*this.textureScale;const c=e.length;for(let t=0;t<c;t++){const r=t*4;if(this.textureScale>0){const r=a.x-e[t].x;const s=a.y-e[t].y;const n=Math.sqrt(r*r+s*s);a=e[t];o+=n/u}else o=t/(c-1);n[r]=o;n[r+1]=0;n[r+2]=o;n[r+3]=1}let l=0;for(let e=0;e<c-1;e++){const t=e*2;i[l++]=t;i[l++]=t+1;i[l++]=t+2;i[l++]=t+2;i[l++]=t+1;i[l++]=t+3}r.update();s.update();this.updateVertices()}updateVertices(){const e=this.points;if(e.length<1)return;let t=e[0];let r;let s=0;let n=0;const i=this.buffers[0].data;const o=e.length;const a=this.textureScale>0?this.textureScale*this._width/2:this._width/2;for(let u=0;u<o;u++){const c=e[u];const l=u*4;r=u<e.length-1?e[u+1]:c;n=-(r.x-t.x);s=r.y-t.y;let d=10*(1-u/(o-1));d>1&&(d=1);const h=Math.sqrt(s*s+n*n);if(h<1e-6){s=0;n=0}else{s/=h;n/=h;s*=a;n*=a}i[l]=c.x+s;i[l+1]=c.y+n;i[l+2]=c.x-s;i[l+3]=c.y-n;t=c}this.buffers[0].update()}update(){this.textureScale>0?this._build():this.updateVertices()}};Mi.defaultOptions={width:200,points:[],textureScale:0};let Fi=Mi;"use strict";const Ui=class _MeshRope extends it{
/**
   * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.
   * @param options
   * @param options.texture - The texture to use on the rope.
   * @param options.points - An array of {@link math.Point} objects to construct this rope.
   * @param {number} options.textureScale - Optional. Positive values scale rope texture
   * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture
   * and downsampling here. If set to zero, texture will be stretched instead.
   */
constructor(e){const{texture:t,points:r,textureScale:s,...n}={..._MeshRope.defaultOptions,...e};const i=new Fi(Be({width:t.height,points:r,textureScale:s}));s>0&&(t.source.style.addressMode="repeat");super(Be({...n,texture:t,geometry:i}));this.autoUpdate=true;this.onRender=this._render}_render(){const e=this.geometry;if(this.autoUpdate||e._width!==this.texture.height){e._width=this.texture.height;e.update()}}};Ui.defaultOptions={textureScale:0};let Ii=Ui;"use strict";class MeshSimple extends it{
/**
   * @param options - Options to be used for construction
   */
constructor(e){const{texture:t,vertices:r,uvs:s,indices:n,topology:i,...o}=e;const a=new Yt(Be({positions:r,uvs:s,indices:n,topology:i}));super(Be({...o,texture:t,geometry:a}));this.autoUpdate=true;this.onRender=this._render}
/**
   * Collection of vertices data.
   * @type {Float32Array}
   */get vertices(){return this.geometry.getBuffer("aPosition").data}set vertices(e){this.geometry.getBuffer("aPosition").data=e}_render(){this.autoUpdate&&this.geometry.getBuffer("aPosition").update()}}"use strict";function getTextureDefaultMatrix(e,t){const{width:r,height:s}=e.frame;t.scale(1/r,1/s);return t}"use strict";const Oi=class _Particle{constructor(e){if(e instanceof Ae){this.texture=e;xe(this,_Particle.defaultOptions,{})}else{const t={..._Particle.defaultOptions,...e};xe(this,t,{})}}get alpha(){return this._alpha}set alpha(e){this._alpha=Math.min(Math.max(e,0),1);this._updateColor()}get tint(){return be(this._tint)}set tint(e){this._tint=typeof e==="number"?e:je.shared.setValue(e??16777215).toBgrNumber();this._updateColor()}_updateColor(){this.color=this._tint+(this._alpha*255<<24)}};Oi.defaultOptions={anchorX:0,anchorY:0,x:0,y:0,scaleX:1,scaleY:1,rotation:0,tint:16777215,alpha:1};let ki=Oi;"use strict";const Li={vertex:{attributeName:"aVertex",format:"float32x2",code:"\n            const texture = p.texture;\n            const sx = p.scaleX;\n            const sy = p.scaleY;\n            const ax = p.anchorX;\n            const ay = p.anchorY;\n            const trim = texture.trim;\n            const orig = texture.orig;\n\n            if (trim)\n            {\n                w1 = trim.x - (ax * orig.width);\n                w0 = w1 + trim.width;\n\n                h1 = trim.y - (ay * orig.height);\n                h0 = h1 + trim.height;\n            }\n            else\n            {\n                w1 = -ax * (orig.width);\n                w0 = w1 + orig.width;\n\n                h1 = -ay * (orig.height);\n                h0 = h1 + orig.height;\n            }\n\n            f32v[offset] = w1 * sx;\n            f32v[offset + 1] = h1 * sy;\n\n            f32v[offset + stride] = w0 * sx;\n            f32v[offset + stride + 1] = h1 * sy;\n\n            f32v[offset + (stride * 2)] = w0 * sx;\n            f32v[offset + (stride * 2) + 1] = h0 * sy;\n\n            f32v[offset + (stride * 3)] = w1 * sx;\n            f32v[offset + (stride * 3) + 1] = h0 * sy;\n        ",dynamic:false},position:{attributeName:"aPosition",format:"float32x2",code:"\n            var x = p.x;\n            var y = p.y;\n\n            f32v[offset] = x;\n            f32v[offset + 1] = y;\n\n            f32v[offset + stride] = x;\n            f32v[offset + stride + 1] = y;\n\n            f32v[offset + (stride * 2)] = x;\n            f32v[offset + (stride * 2) + 1] = y;\n\n            f32v[offset + (stride * 3)] = x;\n            f32v[offset + (stride * 3) + 1] = y;\n        ",dynamic:true},rotation:{attributeName:"aRotation",format:"float32",code:"\n            var rotation = p.rotation;\n\n            f32v[offset] = rotation;\n            f32v[offset + stride] = rotation;\n            f32v[offset + (stride * 2)] = rotation;\n            f32v[offset + (stride * 3)] = rotation;\n        ",dynamic:false},uvs:{attributeName:"aUV",format:"float32x2",code:"\n            var uvs = p.texture.uvs;\n\n            f32v[offset] = uvs.x0;\n            f32v[offset + 1] = uvs.y0;\n\n            f32v[offset + stride] = uvs.x1;\n            f32v[offset + stride + 1] = uvs.y1;\n\n            f32v[offset + (stride * 2)] = uvs.x2;\n            f32v[offset + (stride * 2) + 1] = uvs.y2;\n\n            f32v[offset + (stride * 3)] = uvs.x3;\n            f32v[offset + (stride * 3) + 1] = uvs.y3;\n        ",dynamic:false},color:{attributeName:"aColor",format:"unorm8x4",code:"\n            const c = p.color;\n\n            u32v[offset] = c;\n            u32v[offset + stride] = c;\n            u32v[offset + (stride * 2)] = c;\n            u32v[offset + (stride * 3)] = c;\n        ",dynamic:false}};"use strict";const Di=new ze(0,0,0,0);const Ni=class _ParticleContainer extends Xt{
/**
   * @param options - The options for creating the sprite.
   */
constructor(e={}){e={..._ParticleContainer.defaultOptions,...e,dynamicProperties:{..._ParticleContainer.defaultOptions.dynamicProperties,...e?.dynamicProperties}};const{dynamicProperties:t,shader:r,roundPixels:s,texture:n,particles:i,...o}=e;super({label:"ParticleContainer",...o});this.renderPipeId="particle";this.batched=false;this._childrenDirty=false;this.texture=n||null;this.shader=r;this._properties={};for(const e in Li){const r=Li[e];const s=t[e];this._properties[e]={...r,dynamic:s}}this.allowChildren=true;this.roundPixels=s??false;this.particleChildren=i??[]}
/**
   * Adds one or more particles to the container.
   *
   * Multiple items can be added like so: `myContainer.addParticle(thingOne, thingTwo, thingThree)`
   * @param {...IParticle} children - The Particle(s) to add to the container
   * @returns {IParticle} - The first child that was added.
   */addParticle(...e){for(let t=0;t<e.length;t++)this.particleChildren.push(e[t]);this.onViewUpdate();return e[0]}
/**
   * Removes one or more particles from the container.
   * @param {...IParticle} children - The Particle(s) to remove
   * @returns {IParticle} The first child that was removed.
   */removeParticle(...e){let t=false;for(let r=0;r<e.length;r++){const s=this.particleChildren.indexOf(e[r]);if(s>-1){this.particleChildren.splice(s,1);t=true}}t&&this.onViewUpdate();return e[0]}update(){this._childrenDirty=true}onViewUpdate(){this._childrenDirty=true;super.onViewUpdate()}get bounds(){return Di}updateBounds(){}
/**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */destroy(e=false){super.destroy(e);const t=typeof e==="boolean"?e:e?.texture;if(t){const t=typeof e==="boolean"?e:e?.textureSource;const r=this.texture??this.particleChildren[0]?.texture;r&&r.destroy(t)}this.texture=null;this.shader?.destroy()}
/**
   * Removes all particles from this container that are within the begin and end indexes.
   * @param beginIndex - The beginning position.
   * @param endIndex - The ending position. Default value is size of the container.
   * @returns - List of removed particles
   */removeParticles(e,t){const r=this.particleChildren.splice(e,t);this.onViewUpdate();return r}
/**
   * Removes a particle from the specified index position.
   * @param index - The index to get the particle from
   * @returns The particle that was removed.
   */removeParticleAt(e){const t=this.particleChildren.splice(e,1);this.onViewUpdate();return t[0]}
/**
   * Adds a particle to the container at a specified index. If the index is out of bounds an error will be thrown.
   * If the particle is already in this container, it will be moved to the specified index.
   * @param {Container} child - The particle to add.
   * @param {number} index - The absolute index where the particle will be positioned at the end of the operation.
   * @returns {Container} The particle that was added.
   */addParticleAt(e,t){this.particleChildren.splice(t,0,e);this.onViewUpdate();return e}
/**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.addParticle()` instead.
   * @param {...any} _children
   * @throws {Error} Always throws an error as this method is not available.
   */addChild(...e){throw new Error("ParticleContainer.addChild() is not available. Please use ParticleContainer.addParticle()")}
/**
   * This method is not available in ParticleContainer.
   * Calling this method will throw an error. Please use `ParticleContainer.removeParticle()` instead.
   * @param {...any} _children
   * @throws {Error} Always throws an error as this method is not available.
   */removeChild(...e){throw new Error("ParticleContainer.removeChild() is not available. Please use ParticleContainer.removeParticle()")}
/**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.removeParticles()` instead.
   * @param {number} [_beginIndex]
   * @param {number} [_endIndex]
   * @throws {Error} Always throws an error as this method is not available.
   */removeChildren(e,t){throw new Error("ParticleContainer.removeChildren() is not available. Please use ParticleContainer.removeParticles()")}
/**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.removeParticleAt()` instead.
   * @param {number} _index
   * @throws {Error} Always throws an error as this method is not available.
   */removeChildAt(e){throw new Error("ParticleContainer.removeChildAt() is not available. Please use ParticleContainer.removeParticleAt()")}
/**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.getParticleAt()` instead.
   * @param {number} _index
   * @throws {Error} Always throws an error as this method is not available.
   */getChildAt(e){throw new Error("ParticleContainer.getChildAt() is not available. Please use ParticleContainer.getParticleAt()")}
/**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.setParticleIndex()` instead.
   * @param {ContainerChild} _child
   * @param {number} _index
   * @throws {Error} Always throws an error as this method is not available.
   */setChildIndex(e,t){throw new Error("ParticleContainer.setChildIndex() is not available. Please use ParticleContainer.setParticleIndex()")}
/**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.getParticleIndex()` instead.
   * @param {ContainerChild} _child
   * @throws {Error} Always throws an error as this method is not available.
   */getChildIndex(e){throw new Error("ParticleContainer.getChildIndex() is not available. Please use ParticleContainer.getParticleIndex()")}
/**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.addParticleAt()` instead.
   * @param {ContainerChild} _child
   * @param {number} _index
   * @throws {Error} Always throws an error as this method is not available.
   */addChildAt(e,t){throw new Error("ParticleContainer.addChildAt() is not available. Please use ParticleContainer.addParticleAt()")}
/**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.swapParticles()` instead.
   * @param {ContainerChild} _child
   * @param {ContainerChild} _child2
   */swapChildren(e,t){throw new Error("ParticleContainer.swapChildren() is not available. Please use ParticleContainer.swapParticles()")}
/**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error.
   * @param _child - The child to reparent
   * @throws {Error} Always throws an error as this method is not available.
   */reparentChild(...e){throw new Error("ParticleContainer.reparentChild() is not available with the particle container")}
/**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error.
   * @param _child - The child to reparent
   * @param _index - The index to reparent the child to
   * @throws {Error} Always throws an error as this method is not available.
   */reparentChildAt(e,t){throw new Error("ParticleContainer.reparentChildAt() is not available with the particle container")}};Ni.defaultOptions={dynamicProperties:{vertex:false,position:true,rotation:false,uvs:false,color:false},roundPixels:false};let Hi=Ni;"use strict";const Vi=class _NineSliceSprite extends Xt{
/**
   * @param {scene.NineSliceSpriteOptions|Texture} options - Options to use
   * @param options.texture - The texture to use on the NineSliceSprite.
   * @param options.leftWidth - Width of the left vertical bar (A)
   * @param options.topHeight - Height of the top horizontal bar (C)
   * @param options.rightWidth - Width of the right vertical bar (B)
   * @param options.bottomHeight - Height of the bottom horizontal bar (D)
   * @param options.width - Width of the NineSliceSprite,
   * setting this will actually modify the vertices and not the UV's of this plane.
   * @param options.height - Height of the NineSliceSprite,
   * setting this will actually modify the vertices and not UV's of this plane.
   */
constructor(e){e instanceof Ae&&(e={texture:e});const{width:t,height:r,anchor:s,leftWidth:n,rightWidth:i,topHeight:o,bottomHeight:a,texture:u,roundPixels:c,...l}=e;super({label:"NineSliceSprite",...l});this.renderPipeId="nineSliceSprite";this.batched=true;this._leftWidth=n??u?.defaultBorders?.left??$t.defaultOptions.leftWidth;this._topHeight=o??u?.defaultBorders?.top??$t.defaultOptions.topHeight;this._rightWidth=i??u?.defaultBorders?.right??$t.defaultOptions.rightWidth;this._bottomHeight=a??u?.defaultBorders?.bottom??$t.defaultOptions.bottomHeight;this._width=t??u.width??$t.defaultOptions.width;this._height=r??u.height??$t.defaultOptions.height;this.allowChildren=false;this.texture=u??_NineSliceSprite.defaultOptions.texture;this.roundPixels=c??false;this._anchor=new nt({_onUpdate:()=>{this.onViewUpdate()}});s?this.anchor=s:this.texture.defaultAnchor&&(this.anchor=this.texture.defaultAnchor)}get anchor(){return this._anchor}set anchor(e){typeof e==="number"?this._anchor.set(e):this._anchor.copyFrom(e)}get width(){return this._width}set width(e){this._width=e;this.onViewUpdate()}get height(){return this._height}set height(e){this._height=e;this.onViewUpdate()}
/**
   * Sets the size of the NiceSliceSprite to the specified width and height.
   * setting this will actually modify the vertices and UV's of this plane
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */setSize(e,t){if(typeof e==="object"){t=e.height??e.width;e=e.width}this._width=e;this._height=t??e;this.onViewUpdate()}
/**
   * Retrieves the size of the NineSliceSprite as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the NineSliceSprite.
   */getSize(e){e||(e={});e.width=this._width;e.height=this._height;return e}get leftWidth(){return this._leftWidth}set leftWidth(e){this._leftWidth=e;this.onViewUpdate()}get topHeight(){return this._topHeight}set topHeight(e){this._topHeight=e;this.onViewUpdate()}get rightWidth(){return this._rightWidth}set rightWidth(e){this._rightWidth=e;this.onViewUpdate()}get bottomHeight(){return this._bottomHeight}set bottomHeight(e){this._bottomHeight=e;this.onViewUpdate()}get texture(){return this._texture}set texture(e){e||(e=Ae.EMPTY);const t=this._texture;if(t!==e){t&&t.dynamic&&t.off("update",this.onViewUpdate,this);e.dynamic&&e.on("update",this.onViewUpdate,this);this._texture=e;this.onViewUpdate()}}get originalWidth(){return this._texture.width}get originalHeight(){return this._texture.height}
/**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */destroy(e){super.destroy(e);const t=typeof e==="boolean"?e:e?.texture;if(t){const t=typeof e==="boolean"?e:e?.textureSource;this._texture.destroy(t)}this._texture=null}updateBounds(){const e=this._bounds;const t=this._anchor;const r=this._width;const s=this._height;e.minX=-t._x*r;e.maxX=e.minX+r;e.minY=-t._y*s;e.maxY=e.minY+s}};Vi.defaultOptions={texture:Ae.EMPTY};let Wi=Vi;class NineSlicePlane extends Wi{constructor(...e){let t=e[0];if(t instanceof Ae){ye(Te,"NineSlicePlane now uses the options object {texture, leftWidth, rightWidth, topHeight, bottomHeight}");t={texture:t,leftWidth:e[1],topHeight:e[2],rightWidth:e[3],bottomHeight:e[4]}}ye(Te,"NineSlicePlane is deprecated. Use NineSliceSprite instead.");super(t)}}"use strict";function ensureTextStyle(e,t){return t instanceof We||t instanceof qt?t:e==="html"?new qt(t):new We(t)}"use strict";"use strict";"use strict";"use strict";async function logDebugTexture(e,t,r=200){const s=await t.extract.base64(e);await t.encoder.commandFinished;const n=r;console.log(`logging texture ${e.source.width}px ${e.source.height}px`);const i=["font-size: 1px;",`padding: ${n}px 300px;`,`background: url(${s}) no-repeat;`,"background-size: contain;"].join(" ");console.log("%c ",i)}"use strict";const ji=["#000080","#228B22","#8B0000","#4169E1","#008080","#800000","#9400D3","#FF8C00","#556B2F","#8B008B"];let zi=0;function logScene(e,t=0,r={color:"#000000"}){e.renderGroup&&(r.color=ji[zi++]);let s="";for(let e=0;e<t;e++)s+="    ";let n=e.label;!n&&e instanceof st&&(n=`sprite:${e.texture.label}`);let i=`%c ${s}|- ${n} (worldX:${e.worldTransform.tx}, relativeRenderX:${e.relativeGroupTransform.tx}, renderX:${e.groupTransform.tx}, localX:${e.x})`;e.renderGroup&&(i+=" (RenderGroup)");e.filters&&(i+="(*filters)");console.log(i,`color:${r.color}; font-weight:bold;`);t++;for(let s=0;s<e.children.length;s++){const n=e.children[s];logScene(n,t,{...r})}}function logRenderGroupScene(e,t=0,r={index:0,color:"#000000"}){let s="";for(let e=0;e<t;e++)s+="    ";const n=`%c ${s}- ${r.index}: ${e.root.label} worldX:${e.worldTransform.tx}`;console.log(n,`color:${r.color}; font-weight:bold;`);t++;for(let s=0;s<e.renderGroupChildren.length;s++){const n=e.renderGroupChildren[s];logRenderGroupScene(n,t,{...r,index:s})}}"use strict";"use strict";"use strict";Y.add(Qt,Zt);export{we as AbstractBitmapFont,ae as AbstractRenderer,ds as AlphaFilter,AlphaMaskPipe,sr as Application,ApplicationInitHook,qr as Assets,AssetsClass,ks as BUFFER_TYPE,BackgroundLoader,Gn as BackgroundSystem,Vt as BatchableSprite,Fs as BatcherPipe,Bt as BigPool,jt as BindGroup,BindGroupSystem,BitmapFont,Me as BitmapFontManager,BlendModePipe,BlurFilter,_s as BlurFilterPass,ze as Bounds,Ut as Buffer,Dt as BufferResource,Mt as BufferUsage,ue as CLEAR,Ie as Cache,He as CanvasPool,Ht as CanvasSource,je as Color,ColorMaskPipe,ColorMatrixFilter,le as Container,is as Culler,CullerPlugin,CustomRenderPipe,er as DATA_URI,xi as DEPRECATED_SCALE_MODES,gi as DEPRECATED_WRAP_MODES,ve as DOMAdapter,pi as DRAW_MODES,ct as DefaultBatcher,DisplacementFilter,X as ExtensionType,Cn as ExtractSystem,re as Filter,he as FilterEffect,hs as GAUSSIAN_VALUES,Ns as GL_FORMATS,Hs as GL_TARGETS,Ws as GL_TYPES,Vs as GL_WRAP_MODES,GenerateTextureSystem,Ft as Geometry,Ks as GlBackBufferSystem,GlBatchAdaptor,GlBuffer,GlBufferSystem,GlColorMaskSystem,Ds as GlContextSystem,GlEncoderSystem,GlGeometrySystem,GlGraphicsAdaptor,GlMeshAdaptor,Ke as GlProgram,GlRenderTarget,GlRenderTargetAdaptor,GlRenderTargetSystem,Lt as GlShaderSystem,un as GlStateSystem,GlStencilSystem,GlTexture,GlTextureSystem,Ot as GlUboSystem,kt as GlUniformGroupSystem,GlobalUniformSystem,GpuBatchAdaptor,Zn as GpuBlendModesToPixi,GpuBufferSystem,GpuColorMaskSystem,GpuDeviceSystem,GpuEncoderSystem,GpuGraphicsAdaptor,GpuMeshAdapter,GpuMipmapGenerator,Ye as GpuProgram,GpuReadBuffer,GpuRenderTarget,GpuRenderTargetAdaptor,GpuRenderTargetSystem,GpuShaderSystem,GpuStateSystem,$s as GpuStencilModesToPixi,GpuStencilSystem,GpuTextureSystem,Nt as GpuUboSystem,GpuUniformBatchPipe,De as GraphicsContext,Ve as GraphicsPath,qt as HTMLTextStyle,HelloSystem,Le as ImageSource,Loader,Se as LoaderParserPriority,mi as MSAA_QUALITY,MaskFilter,et as Matrix,it as Mesh,Yt as MeshGeometry,MeshPlane,Ii as MeshRope,MeshSimple,$t as NineSliceGeometry,NineSlicePlane,Wi as NineSliceSprite,As as NoiseFilter,nt as ObservablePoint,ki as Particle,Hi as ParticleContainer,wi as PerspectiveMesh,PerspectivePlaneGeometry,PipelineSystem,Kt as PlaneGeometry,rt as Point,Ee as Rectangle,RenderContainer,RenderGroupPipe,RenderGroupSystem,Gi as RenderLayer,vi as RenderLayerClass,Zs as RenderTarget,RenderTargetSystem,RenderTexture,On as RenderableGCSystem,RendererInitHook,Je as RendererType,ke as Resolver,Fi as RopeGeometry,bi as SCALE_MODES,wt as STENCIL_MODES,SchedulerSystem,ScissorMask,$e as Shader,Vn as SharedRenderPipes,Hn as SharedSystems,st as Sprite,SpritePipe,ot as State,StencilMaskPipe,ce as SystemRunner,We as TextStyle,Ae as Texture,Ln as TextureGCSystem,Pe as TextureMatrix,Ze as TexturePool,Ce as TextureSource,TextureUvs,zt as Ticker,Triangle,me as UPDATE_BLEND,fe as UPDATE_COLOR,pe as UPDATE_VISIBLE,UboBatch,qe as UniformGroup,tr as VERSION,J as VideoSource,Xt as ViewContainer,Nn as ViewSystem,_i as WRAP_MODES,WebGLRenderer,WebGPURenderer,os as WebWorkerAdapter,Hr as WorkerManager,ee as addMaskBounds,te as addMaskLocalBounds,us as alphaFrag,cs as alphaWgsl,applyProjectiveTransformationToPlane,applyStyleParams,xe as assignWithIgnore,autoDetectRenderer,be as bgr2rgb,ur as bitmapFontCachePlugin,nr as bitmapFontTextParser,ir as bitmapFontXMLParser,or as bitmapFontXMLStringParser,ei as blockDataMap,ms as blurTemplateWgsl,Qt as browserExt,gt as buildCircle,buildGeometryFromPath,xt as buildPolygon,bt as buildRectangle,St as buildSimpleUvs,_t as buildTriangle,Tt as buildUvs,lr as cacheTextureArray,calculateProjection,checkDataUrl,ie as checkExtension,cleanArray,cleanHash,clearList,collectAllRenderables,Wt as color32BitToUniform,ft as colorBit,lt as colorBitGl,xs as colorMatrixFilterFrag,bs as colorMatrixFilterWgsl,_n as compareModeToGlCompare,vt as compileHighShaderGlProgram,Et as compileHighShaderGpuProgram,compute2DProjection,convertFormatIfRequired,Ue as convertToList,$ as copySearchParams,Qe as createIdFromString,createLevelBuffers,createLevelBuffersFromKTX,oe as createTexture,crossOrigin,as as defaultFilterVert,Be as definedProps,ye as deprecation,dr as detectAvif,pr as detectDefaults,mr as detectMp4,gr as detectOgv,Z as detectVideoAlphaMode,_r as detectWebm,xr as detectWebp,determineCrossOrigin,ys as displacementFrag,Ts as displacementVert,Ss as displacementWgsl,ensureAttributes,ensureTextStyle,executeInstructions,Y as extensions,pt as fastCopy,formatShader,generateBlurFragSource,generateBlurGlProgram,generateBlurProgram,generateBlurVertSource,generateGPULayout,generateLayout,mt as generateTextureBatchBit,dt as generateTextureBatchBitGl,generateUID,It as getAttributeInfoFromFormat,ht as getBatchSamplersUniformGroup,getCanvasTexture,getFastGlobalBounds,getFontFamilyName,getGlTypeFromFormat,de as getGlobalBounds,_e as getLocalBounds,at as getMaxTexturesPerBatch,getResolutionOfUrl,ut as getTextureBatchBindGroup,getTextureDefaultMatrix,getTextureFormatFromKTXTexture,glFormatToGPUFormat,cn as glUploadBufferImageResource,dn as glUploadCompressedTextureResource,hn as glUploadImageResource,pn as glUploadVideoResource,gpuFormatToBasisTranscoderFormat,gpuFormatToKTXBasisTranscoderFormat,Jn as gpuUploadBufferImageResource,ri as gpuUploadCompressedTextureResource,si as gpuUploadImageResource,ni as gpuUploadVideoResource,Re as groupD8,hasCachedCanvasTexture,Bs as hslWgsl,isRenderingToScreen,Oe as isSingleItem,ne as isWebGLSupported,se as isWebGPUSupported,cr as loadBitmapFont,loadImageBitmap,Tr as loadJson,Fr as loadSvg,jr as loadTextures,Gr as loadTxt,Yr as loadVideoTextures,Br as loadWebFont,Rt as localUniformBit,Pt as localUniformBitGl,Ct as localUniformBitGroup2,logDebugTexture,logRenderGroupScene,logScene,mapFormatToGlFormat,mapFormatToGlInternalFormat,mapFormatToGlType,mapSize,mapWebGLBlendModesToPixi,Ps as maskFrag,Cs as maskVert,Rs as maskWgsl,migrateFragmentFromV7toV8,mn as mipmapScaleModeToGlFilter,mixHexColors,ge as multiplyColors,vs as noiseFrag,Gs as noiseWgsl,parseFunctionBody,Li as particleData,Ge as path,preloadVideo,$r as resolveJsonUrl,Kr as resolveTextureUrl,At as roundPixelsBit,Gt as roundPixelsBitGl,sayHello,fn as scaleModeToGlFilter,Ne as squaredDistanceToLineSegment,testImageFormat,testVideoFormat,Us as textureBit,Is as textureBitGl,yt as transformVertices,tt as uid,unpremultiplyAlpha$1 as unpremultiplyAlpha,updateLocalTransform,updateRenderGroupTransform,updateRenderGroupTransforms,updateTransformAndChildren,updateWorldTransform,Te as v8_0_0,validateRenderables,viewportFromFrame,vkFormatToGPUFormat,Fe as warn,Zt as webworkerExt,gn as wrapModeToGlAddress};

